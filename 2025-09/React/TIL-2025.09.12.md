# TIL - 2025.09.12 - 전역 상태 관리(Zustand)와 백엔드 연동을 통한 CRUD 구현 개념 이해

## 카테고리 🏷️
#TIL #React #JavaScript #Zustand #StateManagement #Spring #Java #JPA #QueryDSL #RESTAPI

---

## 오늘 배운 내용 🔍

*   Zustand를 이용한 클라이언트 전역 상태 관리 (`persist` 미들웨어 활용)
*   인증 상태에 따라 접근을 제어하는 비공개 라우트(`PrivateRoute`) 컴포넌트 설계
*   `react-router-dom`의 `loader`를 이용한 페이지 진입 전 데이터 사전 처리
*   다대다(M:N) 관계를 해소하기 위한 연결 엔티티(`RoomParticipant`) 설계 및 단방향 매핑 전략
*   QueryDSL의 `LEFT JOIN`, `groupBy`, DTO 프로젝션을 활용한 집계 쿼리 구현
*   **React 컴포넌트의 다양한 UI 상태 처리 (로딩, 빈 상태, 에러)**
*   **비동기 처리 시 중복 제출 방지를 위한 `submitting` 상태 관리 패턴**
*   **`touched` 상태를 활용한 실시간 입력값 검증 UX 개선**
*   `useRef`와 `useEffect`를 이용한 전역 이벤트 처리 (외부 클릭, ESC 키)

---

## 어려웠던 점 💣

*   스터디룸과 참여자의 다대다 관계를 설계할 때, 양방향 연관 관계를 설정하지 않고 연결 엔티티에서 단방향으로만 매핑한 이유를 이해하는 데 시간이 걸렸다. 주석에 설명된 것처럼, 이는 불필요한 양방향 컬렉션 관리의 복잡성을 줄이고, N+1 문제 발생 가능성을 낮추며, Jackson 직렬화 시 순환 참조 문제를 원천적으로 방지하는 실무적인 설계 선택임을 알게 되었다.

*   React의 컴포넌트 내부 상태(`useState`)와 Zustand를 이용한 전역 상태 중 어떤 것을 사용해야 할지 판단하는 기준이 모호했다. 스터디룸 생성 모달의 열림 여부(`modalOpen`)나 입력값(`title`)처럼 특정 컴포넌트 내에서만 사용되는 상태는 `useState`로 관리하고, 여러 페이지에 걸쳐 공유되어야 하는 스터디룸 목록(`rooms`) 같은 데이터는 Zustand로 관리하는 것이 적합하다는 것을 깨달았다.

*   QueryDSL로 스터디룸 목록과 각 방의 참여자 수를 한 번에 조회하는 쿼리를 작성하는 것이 복잡했다. 참여자가 없는 방도 목록에 포함시켜야 했기 때문에 `LEFT JOIN`을 사용해야 했고, 참여자 수를 정확히 세기 위해 `countDistinct`를 사용해야 했다. 또한, 이 집계 결과를 엔티티가 아닌 별도의 DTO로 매핑하기 위해 `Projections.constructor`를 활용하는 등 여러 개념을 종합적으로 적용해야 했다.

*   `CreateRoomModal` 컴포넌트 하나를 구현하는 데 생각보다 많은 상태(`open`, `submitting`, `title`, `description`, `touched`, `errorMessage`)가 필요하다는 점을 알게 되었다. 단순히 UI를 보여주는 것을 넘어, 사용자의 상호작용 흐름에 따라 로딩 상태를 표시하고, 중복 제출을 막고, 적절한 타이밍에 유효성 검사 피드백을 주는 등 섬세한 상태 설계가 좋은 UX의 기반이 됨을 확인했다.

*   `useEffect`의 클린업(cleanup) 함수의 중요성을 다시 한번 확인했다. 모달에서 ESC 키 이벤트를 감지하기 위해 `document`에 이벤트 리스너를 추가했을 때, 컴포넌트가 언마운트될 때 `removeEventListener`를 호출해주지 않으면 메모리 누수가 발생하고 예기치 않은 버그를 유발할 수 있다는 점을 인지했다.

---

## 정리 🖇️

### 1. Zustand를 이용한 전역 상태 관리

`useState`와 `props`만으로는 관리하기 어려운 전역 상태(e.g., 로그인 정보, 공통 데이터)를 컴포넌트 트리와 독립적으로 관리하는 방법을 학습했다.

*   **학습 목표 (Why?)**:
    Prop Drilling(여러 계층에 걸쳐 props를 계속 전달하는 문제)을 해결하고, 애플리케이션의 어느 컴포넌트에서든 상태에 쉽게 접근하고 업데이트할 수 있는 중앙 집중식 상태 관리 저장소를 구축하기 위함이다.

*   **핵심 원리 (What?)**:
  *   **Zustand**: 가볍고 간결한 API를 제공하는 React 상태 관리 라이브러리. `create` 함수를 사용하여 스토어(store)를 생성한다.
  *   **스토어(Store)**: 상태(state)와 상태를 변경하는 액션(action)을 모두 포함하는 객체.
  *   **훅(Hook) 기반 사용**: `const rooms = useRoomStore(state => state.rooms)` 와 같이 훅을 사용하여 컴포넌트가 스토어의 특정 상태를 구독(subscribe)하게 할 수 있다. 해당 상태가 변경되면 컴포넌트는 자동으로 리렌더링된다.
  *   **미들웨어(`persist`)**: 스토어의 상태를 `localStorage`나 `sessionStorage`에 자동으로 저장하고 복원해주는 미들웨어. 페이지를 새로고침해도 상태가 유지된다.
    *   `partialize`: `persist` 미들웨어의 옵션으로, 스토어의 여러 상태 중 영속화할 상태만 선별하여 저장할 수 있다.

*   **문법 및 사용법 (How?)**:
  ```javascript
  // stores/authStore.js
  import { create } from 'zustand';
  import { persist } from 'zustand/middleware';

  export const useAuthStore = create(
    persist(
      (set) => ({
        user: null,
        isAuthenticated: false,
        fetchMe: async () => { /* ... */ },
        logout: () => { /* ... */ },
      }),
      {
        name: 'auth-storage',
        partialize: (state) => ({
          user: state.user,
          isAuthenticated: state.isAuthenticated,
        }),
      }
    )
  );
  ```

*   **주의사항 및 실무 팁 (Watch out for)**:
  *   모든 상태를 전역으로 관리하는 것은 오히려 복잡성을 증가시킬 수 있다. 특정 컴포넌트나 그 하위에서만 사용되는 상태는 `useState`를 사용하는 것이 좋다.
  *   `persist`를 사용할 때, 로딩이나 에러 상태처럼 일시적인 상태는 `partialize`를 통해 영속화 대상에서 제외하는 것이 일반적이다.

---

### 2. 비공개 라우트(Private Route)와 라우터 로더(Loader)

인증된 사용자만 접근할 수 있는 페이지를 보호하고, 페이지 진입 전 데이터 로딩이나 조건을 검사하는 방법을 학습했다.

*   **학습 목표 (Why?)**:
    권한에 따라 페이지 접근을 제어하여 애플리케이션의 보안을 강화하고, 특정 조건(e.g., 이미 로그인된 사용자가 로그인 페이지에 접근)에 따라 자동으로 리다이렉트 시켜 사용자 경험을 개선하기 위함이다.

*   **핵심 원리 (What?)**:
  *   **`PrivateRoute` 컴포넌트**: 라우트 컴포넌트를 감싸는 래퍼 컴포넌트.
    1.  내부적으로 전역 인증 스토어(`useAuthStore`)를 구독하여 인증 상태를 확인한다.
    2.  인증 상태를 확인하는 동안에는 로딩 UI(스플래시 스크린, 스켈레톤)를 보여준다.
    3.  인증되었다면, `props`로 전달받은 `children`(실제 페이지 컴포넌트)을 렌더링한다.
    4.  인증되지 않았다면, `<Navigate>` 컴포넌트를 사용하여 로그인 페이지로 리다이렉트시킨다.
  *   **라우터 로더(`loader`)**: `react-router-dom`의 기능으로, 특정 라우트의 컴포넌트가 **렌더링되기 전에** 실행되는 비동기 함수. `redirect`를 반환하여 페이지 진입을 막고 다른 경로로 이동시킬 수 있다.

*   **문법 및 사용법 (How?)**:
  ```jsx
  // components/PrivateRoute.jsx
  import { Navigate } from 'react-router-dom';
  import { useAuthStore } from '../stores/authStore';
  
  const PrivateRoute = ({ children }) => {
    const { isAuthenticated, hasCheckedAuth } = useAuthStore();
  
    if (!hasCheckedAuth) return <div>Loading...</div>;
    return isAuthenticated ? children : <Navigate to="/" replace />;
  };

  // routes/router-config.jsx
  import { loginLoader } from '../loaders/authLoaders.js';
  export const router = createBrowserRouter([
    { path: '/', element: <LoginPage />, loader: loginLoader },
    { path: '/app', element: <PrivateRoute><AppLayout /></PrivateRoute> },
  ]);
  ```

*   **주의사항 및 실무 팁 (Watch out for)**:
  *   `PrivateRoute`에서 최초 인증 상태를 확인하는 동안 로딩 상태를 제대로 처리하지 않으면, 인증되지 않은 화면이 잠깐 보였다가 리다이렉트되는 현상(flickering)이 발생할 수 있다. `hasCheckedAuth` 같은 플래그 상태를 두어 이를 방지하는 것이 중요하다.

---

### 3. React 컴포넌트 심화: UI 상태와 사용자 경험(UX)

단순 렌더링을 넘어, 로딩, 에러, 유효성 검증 등 다양한 UI 상태를 관리하여 사용자 경험을 향상시키는 실무적인 패턴들을 학습했다.

*   **학습 목표 (Why?)**:
    사용자에게 현재 애플리케이션의 상태를 명확하게 피드백하고, 비동기 작업 중 발생할 수 있는 오류나 중복 액션을 방지하여 안정적이고 직관적인 UI를 제공하기 위함이다.

*   **핵심 원리 (What?)**:
  *   **UI 상태 분기**: `loading` 상태를 두어 API 호출 중에는 **스켈레톤(Skeleton) UI**를, 데이터가 없을 때는 **빈 상태(Empty State) UI**를, 에러 발생 시에는 **에러 UI**를 조건부 렌더링한다. 이는 사용자에게 막연한 기다림 대신 명확한 피드백을 제공한다.
  *   **비동기 작업 중복 실행 방지**: API 요청과 같은 비동기 작업을 수행할 때 `submitting`과 같은 boolean 상태를 활용한다. 작업이 시작되면 `true`로 설정하여 버튼을 비활성화하고, 작업이 완료되면(`finally` 블록에서) `false`로 설정하여 다시 활성화한다. 이를 통해 사용자가 버튼을 여러 번 클릭하여 중복된 요청을 보내는 것을 방지할 수 있다.
  *   **고급 폼 유효성 검증 (Touched State)**: `touched` 상태를 두어 사용자가 특정 입력 필드를 한 번이라도 건드렸는지(`onBlur` 이벤트) 추적한다. 유효성 검사 에러 메시지는 `touched`가 `true`일 때만 보여줌으로써, 사용자가 입력을 시작하기도 전에 에러 메시지가 노출되는 나쁜 경험을 방지한다.
  *   **전역 이벤트 처리 (`useRef`, `useEffect`)**: 드롭다운 메뉴의 외부 클릭 감지나 모달의 ESC 키 입력 감지처럼 컴포넌트 외부에서 발생하는 이벤트를 처리해야 할 때 사용된다. `useRef`로 특정 DOM 요소를 참조하고, `useEffect` 내에서 `document`에 이벤트 리스너를 등록한다. 컴포넌트가 사라질 때(unmount) 반드시 **클린업 함수**에서 이벤트 리스너를 제거하여 메모리 누수를 방지해야 한다.

*   **문법 및 사용법 (How?)**:
  ```jsx
  // CreateRoomModal.jsx - 중복 제출 방지 및 Touched State 활용
  const CreateRoomModal = ({ open, onSubmit }) => {
    const [submitting, setSubmitting] = useState(false);
    const [title, setTitle] = useState('');
    const [touched, setTouched] = useState({ title: false });
    const titleError = useMemo(() => {
        if (!touched.title || title.trim()) return '';
        return '방 제목을 입력해주세요.';
    }, [title, touched.title]);
  
    const handleSubmit = async (e) => {
      e.preventDefault();
      setTouched({ title: true }); // 제출 시 모든 필드를 touched로 간주
      if (submitting || titleError) return;

      try {
        setSubmitting(true);
        await onSubmit({ title });
      } finally {
        setSubmitting(false);
      }
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <input 
          value={title} 
          onChange={(e) => setTitle(e.target.value)}
          onBlur={() => setTouched(prev => ({ ...prev, title: true }))}
        />
        {titleError && <p className="error-text">{titleError}</p>}
        <button type="submit" disabled={submitting}>
          {submitting ? '생성 중...' : '방 생성'}
        </button>
      </form>
    );
  };
  ```

*   **주의사항 및 실무 팁 (Watch out for)**:
  *   로딩 상태를 보여주기 위해 `setTimeout`으로 API 호출을 의도적으로 지연시키는 것은 개발 단계에서 UI를 확인하기 위한 **목(mock) 설계**이며, 실제 프로덕션 코드에서는 제거해야 한다.
  *   이미지 로딩 실패 시 `onError` 이벤트를 활용하여 대체 이미지나 UI(e.g., 사용자 이름의 이니셜)를 보여주는 **폴백(Fallback)** 처리는 사용자 경험을 크게 향상시킨다.

---

### 4. 백엔드: 연결 엔티티와 집계 쿼리 설계

스터디룸과 참여자의 다대다 관계를 모델링하고, 목록 조회 시 N+1 문제 없이 참여자 수를 함께 조회하는 효율적인 쿼리를 설계했다.

*   **학습 목표 (Why?)**:
    복잡한 도메인 관계를 JPA 엔티티로 올바르게 표현하고, 목록 조회와 같은 흔한 기능에서 발생할 수 있는 성능 문제를 데이터베이스 쿼리 레벨에서 최적화하기 위함이다.

*   **핵심 원리 (What?)**:
  *   **연결 엔티티(`RoomParticipant`)**: `StudyRoom`과 `User`의 다대다 관계를 `1:N - N:1` 관계로 해소한다. 이 엔티티에 참여 역할(`role`), 상태(`status`) 등 관계에 대한 추가 데이터를 저장할 수 있다.
  *   **단방향 연관 관계**: `RoomParticipant`에서만 `StudyRoom`과 `User`를 참조(`@ManyToOne`)하고, `StudyRoom`이나 `User`에서는 `RoomParticipant` 목록을 컬렉션으로 갖지 않는 방식. 이는 불필요한 양방향 동기화 로직을 제거하고 N+1 문제 발생 가능성을 줄이는 실무적인 설계이다.
  *   **QueryDSL 집계 쿼리**: `LEFT JOIN`, `groupBy`, `countDistinct`, DTO 프로젝션을 사용하여 스터디룸 목록과 각 방의 참여자 수를 한 번의 쿼리로 효율적으로 조회한다.

*   **문법 및 사용법 (How?)**:
  ```java
  // StudyRoomRepositoryImpl.java
  @Repository
  @RequiredArgsConstructor
  public class StudyRoomRepositoryImpl implements StudyRoomRepositoryCustom {
      private final JPAQueryFactory queryFactory;
  
      @Override
      public Page<StudyRoomWithParticipantCount> searchRooms(...) {
          List<StudyRoomWithParticipantCount> content = queryFactory
              .select(Projections.constructor(
                  StudyRoomWithParticipantCount.class,
                  studyRoom.id,
                  studyRoom.title,
                  roomParticipant.id.countDistinct() // 참여자 수 집계
              ))
              .from(studyRoom)
              .leftJoin(roomParticipant).on(roomParticipant.room.eq(studyRoom))
              .where( /* ... 동적 조건 ... */ )
              .groupBy(studyRoom.id) // 스터디룸 ID로 그룹화
              .fetch();
          
          return new PageImpl<>(content, pageable, total);
      }
  }
  ```

*   **주의사항 및 실무 팁 (Watch out for)**:
  *   목록 조회 시 엔티티를 직접 반환하고 서비스 레이어에서 참여자 수를 각각 조회하면 심각한 N+1 문제를 유발한다. 처음부터 Repository 레벨에서 필요한 데이터를 모두 JOIN하고 DTO로 프로젝션하는 것이 성능상 매우 중요하다.
  *   `User`가 스터디룸을 생성하면, 해당 `User`는 자동으로 `HOST` 역할의 `RoomParticipant`로 함께 등록되는 비즈니스 로직을 서비스 레이어의 단일 트랜잭션(`@Transactional`) 내에서 처리하여 데이터 정합성을 보장해야 한다.

---

## 오늘의 깨달음 💡

*   전역 상태 관리 라이브러리(Zustand)는 Prop Drilling 문제를 해결하는 강력한 도구이지만, 모든 상태를 전역으로 만드는 것이 능사는 아니었다. 모달의 열림 여부처럼 특정 컴포넌트에 종속된 상태는 여전히 `useState`를 사용하는 것이 코드의 응집도를 높이고 추적을 용이하게 했다.

*   `PrivateRoute`와 같은 보호 장치는 단순히 '인증 여부'라는 boolean 값 하나로 동작하는 것이 아니었다. '최초 인증 상태 확인 중'이라는 로딩 상태, '로그인 직후'라는 특수 상태 등 다양한 엣지 케이스를 고려해야 사용자에게 부드러운 화면 전환 경험을 제공할 수 있음을 깨달았다.

*   JPA에서 양방향 연관 관계는 편리한 객체 그래프 탐색을 제공하지만, 그만큼 동기화 관리, N+1 문제, 직렬화 문제 등 고려해야 할 비용이 크다는 것을 알게 되었다. 현재 요구사항에 맞춰 단방향 관계로 시작하고, 정말 필요한 시점에 양방향을 고려하는 것이 더 실용적이고 안전한 설계 전략일 수 있다.

*   프론트엔드에서 '로딩 상태'를 잘 처리하는 것이 사용자 경험에 미치는 영향이 매우 크다는 것을 체감했다. API 호출이 시작될 때 스켈레톤 UI를 보여주고, 완료되면 실제 데이터를 렌더링하는 패턴은 사용자의 막연한 기다림을 시각적인 피드백으로 바꿔주는 중요한 장치였다.