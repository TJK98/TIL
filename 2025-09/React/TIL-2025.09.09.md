# TIL - 2025.09.09 - React.memo · useCallback 최적화, 리스트 키, Zustand 스토어 개념 이해

## 카테고리 🏷️

#TIL #React #ReactMemo #useCallback #Memoization #Rendering #Keys #Zustand #StateManagement #ContextAPI

---

## 오늘 배운 내용 🔍

* `React.memo`로 자식 컴포넌트의 불필요한 재렌더링을 차단함
* 비싼 계산(`isPrime`)은 상위 상태 변경과 분리하고, 자식/형제 렌더를 `memo`로 억제함
* 이벤트 핸들러를 `useCallback`으로 고정해 props 참조 안정성 확보함
* 리스트 `key`를 `index` → **안정 id**로 교체하여 항목 상태 보존 및 재배치 성능 개선함
* 상태 변경 이력(`counterChanges`)을 누적하고 **총합만 계산**하는 패턴으로 UI와 계산 책임을 분리함
* `IconButton`, `Header`, `Counter` 등 렌더 경로를 분리하고 필요한 곳에만 `memo`를 적용함
* Zustand로 **Provider 없이** 전역 스토어 구성, 선택자 구독과 액션 분리로 리렌더 최소화함
* `persist` 미들웨어로 인증의 최소 상태만 로컬 저장하고 민감정보는 저장하지 않도록 설계함

---

## 어려웠던 점 💣

* `React.memo`가 **얕은 비교**만 수행한다는 점을 간과해, 객체/배열 props가 새 참조로 생성되면 메모가 무력화됨

* 자식에 `onClick={() => handle(item)}` 형태로 **매 렌더 새 함수**를 넘겨 `memo` 효과가 사라지는 문제를 경험함

* `Counter` 초기값 변경 시 내부 상태 동기화 문제로 `key={chosenCount}` 전략을 이해하는 데 시간이 필요했음

---

## 정리 🖇️

### 1. React.memo로 자식 컴포넌트 실행 최소화

**학습 목표 (Why?)**

자식이 상위의 무관한 상태 변경에 의해 매번 렌더되는 낭비를 줄여 UI 응답성을 높이기 위함.

**핵심 원리 (What?)**

`React.memo(Component, areEqual?)`는 **props 얕은 비교** 결과 변경이 없으면 렌더를 건너뜀. 두 번째 인자로 **커스텀 비교** 제공 가능.

**문법 및 사용법 (How?)**

```jsx
const Header = React.memo(function Header() {
  // ...
});

const IconButton = React.memo(function IconButton({ icon: Icon, ...props }) {
  return <button {...props}><Icon /></button>;
});
```

필요 시 커스텀 비교:

```jsx
const Row = React.memo(
  RowBase,
  (prev, next) => prev.item.id === next.item.id && prev.onClick === next.onClick
);
```

**주의사항 및 실무 팁 (Watch out for)**

* **새 참조 생성 주의**: 객체/배열/함수 props는 참조가 바뀌면 `memo`가 무력화됨 → `useMemo`/`useCallback`으로 고정.
* **남용 금지**: 비교 비용이 이득을 상회할 수 있음. **빈번하지만 내용이 안 바뀌는** 컴포넌트에 선별 적용.
* **스타일/클래스 병합**에 inline 객체 생성 지양(매번 새 참조).

---

### 2. useCallback으로 함수 재생성 방지

**학습 목표 (Why?)**

자식에 전달하는 핸들러 참조를 **안정**시키고, `React.memo`와 조합해 재렌더를 줄임.

**핵심 원리 (What?)**

`useCallback(fn, deps)`는 `deps`가 바뀌지 않는 한 **동일 함수 참조**를 반환.

**문법 및 사용법 (How?)**

```jsx
const increment = useCallback(() => {
  setCount(c => c + 1); // 외부 의존 없음 → []
}, []);

const selectItem = useCallback((id) => {
  // id는 인자이므로 deps 불필요
}, []);
```

**주의사항 및 실무 팁 (Watch out for)**

* **의존성 정확도**가 핵심. 콜백이 사용하는 외부 값은 모두 deps에 포함.
* 자식에서 `onClick={() => handler(item)}`는 여전히 **새 함수**. 대안:

  * 자식 API를 `onClick` → `onSelect`로 바꿔 **자식 내부에서** `onSelect(item.id)` 호출하게 설계(부모는 안정 핸들러만 전달).
  * 또는 **프리바운드 맵**을 메모이즈(`useMemo`)해 항목별 핸들러 참조를 고정.

---

### 3. 리스트 key 안정화와 항목 상태 보존

**학습 목표 (Why?)**

항목 재정렬/추가/삭제 시 **불필요한 재마운트**를 방지하고 항목 내부 상태(선택 여부 등)를 보존.

**핵심 원리 (What?)**

`key`는 **항목의 정체성**. `index`는 정렬/삽입에 취약. **불변 id** 사용.

**문법 및 사용법 (How?)**

```jsx
<HistoryItem key={id} count={value} />
```

**주의사항 및 실무 팁 (Watch out for)**

* 서버/스토어에서 **정말로 안정**적인 id를 생성. 임시 `Math.random()`은 재생성 시 달라짐.
* 정렬/필터링이 잦은 컬렉션일수록 `index` 키 사용 금지.

---

### 4. 비싼 계산과 렌더 경로 분리

**학습 목표 (Why?)**

`isPrime(initialCount)` 같은 비싼 계산이 **무관한 상태 변화**에 의해 재실행되는 것을 방지.

**핵심 원리 (What?)**

* 비싼 계산은 **입력 의존성**으로 `useMemo` 메모이즈
* 계산을 쓰는 영역만 `memo`로 **렌더 경로 분리**

**문법 및 사용법 (How?)**

```jsx
const initialCountIsPrime = useMemo(
  () => isPrime(initialCount),
  [initialCount]
);
```

**주의사항 및 실무 팁 (Watch out for)**

* `useMemo`는 **캐시 힌트**일 뿐. 비용이 낮으면 쓰지 않는다.
* 상위의 빈번한 상태 변경이 하위 전체를 깨우지 않도록 **컴포넌트 쪼개기 + memo** 병행.

---

### 5. 상태 이력 누적과 총합 계산 패턴

**학습 목표 (Why?)**

로그(±1 등)를 누적 보관하고 파생 값(총합)을 계산해 **표현과 저장을 분리**.

**핵심 원리 (What?)**

* 소스는 **이벤트 시퀀스**
* 파생 값은 `reduce`로 계산
* 렌더 최적화는 리스트 `memo` + 안정 `key`

**문법 및 사용법 (How?)**

```jsx
const [changes, setChanges] = useState([{ id, value: initial }]);

const total = useMemo(
  () => changes.reduce((acc, cur) => acc + cur.value, 0),
  [changes]
);
```

**주의사항 및 실무 팁 (Watch out for)**

* 로그가 커지면 **페이지네이션/가상 스크롤** 고려.
* `id`는 **항목 식별**용, 표시 값은 `value`로 분리.

---

### 6. Counter 초기화와 key 전략

**학습 목표 (Why?)**

부모가 초기 카운트를 바꿔도 내부 로컬 상태가 **초기값으로 재동기화**되도록 보장.

**핵심 원리 (What?)**

* 내부에서 `useState(initialCount)`를 쓰면 이후 prop 변경이 반영되지 않음
* `key={initialCount}`로 컴포넌트 재마운트 → 초기화 보장

**문법 및 사용법 (How?)**

```jsx
<Counter key={chosenCount} initialCount={chosenCount} />
```

**주의사항 및 실무 팁 (Watch out for)**

* 재마운트로 **자식 상태도 초기화**됨. 의도된 경우에만 사용.
* 대안: `useEffect`로 prop 변화 시 로컬 상태 동기화.

---

### 7. Zustand 전역 상태 관리

**학습 목표 (Why?)**

Provider 트리 없이 전역 상태를 **선택적 구독**으로 읽고 최소 리렌더를 달성.

**핵심 원리 (What?)**

* `create(set)`로 스토어 생성
* **선택자**로 필요한 조각만 구독
* 액션은 스토어 생성 시 **한 번만** 만들어져 참조 안정

**문법 및 사용법 (How?)**

```jsx
export const useCounterStore = create(set => ({
  count: 0,
  showCounter: true,
  increment: () => set(s => ({ count: s.count + 1 })),
  toggle: () => set(s => ({ showCounter: !s.showCounter })),
}));

// 읽기/쓰기 분리
const count = useCounterStore(s => s.count);
const increment = useCounterStore(s => s.increment);
```

**주의사항 및 실무 팁 (Watch out for)**

* **persist** 사용 시: 토큰/민감정보는 저장 금지, 필요한 최소 상태만 `partialize`.
* 선택자 여러 번 호출해 **읽기/쓰기 분리**하면 리렌더 줄어듦.
* 깊은 구조 업데이트는 `immer` 미들웨어 고려.

---

## 오늘의 깨달음 💡

* `React.memo`의 효과는 \*\*안정 참조(props)\*\*가 전제다. 함수·객체·배열을 안정화하지 않으면 체감 이득이 없다.

* 리스트 최적화의 핵심은 **안정 key**와 **항목 단위 메모**이며, 이벤트 핸들러 전달 방식(API 설계)까지 함께 바꿔야 실효성이 생긴다.

* 전역 상태는 **읽기/쓰기 분리 + 선택자**만으로도 큰 리렌더 절약이 가능하며, Context 남용보다 추적이 쉽고 코드가 간결해진다.
