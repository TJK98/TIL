# TIL - 2025.09.11 - OAuth2 소셜 로그인(Google/Kakao)과 JWT 쿠키 연동 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringSecurity #OAuth2 #JWT #Cookie #HttpOnly #KakaoLogin #GoogleLogin #CSRF

---

## 오늘 배운 내용 🔍

* **Spring Security OAuth2 클라이언트**(`spring-boot-starter-oauth2-client`) 의존성으로 소셜 로그인 연동
* `CustomOAuth2UserService`를 통한 Google/Kakao 사용자 정보 추출 및 DB 동기화
* **OAuth2SuccessHandler / OAuth2FailureHandler**로 로그인 성공/실패 시 토큰 처리와 리다이렉트 구현
* 성공 시 Access/Refresh Token 발급 → **HttpOnly 쿠키 저장**
* 실패 시 쿠키 삭제 후 프론트엔드 에러 페이지로 안전하게 리다이렉트
* `AuthController`에서 Refresh Token 기반 Access Token 재발급과 로그아웃 구현
* 프론트엔드(Vite+React)에서 **axios + interceptor**로 401 응답 시 자동 재발급 로직 처리
* **순환 의존성 문제 해결**을 위해 동적 import(`import()`)를 활용한 AuthService 로딩 방식 이해
* Zustand Store로 인증 상태 관리(`user`, `isAuthenticated`), LocalStorage에는 최소 정보만 저장

---

## 어려웠던 점 💣

* Google과 Kakao의 **OAuth2 사용자 정보 응답 스키마가 달라서** provider별 분기 처리가 필요했다.
* Kakao 로그인 시 이메일 제공에 동의하지 않으면 null이 발생해 placeholder 이메일을 넣어야 하는 부분이 까다로웠다.
* OAuth2 성공/실패 핸들러에서 JWT 쿠키를 안전하게 발급/삭제하면서 **URL 노출 없이 리다이렉트** 처리하는 부분을 이해하는 데 시간이 걸렸다.
* axios interceptor에서 **401 자동 갱신** 로직이 여러 요청에 동시에 발생할 수 있어, `isRefreshing` / `refreshPromise` 패턴으로 직렬화하는 아이디어를 이해하는 데 시간이 걸렸다.
* 순환 의존성을 막기 위해 **AuthService를 동적 import**해야 하는 이유를 파악하는 데 시간이 필요했다.

---

## 정리 🖇️

### 1. OAuth2 사용자 정보 동기화(CustomOAuth2UserService)

* **학습 목표 (Why?)**
  소셜 로그인 후 외부 OAuth2 제공자의 응답을 **우리 도메인 User 엔티티와 동기화**해야 함.

* **핵심 원리 (What?)**

  * Google: `sub`, `email`, `name`, `picture`
  * Kakao: `id`, `kakao_account.email`, `kakao_account.profile.nickname`
  * 신규 사용자면 저장, 기존 사용자면 프로필 업데이트
  * 이메일이 비어 있으면 placeholder(`{id}@kakao.local`)로 대체

* **문법 및 사용법 (How?)**

  ```java
  OAuth2User oAuth2User = super.loadUser(userRequest);
  String registrationId = userRequest.getClientRegistration().getRegistrationId();

  if ("google".equals(registrationId)) {
      providerId = attributes.get("sub").toString();
      email = (String) attributes.get("email");
      nickname = (String) attributes.get("name");
  } else if ("kakao".equals(registrationId)) {
      providerId = attributes.get("id").toString();
      Map<String, Object> kakaoAccount = (Map) attributes.get("kakao_account");
      email = (String) kakaoAccount.get("email");
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * Kakao는 이메일 null 가능성 → placeholder 전략 필요
  * provider별 `nameAttributeKey`(`google=sub`, `kakao=id`) 지정

---

### 2. OAuth2SuccessHandler / FailureHandler

* **학습 목표 (Why?)**
  로그인 성공/실패 후 후속 처리(토큰 발급·삭제, 리다이렉트)를 일관되게 처리.

* **핵심 원리 (What?)**

  * 성공: subject 추출 → Access/Refresh Token 생성 → **HttpOnly 쿠키 저장** → 프론트엔드 URL로 리다이렉트
  * 실패: 쿠키 삭제 → 실패 메시지를 쿼리 파라미터로 추가하여 리다이렉트

* **문법 및 사용법 (How?)**

  ```java
  // 성공 시
  String accessToken = jwtTokenProvider.createAccessToken(subject, Map.of());
  cookieUtil.addAccessTokenCookie(response, accessToken);

  // 실패 시
  cookieUtil.deleteAccessTokenCookie(response);
  response.sendRedirect(appProperties.getOauth2FailureRedirectUrl() + "?error=" + encodedMsg);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 토큰을 URL 쿼리에 노출하지 말고 반드시 **HttpOnly 쿠키**로 전달
  * Redirect URL은 환경별 프로퍼티(yml)로 관리

---

### 3. AuthController(재발급 / 로그아웃)

* **학습 목표 (Why?)**
  세션 없이도 장기 로그인을 지원하기 위해 Refresh Token 기반 재발급 엔드포인트 제공.

* **핵심 원리 (What?)**

  * `/api/auth/refresh`: Refresh Token 검증 → Access Token 재발급 후 쿠키 저장
  * `/api/auth/logout`: Access/Refresh 쿠키 삭제

* **문법 및 사용법 (How?)**

  ```java
  String refreshToken = cookieUtil.readRefreshToken(request);
  if (!jwtTokenProvider.validateToken(refreshToken)) return 401;

  String newAccessToken = jwtTokenProvider.createAccessToken(subject, Map.of());
  cookieUtil.addAccessTokenCookie(response, newAccessToken);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * Refresh Token 자체도 만료되면 **401 반환 후 클라이언트는 로그인 페이지로 이동**

---

### 4. axios interceptor 기반 자동 재발급

* **학습 목표 (Why?)**
  Access Token 만료 시 사용자가 끊김 없이 서비스를 이용할 수 있도록 자동 재발급.

* **핵심 원리 (What?)**

  * 모든 요청은 `withCredentials: true`로 쿠키 자동 전송
  * 401 응답 발생 시 `/api/auth/refresh` 요청
  * 동시에 여러 요청이 401이 발생할 수 있으므로 `isRefreshing` / `refreshPromise`로 직렬화

* **문법 및 사용법 (How?)**

  ```js
  apiClient.interceptors.response.use(
    (res) => res,
    async (error) => {
      if (status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;
        const { AuthService } = await import('../services/authService');
        await AuthService.refresh();
        return apiClient(originalRequest); // 실패한 요청 재시도
      }
      return Promise.reject(error);
    }
  );
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * **무한 루프 방지**: `_retry` 플래그 사용
  * **순환 의존성 회피**: AuthService는 정적 import가 아닌 **동적 import** 사용

---

### 5. Zustand Auth Store 설계

* **학습 목표 (Why?)**
  클라이언트 전역에서 인증 상태를 공유하면서, LocalStorage에는 최소한의 정보만 저장.

* **핵심 원리 (What?)**

  * `user`, `isAuthenticated`는 persist 대상
  * `loading`, `error`는 메모리 상태만 유지
  * 쿠키 기반 인증이므로 토큰 자체는 클라이언트에 저장하지 않음

* **문법 및 사용법 (How?)**

  ```js
  export const useAuthStore = create(
    persist((set) => ({
      user: null,
      isAuthenticated: false,
      fetchMe: async () => {
        const res = await AuthService.me();
        set({ user: res.data.data, isAuthenticated: true });
      },
      logout: async () => {
        await AuthService.logout();
        set({ user: null, isAuthenticated: false });
      },
    }), {
      name: 'auth',
      partialize: (state) => ({ user: state.user, isAuthenticated: state.isAuthenticated }),
    })
  );
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 새로고침 후에도 로그인 상태를 유지할 수 있지만, 토큰은 **쿠키에만 존재**

---

## 오늘의 깨달음 💡

* OAuth2 연동은 단순히 외부 로그인 화면을 띄우는 것이 아니라, **User 동기화 → JWT 발급 → 쿠키 저장 → 프론트 리다이렉트**까지 하나의 완전한 파이프라인임을 알게 됐다.
* Kakao와 Google처럼 제공자의 응답 스키마가 달라서, provider별 매핑 로직을 별도로 관리하는 것이 중요하다.
* axios interceptor에서 **401 자동 재발급 패턴**을 통해 끊김 없는 사용자 경험을 제공할 수 있음을 알게 됐다.
* 순환 의존성을 막기 위해 **동적 import를 선택하는 이유**를 실제 코드 흐름 속에서 명확히 이해했다.
* 클라이언트 상태 관리에서 토큰을 절대 저장하지 않고, **HttpOnly 쿠키 기반**으로만 인증을 유지하는 것이 보안상 안전하다는 점을 다시 확인했다.