# TIL - 2025.09.11 - OAuth2 소셜 로그인(Google/Kakao)과 JWT 쿠키 연동, Axios 설정과 fetch 비교 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringSecurity #OAuth2 #JWT #Cookie #Axios #KakaoLogin #GoogleLogin

---

## 오늘 배운 내용 🔍

* Spring Security OAuth2 Client로 Google/Kakao 소셜 로그인 연동 흐름 파악
* `CustomOAuth2UserService`로 공급자별 사용자 정보 매핑 및 DB 동기화
* OAuth2 성공/실패 핸들러에서 JWT 발급/삭제 후 HttpOnly 쿠키 저장과 리다이렉트 처리
* Access/Refresh 역할 분리와 재발급 API(`/api/auth/refresh`) 설계
* 쿠키 보안 플래그(HttpOnly, Secure, SameSite)와 만료 제어(`maxAge` 초 단위)
* 프론트엔드 Axios 인스턴스(`withCredentials`) 구성과 401 자동 재발급 인터셉터
* Axios와 fetch 차이점 비교 및 JWT 쿠키 인증 맥락에서의 선택 기준

---

## 어려웠던 점 💣

* Google과 Kakao의 응답 스키마가 달라 provider별 매핑 분기가 필요했다.

* Kakao에서 이메일 미동의 시 placeholder 이메일을 넣는 정책을 정하는 데 시간이 걸렸다.

* OAuth2 성공/실패 핸들러에서 쿠키로만 토큰을 전달하고 URL 노출을 피하는 구성이 처음엔 낯설었다.

* 401 동시 다발 응답 상황에서 Axios 인터셉터를 직렬화(`isRefreshing`, `refreshPromise`)하는 패턴을 이해하는 데 시간이 필요했다.

* 쿠키 `setMaxAge`가 초 단위라는 점을 놓쳐 삭제/만료 타이밍을 잘못 설정한 적이 있었다.

---

## 정리 🖇️

### 1. OAuth2 전체 흐름과 보안 체인 구성

* **학습 목표 (Why?)**
  외부 OAuth2 공급자를 통해 로그인 후, 서버에서 JWT를 발급해 HttpOnly 쿠키로 저장하고, 세션 없이도 인증 상태를 유지하려고 함.

* **핵심 원리 (What?)**
  `SecurityFilterChain`에서 `oauth2Login()`을 활성화하고, 성공/실패 핸들러를 통해 JWT 발급·삭제 및 리다이렉트를 수행함. 서비스 전반은 `STATELESS`로 동작함.

* **문법 및 사용법 (How?)**

  ```java
  http
    .csrf(csrf -> csrf.disable())
    .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
    .authorizeHttpRequests(authz -> authz
      .requestMatchers("/", "/health", "/h2-console/**",
                       "/api/auth/**", "/oauth2/**", "/login/oauth2/**").permitAll()
      .anyRequest().authenticated())
    .oauth2Login(oauth -> oauth
      .userInfoEndpoint(u -> u.userService(customOAuth2UserService))
      .successHandler(oAuth2SuccessHandler)
      .failureHandler(oAuth2FailureHandler));
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  인증 실패는 401로 반환해 클라이언트가 재발급을 트리거하게 함. H2 콘솔 등 개발 도구 접근에는 `frameOptions().sameOrigin()` 설정이 필요함.

---

### 2. OAuth2 사용자 정보 동기화 (CustomOAuth2UserService)

* **학습 목표 (Why?)**
  공급자 응답을 우리 도메인 `User`에 정규화하고, 신규/기존 사용자를 구분해 저장/업데이트하려고 함.

* **핵심 원리 (What?)**
  `registrationId`에 따라 응답 스키마가 다르므로 provider별로 `providerId`, `email`, `nickname`, `profileImageUrl`을 추출하고 DB에 동기화함.

* **문법 및 사용법 (How?)**

  ```java
  String registrationId = userRequest.getClientRegistration().getRegistrationId();
  if ("google".equals(registrationId)) {
    providerId = String.valueOf(attributes.get("sub"));
    email = (String) attributes.get("email");
    nickname = coalesce((String) attributes.get("name"),
                        email != null ? email.split("@")[0] : null);
  } else if ("kakao".equals(registrationId)) {
    providerId = String.valueOf(attributes.get("id"));
    Map<String, Object> acc = (Map<String, Object>) attributes.getOrDefault("kakao_account", Map.of());
    email = (String) acc.get("email");
    Map<String, Object> profile = (Map<String, Object>) acc.getOrDefault("profile", Map.of());
    nickname = coalesce((String) profile.get("nickname"),
                        email != null ? email.split("@")[0] : null);
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  Kakao는 이메일이 없을 수 있으므로 `{providerId}@kakao.local` 같은 placeholder 정책을 명확히 두고, 이후 실제 이메일을 받으면 교체하는 로직이 필요함.

---

### 3. Google vs Kakao 응답 스키마 차이

* **학습 목표 (Why?)**
  필드명이 달라 매핑 오류가 발생하지 않도록 공급자별 응답 구조를 정확히 이해하려고 함.

* **핵심 원리 (What?)**
  아래 표는 자주 쓰는 표준 필드 대비 각 공급자 위치를 정리함.

* **문법 및 사용법 (How?)**

  | 개념      | Google 위치 | Kakao 위치                                  |
    | ------- | --------- | ----------------------------------------- |
  | 고유 ID   | `sub`     | `id`                                      |
  | 이메일     | `email`   | `kakao_account.email`                     |
  | 닉네임     | `name`    | `kakao_account.profile.nickname`          |
  | 프로필 이미지 | `picture` | `kakao_account.profile.profile_image_url` |

* **주의사항 및 실무 팁 (Watch out for)**
  Kakao는 동의 항목에 따라 필드가 빠질 수 있음. 매핑 시 안전 캐스팅과 `null` 방어를 적용해야 함.

---

### 4. OAuth2SuccessHandler / OAuth2FailureHandler

* **학습 목표 (Why?)**
  로그인 결과에 따라 JWT 발급/삭제와 리다이렉트를 일관되게 처리하려고 함.

* **핵심 원리 (What?)**
  성공 시 subject로 Access/Refresh 생성 → HttpOnly 쿠키 저장 → 프론트엔드 URL로 리다이렉트. 실패 시 토큰 쿠키 정리 후 에러 메시지와 함께 리다이렉트.

* **문법 및 사용법 (How?)**

  ```java
  // 성공
  String access = jwtTokenProvider.createAccessToken(subject, Map.of());
  String refresh = jwtTokenProvider.createRefreshToken(subject);
  cookieUtil.addAccessTokenCookie(response, access);
  cookieUtil.addRefreshTokenCookie(response, refresh);
  response.sendRedirect(appProperties.getOauth2SuccessRedirectUrl());

  // 실패
  cookieUtil.deleteAccessTokenCookie(response);
  cookieUtil.deleteRefreshTokenCookie(response);
  response.sendRedirect(appProperties.getOauth2FailureRedirectUrl() + "?error=" + encodedMsg);
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  토큰은 URL 파라미터로 노출하지 말고 **항상 쿠키**로만 전달함. 리다이렉트 목적지는 환경변수(yml)로 분리 관리함.

---

### 5. JWT 쿠키 기반 인증과 보안 플래그

* **학습 목표 (Why?)**
  XSS/스니핑/크로스 사이트 전송 위험을 플래그 조합으로 낮추려 함.

* **핵심 원리 (What?)**

  * **HttpOnly**: JS 접근 차단 → XSS로부터 토큰 노출 방지
  * **Secure**: HTTPS에서만 전송 → 네트워크 탈취 방지
  * **SameSite**: `Lax/Strict/None`에 따라 크로스 사이트 쿠키 전송 제한

* **문법 및 사용법 (How?)**

  ```java
  ResponseCookie cookie = ResponseCookie.from("access-token", token)
      .httpOnly(true).secure(true)
      .sameSite("Lax")   // cross-site 필요 시 "None" (이때 secure=true 필수)
      .path("/").maxAge(300).build();
  response.addHeader("Set-Cookie", cookie.toString());
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  SPA가 다른 도메인에 호스팅되면 `SameSite=None; Secure` 조합이 필요함. 개발(HTTP)과 운영(HTTPS) 프로파일을 분리해 설정 실수를 줄임.

---

### 6. Access Token vs Refresh Token 전략

* **학습 목표 (Why?)**
  보안성과 UX를 동시에 만족하려고 단기/장기 토큰을 분리함.

* **핵심 원리 (What?)**

  * **Access Token**: 짧게(예: 5\~10분), 모든 보호 API에 사용
  * **Refresh Token**: 길게(예: 30\~90일), Access 갱신 전용. 서버에서 회전(rotation) 관리 권장

* **문법 및 사용법 (How?)**

  ```java
  // 최초 로그인
  cookieUtil.addAccessTokenCookie(response, accessToken);
  cookieUtil.addRefreshTokenCookie(response, refreshToken);

  // 재발급 API에서 Refresh 검증 후 Access 재발급
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  Refresh 탈취 대비를 위해 UA/IP/만료를 포함해 서버 보관·회전을 고려함. 로그아웃/강제 만료 시 쿠키 삭제와 서버 상태 폐기를 함께 처리함.

---

### 7. 재발급/로그아웃 API (AuthController)

* **학습 목표 (Why?)**
  세션 없이 장기 로그인을 지원하기 위해 안전한 재발급/종료 경로를 제공하려 함.

* **핵심 원리 (What?)**

  * `POST /api/auth/refresh`: 쿠키의 Refresh 검증 후 Access 재발급
  * `POST /api/auth/logout`: Access/Refresh 쿠키 삭제

* **문법 및 사용법 (How?)**

  ```java
  String refresh = cookieUtil.readRefreshToken(request);
  if (refresh == null || !jwtTokenProvider.validateToken(refresh)) {
    return ResponseEntity.status(401).build();
  }
  String subject = jwtTokenProvider.getClaims(refresh).getSubject();
  String newAccess = jwtTokenProvider.createAccessToken(subject, Map.of());
  cookieUtil.addAccessTokenCookie(response, newAccess);
  return ResponseEntity.noContent().build();
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  재발급 실패 시 401을 반환해 클라이언트가 인증 상태를 초기화하고 로그인 화면으로 보낼 수 있게 함.

---

### 8. 쿠키 만료/삭제 동작 (maxAge는 초 단위)

* **학습 목표 (Why?)**
  인증 지속시간과 즉시 로그아웃 동작을 정확히 제어하려 함.

* **핵심 원리 (What?)**

  * `setMaxAge(300)` → **300초(5분)**
  * `setMaxAge(0)` → **즉시 삭제**
  * `setMaxAge(-1)` → **세션 쿠키**(브라우저 종료 시 삭제)

* **문법 및 사용법 (How?)**

  ```java
  cookie.setMaxAge(300);  // 5분
  // 삭제
  ResponseCookie del = ResponseCookie.from("access-token", "")
      .path("/").httpOnly(true).secure(true).maxAge(0).build();
  response.addHeader("Set-Cookie", del.toString());
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  생성/삭제 시 도메인·경로·플래그가 동일해야 브라우저가 원하는 쿠키를 정확히 삭제함.

---

### 9. Axios 인스턴스와 401 자동 재발급 인터셉터

* **학습 목표 (Why?)**
  Access 만료 시 사용자 경험을 끊김 없이 유지하려 함.

* **핵심 원리 (What?)**
  `withCredentials: true`로 쿠키를 자동 포함하고, 401 응답 시 `/api/auth/refresh`를 호출한 뒤 실패한 요청을 한 번만 재시도함. 동시 401은 `isRefreshing`/`refreshPromise`로 직렬화함.

* **문법 및 사용법 (How?)**

  ```js
  const apiClient = axios.create({ baseURL: '/api', withCredentials: true });

  let isRefreshing = false;
  let refreshPromise = null;

  apiClient.interceptors.response.use(
    (res) => res,
    async (error) => {
      const original = error?.config || {};
      const status = error?.response?.status;
      if (status !== 401 || original.skipAuthRefresh) return Promise.reject(error);

      if (original.url?.includes('/auth/refresh') || original._retry) {
        useAuthStore.getState().clear();
        return Promise.reject(error);
      }

      try {
        if (!isRefreshing) {
          isRefreshing = true;
          original._retry = true;
          const { AuthService } = await import('../services/authService');
          refreshPromise = AuthService.refresh(); // 204 기대
          await refreshPromise;
        } else {
          await refreshPromise;
          original._retry = true;
        }
        return apiClient(original);
      } catch (e) {
        useAuthStore.getState().clear();
        throw e;
      } finally {
        isRefreshing = false;
      }
    }
  );
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  순환 의존을 피하려고 인터셉터 내부에서 `AuthService`를 **동적 import**함. 무한 루프 방지를 위해 `_retry` 플래그를 사용함.

---

### 10. Axios와 fetch 비교 (JWT 쿠키 인증 관점)

* **학습 목표 (Why?)**
  프로젝트 맥락에서 어떤 HTTP 클라이언트를 택할지 근거를 명확히 하려 함.

* **핵심 원리 (What?)**

  | 항목    | fetch                       | Axios                      |
    | ----- | --------------------------- | -------------------------- |
  | 쿠키 포함 | `credentials: 'include'` 지정 | `withCredentials: true` 옵션 |
  | 인터셉터  | 직접 구현 필요                    | **내장**(요청/응답 공통 로직)        |
  | 에러 처리 | 상태코드 수동 체크                  | 4xx/5xx 자동 reject          |
  | JSON  | `res.json()` 호출             | `res.data` 바로 사용           |
  | 실행 환경 | 브라우저                        | 브라우저 + Node.js             |

* **문법 및 사용법 (How?)**

  ```js
  // fetch
  const r = await fetch('/api/users/me', { credentials: 'include' });
  const data = await r.json();

  // axios
  const r2 = await apiClient.get('/users/me'); // withCredentials 적용됨
  const data2 = r2.data;
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  JWT 쿠키 인증 + 자동 재발급 패턴에는 Axios의 인터셉터가 유지보수에 유리함.

---

## 오늘의 깨달음 💡

* OAuth2 연동은 **사용자 동기화 → JWT 발급 → 쿠키 저장 → 리다이렉트**까지 하나의 파이프라인으로 보아야 함.

* Kakao/Google 응답 스키마 차이는 매핑 실수로 이어지기 쉬우므로 표준화 계층을 둬야 함.

* 쿠키 `maxAge`는 **초 단위**이며, 삭제는 `0`, 세션 쿠키는 `-1`임을 확실히 기억해야 함.

* Axios 인터셉터와 동적 import 패턴으로 401 자동 재발급을 안정적으로 구현할 수 있음.

* 클라이언트에는 토큰을 저장하지 않고, 서버가 **HttpOnly 쿠키**로만 토큰을 관리하는 방식이 보안적으로 설득력 있음.
