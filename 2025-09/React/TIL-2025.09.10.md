# TIL - 2025.09.10 - JWT 쿠키 인증, LocalStorage 비교와 OAuth2 카카오 로그인 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringSecurity #JWT #Cookie #HttpOnly #OAuth2 #KakaoLogin #CSRF

---

## 오늘 배운 내용 🔍

* JWT를 **HttpOnly+Secure 쿠키**에 저장하는 방식의 전체 흐름과 보안 요소 정리
* **Access Token(단기)** / **Refresh Token(장기)** 역할 분리와 재발급 전략
* **LocalStorage 저장 방식과의 차이**를 위협 모델(XSS/CSRF) 관점에서 비교
* Spring에서 쿠키 발급/삭제 구현(`Cookie`, `ResponseCookie`)과 공통 유틸 설계
* `SecurityFilterChain` 기반 **Stateless** 보안 구성과 예외 처리(401)
* `JwtAuthenticationFilter`로 헤더/쿠키 우선순위 추출과 컨텍스트 주입
* **OAuth2 카카오 로그인**: 인가코드 → 토큰 교환 → 사용자 정보 조회 흐름

---

## 어려웠던 점 💣

* HttpOnly 쿠키는 XSS에 강하지만 CSRF 방어가 별도라는 점을 실제 설계에 반영하는 과정이 헷갈렸음.

* 쿠키 만료/삭제를 `maxAge=0`으로 처리해야 즉시 삭제된다는 동작 원리를 이해하는 데 시간이 걸렸음.

* Stateless에서 `csrf().disable()` 선택이 가능한 맥락과, 프론트엔드의 `withCredentials` 설정이 CORS/SameSite와 어떻게 상호작용하는지 구분이 필요했음.

* OAuth2 인가코드와 액세스 토큰의 역할 차이, 그리고 `application/x-www-form-urlencoded`로 교환해야 하는 이유가 초기에 직관적이지 않았음.

---

## 정리 🖇️

### 1. JWT 쿠키 기반 인증 기본 흐름

* **학습 목표 (Why?)**
  LocalStorage 보관 시 XSS로 토큰 탈취 위험이 큼. 쿠키의 **HttpOnly** 특성을 활용해 클라이언트 JS 노출을 차단하고 보안 수준을 높임.

* **핵심 원리 (What?)**

  * Access Token(단기)과 Refresh Token(장기)을 **모두 HttpOnly+Secure 쿠키**로 발급
  * 요청 시 브라우저가 쿠키를 자동 전송 → 클라이언트가 토큰을 직접 다루지 않음
  * Access 만료 시 Refresh로 재발급

* **문법 및 사용법 (How?)**

  ```java
  // 서버에서 쿠키 생성 및 전송
  Cookie cookie = new Cookie("access-token", accessToken);
  cookie.setHttpOnly(true);
  cookie.setSecure(true);     // HTTPS 전제
  cookie.setPath("/");
  cookie.setMaxAge(300);      // 5분,
  response.addCookie(cookie);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 쿠키는 XSS 방어에 유리하지만 **CSRF 대비**가 별도 필요(SameSite, CSRF 토큰)
  * 운영에서 `Secure=true` 기본, `SameSite=None`이면 `Secure` 필수

---

### 2. 보안 요소 정리(HttpOnly, Secure, SameSite)

* **학습 목표 (Why?)**
  쿠키 플래그를 정확히 설정하여 **전송 구간/스크립트 접근/크로스 사이트 전송** 리스크를 줄임.

* **핵심 원리 (What?)**

  * **HttpOnly**: JS 접근 불가 → XSS로부터 토큰 노출 차단
  * **Secure**: HTTPS에서만 전송 → 스니핑 방지
  * **SameSite**: Lax/Strict/None에 따라 제3자 컨텍스트 전송 제한

* **문법 및 사용법 (How?)**

  ```java
  ResponseCookie cookie = ResponseCookie.from("refresh-token", refreshToken)
      .httpOnly(true)
      .secure(true)
      .sameSite("Lax")   // 또는 "None"(cross-site 필요 시, 이 경우 secure=true 필수)
      .path("/")
      .maxAge(60 * 60 * 24 * 90) // 90일
      .build();
  response.addHeader("Set-Cookie", cookie.toString());
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * SPA+서드파티 도메인 조합이면 `SameSite=None` 필요 → `Secure=true` 필수
  * 개발용 `localhost`는 HTTPS가 아니므로 `Secure=false`로 분기 운영(프로파일별 설정 추천)

---

### 3. JWT 저장 방식 비교: LocalStorage vs HttpOnly 쿠키

* **학습 목표 (Why?)**
  저장소 선택이 곧 **위협 모델**의 선택임. XSS/CSRF·편의성을 균형 있게 판단.

* **핵심 원리 (What?)**

  | 구분     | LocalStorage                     | HttpOnly 쿠키                   |
    | ------ | -------------------------------- | ----------------------------- |
  | 접근성    | JS로 읽기/쓰기 가능                     | JS 접근 불가(HttpOnly)            |
  | 전송     | 직접 `Authorization: Bearer` 헤더 세팅 | 브라우저가 자동 전송(Set-Cookie/쿠키 정책) |
  | XSS    | 매우 취약(토큰 탈취 가능)                  | 상대적으로 안전(접근 차단)               |
  | CSRF   | 상대적으로 안전(헤더 직접 세팅 필요)            | 취약 가능성 → SameSite/CSRF 토큰 필요  |
  | 구현 난이도 | 클라 구현 증가(보관/갱신/전송)               | 서버·보안설정 주도, 클라 단순             |
  | 실무 권장  | 제한적/내부앱                          | **권장(HTTPS+플래그 조합)**          |

* **문법 및 사용법 (How?)**

  * LocalStorage 예시(지양):

    ```js
    // XSS에 매우 취약
    localStorage.setItem('access-token', token);
    fetch('/api/orders', {
      headers: { Authorization: `Bearer ${token}` }
    });
    ```

  * HttpOnly 쿠키 예시(권장):

    ```java
    // 서버가 Set-Cookie로 전달, 이후 요청은 브라우저가 자동 전송
    response.addHeader("Set-Cookie", responseCookie.toString());
    ```

* **주의사항 및 실무 팁 (Watch out for)**

  * LocalStorage 사용 시 **Content Security Policy** 강화해도 근본적 XSS 탈취 위험 상존
  * 쿠키 사용 시 **SameSite 전략 + CSRF 토큰** 병행으로 방어면 확대

---

### 4. 쿠키 발급/삭제 공통 유틸 설계(CookieUtil)

* **학습 목표 (Why?)**
  보안 플래그/도메인/만료 규칙을 한 곳에서 일관 적용하여 실수와 중복을 줄임.

* **핵심 원리 (What?)**

  * `ResponseCookie` 빌더로 공통 옵션 캡슐화
  * 삭제는 동일 옵션으로 `maxAge=0` 설정

* **문법 및 사용법 (How?)**

  ```java
  public void deleteCookie(HttpServletResponse res, String name) {
    ResponseCookie cookie = ResponseCookie.from(name, "")
        .httpOnly(true).secure(true).sameSite("Lax")
        .path("/").maxAge(0).build();
    res.addHeader("Set-Cookie", cookie.toString());
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  * 생성/삭제 모두 **동일한 도메인/경로/플래그**로 일치시켜야 브라우저가 제대로 삭제 처리
  * `setMaxAge` 값은 **초 단위**다.
    * `setMaxAge(300)` → 300초 = 5분
    * `setMaxAge(0)` → 즉시 삭제
    * `setMaxAge(-1)` → 세션 쿠키 (브라우저 종료 시 삭제)

---

### 5. Spring Security 구성(Stateless + 공개 경로)

* **학습 목표 (Why?)**
  세션 없이 JWT 기반으로 동작하는 **Stateless** 백엔드 구성.

* **핵심 원리 (What?)**

  * `SessionCreationPolicy.STATELESS`
  * 공개 엔드포인트 허용, 나머지 인증 필요
  * 인증 실패 401 반환

* **문법 및 사용법 (How?)**

  ```java
  http
    .cors(c -> c.configurationSource(corsConfigurationSource()))
    .csrf(csrf -> csrf.disable())
    .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
    .formLogin(f -> f.disable())
    .httpBasic(b -> b.disable())
    .headers(h -> h.frameOptions(f -> f.sameOrigin()))
    .authorizeHttpRequests(a -> a
      .requestMatchers("/", "/health", "/h2-console/**", "/api/auth/**", "/oauth2/**", "/login/oauth2/**").permitAll()
      .anyRequest().authenticated())
    .exceptionHandling(ex -> ex.authenticationEntryPoint((req, res, e) -> res.sendError(401)));
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 클라이언트 재발급 트리거를 위해 **403이 아니라 401**을 주는 게 일반적임

---

### 6. JwtAuthenticationFilter(헤더/쿠키 추출 우선순위)

* **학습 목표 (Why?)**
  요청마다 토큰을 추출·검증하고 `SecurityContext`에 반영.

* **핵심 원리 (What?)**

  * 우선순위: **Authorization 헤더 → 쿠키**
  * 유효하면 `UsernamePasswordAuthenticationToken` 저장

* **문법 및 사용법 (How?)**

  ```java
  String bearer = request.getHeader("Authorization");
  if (bearer != null && bearer.startsWith("Bearer ")) return bearer.substring(7);

  Cookie[] cookies = request.getCookies();
  if (cookies != null) {
    for (Cookie c : cookies) {
      if ("access-token".equals(c.getName())) return c.getValue();
    }
  }
  return null;
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * Refresh Token은 본 필터에서 사용하지 않고 **재발급 전용 엔드포인트**에서만 처리

---

### 7. Access Token과 Refresh Token 전략

* **학습 목표 (Why?)**
  보안성과 UX를 동시에 만족시키기 위해 단기/장기 토큰 이원화.

* **핵심 원리 (What?)**

  * **Access Token**: 5\~10분. 모든 API 요청에 사용. 탈취 피해를 시간으로 제한
  * **Refresh Token**: 30\~90일. Access 만료 시 재발급 용. 서버 저장/폐기 관리

* **문법 및 사용법 (How?)**

  ```java
  // 발급
  cookieUtil.addAccessTokenCookie(response, accessToken);
  cookieUtil.addRefreshTokenCookie(response, refreshToken);

  // 재발급 엔드포인트: Refresh 검증 → 새로운 Access 재발급
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * Refresh 탈취 리스크 완화: 서버 저장 시 **UA/IP/만료/회전(Rotation)** 관리
  * 재발급 시 Refresh도 **회전**하고 이전 토큰은 즉시 폐기(블랙리스트/버전 증가)
  * 로그아웃/강제 만료 시 **쿠키 삭제 + 서버 상태 폐기** 동시 수행

---

### 8. OAuth2 카카오 로그인(인가코드 → 토큰 → 사용자 정보)

* **학습 목표 (Why?)**
  소셜 계정으로 간편 인증 구현 및 OAuth2 표준 흐름 이해.

* **핵심 원리 (What?)**

  * 인가 코드 발급(리다이렉트) → 토큰 교환(서버-서버) → 사용자 정보 API 호출
  * `RestTemplate` 또는 `WebClient` 사용

* **문법 및 사용법 (How?)**

  ```java
  // 토큰 교환
  HttpHeaders headers = new HttpHeaders();
  headers.add("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");

  LinkedMultiValueMap<String, Object> params = new LinkedMultiValueMap<>();
  params.add("grant_type", "authorization_code");
  params.add("client_id", appKey);
  params.add("redirect_uri", redirectUri);
  params.add("code", code);
  params.add("client_secret", clientSecret);

  ResponseEntity<Map> tokenRes = new RestTemplate()
      .exchange("https://kauth.kakao.com/oauth/token", HttpMethod.POST, new HttpEntity<>(params, headers), Map.class);
  String accessToken = (String) tokenRes.getBody().get("access_token");
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 교환 요청의 `Content-Type`은 반드시 `application/x-www-form-urlencoded`
  * 운영에서는 토큰/프로필 응답 스키마 변동 대비 DTO 버전 분리/로그 보호 필요

---

## 오늘의 깨달음 💡

* 저장소 선택은 곧 위협 모델 선택임을 이해했다. **HttpOnly 쿠키는 XSS 방어에 유리**하고, **LocalStorage는 편하나 XSS에 취약**함.

* 쿠키 기반은 \*\*CSRF 방어(SameSite/CSRF 토큰)\*\*를 반드시 병행해야 하고, 실무에서는 HTTPS 전제를 두고 `Secure`/`SameSite` 정책을 명확히 해야 한다고 판단했다.

* Access/Refresh 이원화와 **회전(Rotation) 전략**을 결합하면 장기 세션 보안을 강화할 수 있음을 확인했다.

* OAuth2 흐름은 “로그인” 단일 사건이 아니라 **인가코드 → 토큰 → 사용자 정보**라는 단계적 프로토콜임을 분명히 이해했다.
