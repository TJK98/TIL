# TIL - 2025.09.08 - Context API, useContext, forwardRef, 장바구니 상태 관리 개념 이해

## 카테고리 🏷️

#TIL #React #ContextAPI #useContext #ForwardRef #useImperativeHandle #Props #CartApp #StateManagement

---

## 오늘 배운 내용 🔍

* Input 컴포넌트를 `props.inputAttr`로 확장 가능한 재사용 컴포넌트로 설계
* Context API를 사용해 장바구니 모달 열림/닫힘 상태, 장바구니 배열을 중앙에서 관리
* `useContext`로 Consumer 문법을 대체하여 간결한 코드 작성
* `forwardRef`와 `useImperativeHandle`을 이용해 부모 컴포넌트에서 자식 input DOM 제어
* 장바구니 항목 추가/삭제 로직 구현
  * 기존 아이템 수량 증가, 합산 가격 갱신
  * 수량 1일 경우 삭제 처리
* Cart, HeaderCartButton, MealItem, MealItemForm 간 데이터 흐름 연결 및 props vs Context API 비교

---

## 어려웠던 점 💣

* Input 컴포넌트에서 `ref`를 props로 직접 받으면 동작하지 않아 `forwardRef`를 통해 처리해야 한다는 점이 헷갈렸음
* 장바구니 `addToCartItem` 구현에서 가격 합산과 개별 단가 계산이 직관적이지 않아 계산 로직을 분리해야 했다
* Context와 props 사용 시점의 기준이 명확히 구분되지 않아, 어디까지 Context로 넘겨야 하는지 고민이 필요했음

---

## 정리 🖇️

### 1. Context API

**학습 목표 (Why?)**
Props 체인이 깊어질 때 불필요한 렌더링, 결합도 증가, 복잡성 문제를 해결하기 위함.

**핵심 원리 (What?)**
`createContext`로 Context 객체 생성 → `Provider`에서 value를 내려줌 → 하위에서 `useContext`로 값 소비.

**문법 및 사용법 (How?)**

```jsx
const CartContext = createContext(defaultValue);

<CartContext.Provider value={{cartItems, openModal, closeModal}}>
  <MainCart />
</CartContext.Provider>

const {cartItems} = useContext(CartContext);
```

**주의사항 및 실무 팁 (Watch out for)**

* 전역적으로 꼭 필요한 상태만 Context로 관리.
* 너무 많은 상태를 넣으면 추적하기 어렵다.

---

### 2. useContext

**학습 목표 (Why?)**
Consumer 문법의 가독성 문제 해결.

**핵심 원리 (What?)**
함수형 컴포넌트에서 Context 값을 바로 가져올 수 있게 해주는 Hook.

**문법 및 사용법 (How?)**

```jsx
const { openModal } = useContext(CartContext);
```

**주의사항 및 실무 팁 (Watch out for)**

* Context 값이 변경되면 해당 Context를 구독하는 모든 컴포넌트가 재렌더링됨.

---

### 3. forwardRef & useImperativeHandle

**학습 목표 (Why?)**
부모 컴포넌트가 자식 DOM에 직접 접근하기 위함.

**핵심 원리 (What?)**
`forwardRef`로 ref를 자식에게 전달 → `useImperativeHandle`로 특정 기능을 부모에게 노출.

**문법 및 사용법 (How?)**

```jsx
const Input = forwardRef(({label, inputAttr}, ref) => (
  <input ref={ref} {...inputAttr} />
));

useImperativeHandle(ref, () => ({
  focus: () => inputRef.current.focus(),
  clear: () => inputRef.current.value = ''
}));
```

**주의사항 및 실무 팁 (Watch out for)**

* 꼭 필요한 경우에만 DOM 접근.
* 상태 관리로 풀 수 있는 경우는 상태 관리 방식을 우선 고려.

---

### 4. Props vs Context

**Props**

* 단일 레벨 전달에 적합
* 데이터 흐름이 명확
* 재사용성 높음

**Context**

* 깊은 트리 구조에서 공통 상태 공유에 유리
* Props drilling 방지
* 남용 시 추적 어려움

---

### 5. 장바구니 상태 관리

**핵심 로직**

```jsx
const handleAddToCartItem = (newItem) => {
  const foundItem = cartItems.find(item => item.id === newItem.id);
  if (foundItem) {
    foundItem.amount += newItem.amount;
    foundItem.price += newItem.price;
    setCartItems([...cartItems]);
  } else {
    setCartItems([...cartItems, newItem]);
  }
};

const handleRemoveToCartItem = (id) => {
  const foundItem = cartItems.find(item => item.id === id);
  if (foundItem.amount === 1) {
    setCartItems(cartItems.filter(item => item.id !== id));
  } else {
    const eachPrice = foundItem.price / foundItem.amount;
    foundItem.amount--;
    foundItem.price -= eachPrice;
    setCartItems([...cartItems]);
  }
};
```

**실무 팁**

* `price`와 `amount`를 별도로 관리하지 않고, 개별 단가를 유지하고 총액은 `reduce`로 계산하는 방식이 더 직관적일 수 있음.

---

## 오늘의 깨달음 💡

* Context API는 props drilling을 피할 수 있지만, 무분별하게 사용하면 디버깅이 더 힘들어진다.
* `forwardRef`와 `useImperativeHandle`은 실제 DOM 제어가 필요할 때만 쓰는 고급 기술이고, 대부분은 상태 관리로 해결 가능하다.
* 장바구니 상태 관리 시 **데이터 모델링**을 명확히 정의해야, price 합산 문제 같은 복잡한 로직이 줄어든다.