# TIL - 2025.07.09 - Java 스트림(Stream) API 기본 및 활용 개념 이해

## 카테고리 🏷️

#TIL #Java #StreamAPI #Lambda #FunctionalProgramming #DeclarativeProgramming

---

## 오늘 배운 내용 🔍

- 데이터 컬렉션을 함수형 스타일로 처리하는 스트림(Stream) API의 기본 구조
- 스트림 파이프라인: 스트림 생성 → 중간 연산(Intermediate Operations) → 최종 연산(Terminal Operations)
- 주요 중간 연산: `filter`, `map`, `sorted`, `distinct`, `limit`
- 주요 최종 연산: `collect`, `forEach`, `anyMatch`, `allMatch`, `sum`, `average`
- `Comparator.comparing()`을 이용한 객체 컬렉션의 간결한 정렬
- `Collectors.groupingBy()`를 이용한 데이터 그룹화

---

## 어려웠던 점 💣

* **지연 연산(Lazy Evaluation) 개념**: 스트림의 중간 연산(`filter`, `map` 등)은 최종 연산이 호출되기 전까지는 실제로 실행되지 않는다는 점이 처음에는 직관적이지 않았다. 이는
  `collect()`나 `forEach()` 같은 최종 연산이 호출되는 순간, 전체 파이프라인이 한 번에 동작하여 불필요한 계산을 최소화하는 최적화 기법임을 이해해야 했다.

* **명령형에서 선언형으로의 사고 전환**: 기존의 `for`문과 `if`문을 사용하던 명령형(Imperative) 프로그래밍 방식에서, 스트림을 이용한 선언형(Declarative) 프로그래밍 방식으로 생각을
  바꾸는 것이 어려웠다. '데이터를 **어떻게** 처리할지'를 일일이 코드로 작성하는 대신, '**무엇을** 원하는지'를 메서드 체인으로 선언하는 방식에 익숙해지는 데 시간이 필요했다.

* **원시 타입 특화 스트림의 필요성**: `Stream<Integer>` 대신 `IntStream`을 사용하는 이유가 궁금했다. 이는 `Integer` 객체를 `int` 기본 타입으로 변환하는 오토박싱/언박싱
  과정에서 발생하는 불필요한 성능 저하를 피하고, 숫자 데이터에 특화된 최종 연산(`sum()`, `average()` 등)을 편리하게 사용하기 위함이라는 것을 알게 되었다.

* **`collect(Collectors.groupingBy(...))`의 복잡성**: 데이터를 특정 기준으로 묶어 `Map<Key, List<Value>>` 형태로 만드는 `groupingBy`는 매우
  강력하지만, 그 구조와 사용법이 복잡하게 느껴졌다. 데이터를 그룹화하는 기준이 되는 키(Key)와, 그 키에 해당하는 값들의 목록(List of Values)이 어떻게 만들어지는지 여러 단계를 거쳐 이해해야
  했다.

---

## 정리 🖇️

### 1. 스트림 API (Stream API)

데이터 컬렉션(List, Set 등)을 마치 데이터가 흐르는 파이프라인처럼 다루어, 함수형 스타일로 간결하고 효율적으로 처리하기 위한 기능을 학습했다.

* **학습 목표 (Why?)**:
  복잡한 `for` 루프와 `if` 조건문을 중첩하여 사용하던 명령형 데이터 처리 방식에서 벗어나, '무엇을 원하는지'에 집중하는 선언적인 코드를 작성하여 가독성과 유지보수성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  스트림은 **'데이터 소스'**에 대한 **'처리 파이프라인'**을 구성한다. 이 파이프라인은 세 단계로 이루어진다.
    1. **스트림 생성**: 데이터 소스(e.g., `List`, `배열`)로부터 스트림 객체를 생성한다. (`collection.stream()`)
    2. **중간 연산 (Intermediate Operation)**: 생성된 스트림을 받아 다른 스트림을 반환하는 연산. 여러 개를 연결(chaining)할 수 있으며, **지연 연산(Lazy
       Evaluation)** 방식으로 동작한다. (e.g., `filter`, `map`, `sorted`)
    3. **최종 연산 (Terminal Operation)**: 스트림 파이프라인을 실행시키고 최종 결과를 생성하는 연산. 스트림을 닫으며, 파이프라인 당 단 한 번만 호출할 수 있다. (e.g.,
       `collect`, `forEach`, `sum`)

* **문법 및 사용법 (How?)**:
  ```java
  List<Dish> menu = /* ... */;

  // 400 칼로리가 넘는 요리를 칼로리 순으로 정렬하여 이름만 추출한 리스트 만들기
  List<String> highCalorieDishNames =
      menu.stream()                               // 1. 스트림 생성
          .filter(dish -> dish.getCalories() > 400)   // 2. 중간 연산: 필터링
          .sorted(Comparator.comparing(Dish::getCalories)) // 2. 중간 연산: 정렬
          .map(Dish::getName)                         // 2. 중간 연산: 이름으로 매핑
          .collect(Collectors.toList());              // 3. 최종 연산: 결과 수집
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **스트림은 일회용이다**: 최종 연산이 실행되면 해당 스트림은 닫히므로, 재사용할 수 없다. 필요하면 데이터 소스로부터 새로운 스트림을 다시 생성해야 한다.
    * **원본 데이터를 변경하지 않는다**: 스트림 연산은 원본 컬렉션을 수정하지 않고, 항상 새로운 결과물(새로운 컬렉션, 값 등)을 생성한다.

---

### 2. 주요 스트림 연산 메서드

데이터를 가공하고 결과를 도출하는 데 자주 사용되는 중간 연산과 최종 연산을 학습했다.

* **학습 목표 (Why?)**:
  다양한 연산 메서드를 조합하여, 복잡한 데이터 처리 요구사항을 유연하고 간결하게 해결하기 위함이다.

* **핵심 원리 (What?)**:
    * **중간 연산 (Intermediate Operations)**
      | 메서드 | 설명 |
      | :--- | :--- |
      | `filter(Predicate<T>)` | 주어진 조건(Predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환. |
      | `map(Function<T, R>)` | 각 요소를 주어진 함수(Function)를 적용한 결과로 변환하여 새로운 스트림을 반환. |
      | `sorted(Comparator<T>)`| 주어진 비교자(Comparator)를 기준으로 요소를 정렬한 새로운 스트림을 반환. |
      | `distinct()` | 중복된 요소를 제거한 새로운 스트림을 반환 (`equals`와 `hashCode` 기반). |
      | `limit(n)` / `skip(n)` | 스트림의 처음 n개 요소만 선택하거나, 처음 n개 요소를 건너뜀. |
    * **최종 연산 (Terminal Operations)**
      | 메서드 | 설명 |
      | :--- | :--- |
      | `collect(Collector)` | 스트림의 요소들을 `List`, `Set`, `Map` 등 다른 종류의 결과로 수집. |
      | `forEach(Consumer<T>)`| 각 요소에 대해 주어진 동작(Consumer)을 수행. (반환값 없음) |
      | `anyMatch(Predicate<T>)`| 요소 중 하나라도 조건을 만족하면 `true`를 반환. |
      | `allMatch(Predicate<T>)`| 모든 요소가 조건을 만족하면 `true`를 반환. |
      | `findFirst()` | 스트림의 첫 번째 요소를 `Optional<T>`로 반환. |
      | `sum()`, `average()` | 숫자 스트림(`IntStream` 등)에서만 사용 가능한 집계 연산. |

* **문법 및 사용법 (How?)**: (종합 실습 예제)
  ```java
  // 거래 데이터 리스트 (transactions)가 있다고 가정

  // 1. 2021년에 일어난 모든 거래를 찾아 거래액 오름차순으로 정렬
  List<Transaction> result1 = transactions.stream()
      .filter(t -> t.getYear() == 2021)
      .sorted(Comparator.comparing(Transaction::getValue))
      .collect(Collectors.toList());

  // 2. 거래가 이루어진 모든 도시를 중복 없이 나열
  List<String> result2 = transactions.stream()
      .map(t -> t.getTrader().getCity())
      .distinct()
      .collect(Collectors.toList());

  // 3. 케임브리지에서 근무하는 모든 거래자를 찾아 이름순으로 정렬
  List<Trader> result3 = transactions.stream()
      .filter(t -> "Cambridge".equals(t.getTrader().getCity()))
      .map(Transaction::getTrader)
      .distinct()
      .sorted(Comparator.comparing(Trader::getName))
      .collect(Collectors.toList());

  // 4. 밀라노에 거래자가 있는지 여부 확인
  boolean result4 = transactions.stream()
      .anyMatch(t -> "Milan".equals(t.getTrader().getCity()));

  // 5. 케임브리지 거래자의 모든 거래액 총합
  int result5 = transactions.stream()
      .filter(t -> "Cambridge".equals(t.getTrader().getCity()))
      .mapToInt(Transaction::getValue) // IntStream으로 변환
      .sum();

  // 6. 거래를 연도별로 그룹화
  Map<Integer, List<Transaction>> result6 = transactions.stream()
      .collect(Collectors.groupingBy(Transaction::getYear));
  ```

---

## 오늘의 깨달음 💡

* **스트림 API는 '데이터를 어떻게 처리할지(How)'가 아니라 '어떤 데이터를 원하는지(What)'를 선언하는 방식이다.** `for`문과 `if`문으로 가득했던 복잡한 명령형 코드가, `filter`,
  `map`, `sorted`와 같은 메서드 체인으로 훨씬 간결하고 명확해졌다. 이는 코드의 의도를 한눈에 파악하게 해준다.

* 메서드 체이닝(`.filter().map().sorted()...`)을 통해 데이터 처리 과정을 마치 **조립 라인의 파이프라인**처럼 시각적으로 표현할 수 있었다. 데이터가 어떤 단계를 거쳐 최종 결과물로
  만들어지는지 그 흐름을 따라가기가 매우 쉬웠다.

* 스트림은 **원본 데이터를 절대 변경하지 않는다(Immutability)**. 모든 중간 연산은 새로운 스트림을 생성하여 반환하므로, 원본 컬렉션의 상태를 안전하게 유지할 수 있다. 이는 예측 가능하고 부작용(
  side effect)이 없는 코드를 작성하는 데 큰 도움이 된다.

* `Comparator.comparing(ClassName::getMethodName)` 패턴은 객체 리스트를 정렬할 때 매번 익명 클래스로 `Comparator`를 구현하던 번거로움을 완전히 해소해주는 매우
  강력하고 우아한 방법이다.

* 람다와 스트림 API는 단순히 코드를 짧게 만드는 기술이 아니다. 복잡한 반복 로직을 추상화하고, 데이터 처리의 본질에만 집중하게 함으로써 개발자의 생산성을 극대화하는, **현대 자바 개발의 필수적인 패러다임**
  임을 깨달았다.