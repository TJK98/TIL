# TIL - 2025.07.01 - Java 상속, 다형성 및 protected 접근 제어자 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #Inheritance #Polymorphism #Overriding #super #protected

---

## 오늘 배운 내용 🔍

- `extends` 키워드를 이용한 클래스 상속(Inheritance)의 기본 개념
- `super` 키워드의 두 가지 용법: 부모 생성자 호출(`super()`)과 부모 멤버 접근(`super.`)
- 부모의 메서드를 자식 클래스에서 재정의하는 메서드 오버라이딩(Overriding)
- 상속 관계에서 멤버의 접근 범위를 제어하는 `protected` 접근 제어자
- 하나의 타입으로 여러 자식 객체를 다루는 다형성(Polymorphism)의 개념과 활용
- `instanceof` 연산자를 이용한 타입 확인과 안전한 다운캐스팅(Downcasting)

---

## 어려웠던 점 💣

* `super()`와 `super.`의 차이가 혼란스러웠다. `super()`는 부모의 '생성자'를 호출하는 특별한 '함수 호출'이고, `super.`는 부모의 '필드나 메서드'에 접근하기 위한 '참조 변수'라는
  점을 명확히 구분해야 했다.

* 자식 클래스의 생성자에서 `super()` 호출이 반드시 첫 줄에 와야 한다는 규칙이 처음에는 어색했다. 이는 자식 객체의 멤버를 초기화하기 전에, 부모로부터 물려받은 멤버들이 먼저 완전히 생성되고 초기화되어야
  한다는 객체 생성의 논리적인 순서 때문임을 이해했다. 즉, '부모가 존재해야 자식도 존재할 수 있다'는 원리였다.

* `protected`의 접근 범위가 미묘하게 느껴졌다. '같은 패키지'라면 상속 관계가 아니어도 접근이 가능하고, '다른 패키지'라면 반드시 상속 관계인 자식 클래스 내부에서만 접근이 가능하다는 두 가지 조건을
  모두 포함하는 개념임을 명확히 해야 했다.

* 다형성이 적용된 코드에서, `Vehicle car = new Bus();` 처럼 부모 타입 변수로는 자식 클래스 고유의 메서드(e.g., `ringBell()`)를 직접 호출할 수 없다는 점이 의아했다. 이는
  컴파일 시점에는 변수의 타입(`Vehicle`)에 선언된 멤버만 알 수 있기 때문이며, 자식의 고유 기능에 접근하려면 실제 타입을 확인하는 `instanceof`와 강제 타입 변환(다운캐스팅)이 필요하다는 것을
  알게 되었다.

---

## 정리 🖇️

### 1. 상속 (Inheritance)과 `super` 키워드

기존 클래스(부모)의 필드와 메서드를 새로운 클래스(자식)가 물려받아 코드를 재사용하고 클래스 간의 계층 관계를 만드는 방법을 학습했다.

* **학습 목표 (Why?)**:
  코드의 중복을 제거하고, 클래스 간의 'IS-A'(~은 ~의 한 종류다) 관계를 명확히 표현하여 프로그램의 구조를 체계화하기 위함이다. (e.g., '버스는 자동차의 한 종류다' →
  `class Bus extends Vehicle`)

* **핵심 원리 (What?)**:
    * **`extends`**: 클래스 선언부에 사용하여 상속 관계를 명시한다. 자바는 단일 상속만 허용한다.
    * **`super()`**: 자식 클래스의 생성자에서 **부모 클래스의 생성자를 호출**할 때 사용한다. 반드시 생성자의 **첫 번째 줄**에 위치해야 한다. 자식 객체가 생성될 때, 내부적으로는 부모
      객체가 먼저 생성되어야 하기 때문이다.
    * **`super.멤버`**: 자식 클래스에서 부모 클래스의 필드나 메서드에 접근할 때 사용한다. 특히 오버라이딩된 메서드 내에서 부모의 원본 메서드를 호출할 때 유용하다.

* **문법 및 사용법 (How?)**:
  ```java
  // 부모 클래스
  public class Vehicle {
      String brand;

      public Vehicle(String brand) { // 부모 생성자
          this.brand = brand;
      }

      public void start() {
          System.out.println("차량 시동을 겁니다.");
      }
  }

  // 자식 클래스
  public class Bus extends Vehicle {
      int passengerCapacity;

      public Bus(String brand, int capacity) {
          super(brand); // 1. super()로 부모 생성자 호출 (brand 초기화 위임)
          this.passengerCapacity = capacity;
      }

      public void checkPassengers() {
          // ...
      }

      @Override // 3. 메서드 오버라이딩
      public void start() {
          super.start(); // 2. super.로 부모의 원본 메서드 호출
          System.out.println("버스가 부드럽게 출발합니다.");
      }
  }
  ```

---

### 2. 메서드 오버라이딩 (Method Overriding)

부모 클래스로부터 상속받은 메서드를 자식 클래스의 상황에 맞게 내용을 재정의하는 것을 학습했다.

* **학습 목표 (Why?)**:
  다형성을 실현하는 핵심적인 기술로, 같은 이름의 메서드를 호출하더라도 실제 객체의 타입에 따라 각기 다른 동작을 하도록 만들기 위함이다.

* **핵심 원리 (What?)**:
  오버라이딩이 성립하려면, 부모의 메서드와 **동일한 이름, 동일한 매개변수, 동일한 반환 타입**을 가져야 한다. `@Override` 애너테이션을 붙이면 컴파일러가 오버라이딩 규칙을 올바르게 지켰는지
  검사해주므로, 실수를 방지하기 위해 사용하는 것이 좋다.

---

### 3. 다형성 (Polymorphism)

하나의 객체가 여러 타입을 가질 수 있는 성질. 즉, 부모 타입의 참조 변수가 자식 타입의 객체를 가리킬 수 있는 능력을 학습했다.

* **학습 목표 (Why?)**:
  코드를 특정 자식 클래스에 종속되지 않고, 더 일반적인 부모 타입에 의존하게 만들어 유연하고 확장 가능한 프로그램을 설계하기 위함이다.

* **핵심 원리 (What?)**:
  부모 타입으로 객체를 다룰 때는, 컴파일 시점에는 부모 클래스에 선언된 멤버에만 접근할 수 있다. 하지만 메서드를 호출하면, **오버라이딩된 경우 실제 객체의 자식 클래스 메서드가 실행**된다.
  | 구분 | 설명 |
  | :--- | :--- |
  | **다형적 할당** | `Vehicle myCar = new Bus();` 부모 타입 변수에 자식 객체 할당. |
  | **다형적 매개변수**| `void drive(Vehicle v)` 와 같이 메서드가 부모 타입을 매개변수로 받으면, 모든 자식 객체를 인자로 전달할 수 있음. |
  | **다형적 배열** | `Vehicle[] garage = {new Bus(), new Truck()};` 부모 타입 배열에 다양한 자식 객체들을 함께 저장할 수 있음. |

* **문법 및 사용법 (How?)**:
  ```java
  public class Driver {
      // drive 메서드는 Vehicle의 자식인 Bus, Truck 등 어떤 객체든 운전할 수 있음.
      public void drive(Vehicle vehicle) {
          System.out.println(vehicle.brand + " 운전을 시작합니다.");
          vehicle.start(); // 호출은 Vehicle의 start()지만, 실제로는 각 객체의 오버라이딩된 start()가 실행됨
      }
  }
  ```

---

### 4. `instanceof`와 다운캐스팅 (Downcasting)

다형적으로 관리되는 객체의 원래 타입을 확인하고, 해당 타입의 고유한 멤버에 접근하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  부모 타입 변수에서는 보이지 않는 자식 클래스 고유의 필드나 메서드를 안전하게 사용하기 위함이다.

* **핵심 원리 (What?)**:
    * **`instanceof`**: 연산자 좌측의 객체 참조 변수가, 우측의 클래스 타입으로 형 변환이 가능한지 여부를 `true`/`false`로 확인한다.
    * **다운캐스팅 (Downcasting)**: `instanceof`로 타입이 확인된 부모 타입의 참조 변수를, `(자식클래스타입)` 구문을 사용하여 자식 타입으로 강제 형 변환한다.

* **문법 및 사용법 (How?)**:
  ```java
  public void checkVehicle(Vehicle vehicle) {
      // vehicle 변수가 Bus 타입의 인스턴스인지 확인
      if (vehicle instanceof Bus) {
          // 확인되었으므로, Bus 타입으로 안전하게 다운캐스팅
          Bus bus = (Bus) vehicle;
          bus.checkPassengers(); // Bus 클래스 고유의 메서드 호출
      } else if (vehicle instanceof Truck) {
          Truck truck = (Truck) vehicle;
          truck.loadCargo(); // Truck 클래스 고유의 메서드 호출
      }
  }
  ```

---

### 5. `protected` 접근 제어자

상속 관계에 있는 클래스들 사이의 멤버 공유를 위해 특별히 고안된 접근 제어자를 학습했다.
| 접근 제어자 | 같은 클래스 | 같은 패키지 | 다른 패키지 자식 클래스 | 다른 패키지 |
| :--- | :--- | :--- | :--- | :--- |
| `public` | O | O | O | O |
| `protected`| O | O | O | X |
| `default` | O | O | X | X |
| `private` | O | X | X | X |

* **학습 목표 (Why?)**:
  `public`처럼 완전히 공개하지는 않으면서도, '가족(같은 패키지)'과 '자식(상속받은 클래스)'에게는 상속받아 확장하거나 사용할 수 있도록 멤버를 제한적으로 공개하기 위함이다.

* **핵심 원리 (What?)**:
  `protected`로 선언된 멤버는 **① 같은 패키지에 있는 모든 클래스**와, **② 다른 패키지에 있더라도 상속 관계에 있는 자식 클래스**에서 접근할 수 있다.

---

## 오늘의 깨달음 💡

* 상속은 단순히 코드를 재사용하는 '복사/붙여넣기'가 아니라, **'다형성'이라는 강력한 개념을 실현하기 위한 기반 기술**임을 깨달았다. `Vehicle`이라는 하나의 타입으로 `Bus`와 `Truck`을 모두
  다룰 수 있게 되자, 코드가 특정 자식 클래스에 얽매이지 않고 훨씬 유연해졌다.

* `super`는 자식과 부모를 잇는 중요한 **연결고리**였다. `super()`를 통해 부모의 생성 과정을 존중하고, `super.메서드()`를 통해 부모의 기능을 빌려와 확장하는 등, 부모와의 관계를 어떻게
  설정할지 결정하는 핵심 키워드였다.

* 다형성을 사용하면 **코드가 미래의 변화에 열려있게 된다.** `Driver` 클래스는 새로운 종류의 `Vehicle`(e.g., `Excavator`)이 추가되어도 코드를 단 한 줄도 수정할 필요가 없다.
  이것이 바로 객체 지향의 OCP(개방-폐쇄 원칙)를 실현하는 방법임을 알게 되었다.

* `protected`는 '우리 가족(같은 패키지)과 내 자식에게만 물려주는 유산'과 같은 느낌이었다. 외부에는 공개하고 싶지 않지만, 클래스를 확장하여 사용할 다른 개발자에게는 특정 기능을 제공하고 싶을 때 매우
  유용한 접근 제어자임을 이해했다.

* 생성자는 연쇄적으로 호출된다는 사실이 인상 깊었다. 자식 객체를 만들면, 그 안에서 부모 생성자가 먼저 호출되고, 그 부모가 또 다른 부모가 있다면 거슬러 올라가 최상위 조상부터 순서대로 객체가 만들어진다. 이는
  객체가 '뿌리'부터 순서대로 안전하게 생성되는 것을 보장하는 중요한 메커"니즘이었다.