# TIL - 2025.07.03 - Java 추상화(추상 클래스, 인터페이스)와 final, 예외 처리 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #abstract #interface #final #ExceptionHandling

---

## 오늘 배운 내용 🔍

- 데이터와 상태를 함께 관리하는 열거형(`enum`)의 심화 활용
- 변경 불가능함을 명시하는 `final` 키워드의 세 가지 용법 (필드, 메서드, 클래스)
- `static final` 상수의 개념과 싱글턴(Singleton) 디자인 패턴
- 미완성 설계도 역할을 하는 추상 클래스(`abstract class`)와 추상 메서드
- 클래스가 구현해야 할 '기능 명세'를 정의하는 인터페이스(`interface`)
- `try-catch-finally`, `throw`, `throws`를 이용한 예외 처리(Exception Handling)

---

## 어려웠던 점 💣

* **추상 클래스와 인터페이스의 차이**: 둘 다 객체 생성이 불가능하고 미완성 메서드를 포함할 수 있다는 점에서 역할이 모호하게 느껴졌다. 추상 클래스는 'is-a' 관계의 **상속 계층**을 표현하는 데
  적합하고(e.g., `Dog is an Animal`), 인터페이스는 클래스의 종류와 상관없이 특정 '행동'이나 '자격'을 부여하는 **'can-do' 관계**에 적합하다는(e.g.,
  `Car can be Drivable`) 개념적 차이를 구분하는 것이 중요했다.

* **`throw`와 `throws`의 혼동**: 두 키워드가 비슷해 보여 헷갈렸다. `throw`는 예외 객체를 **'직접 던지는 행위'** (`throw new Exception();`)이고, `throws`는
  메서드 선언부에 붙어 "이 메서드는 이러한 예외를 던질 수 있으니, 호출하는 쪽에서 처리해야 합니다"라고 **'책임을 전가하는 선언'** (`void myMethod() throws Exception`)이라는
  역할 차이를 이해해야 했다.

* **`enum`의 진화**: `enum`이 단순히 상수를 나열하는 것을 넘어, 내부에 필드, 생성자, 메서드를 가질 수 있는 하나의 완전한 '클래스'처럼 동작할 수 있다는 점이 새롭고 강력하게 느껴졌다.

* **`finally` 블록의 `return` 위험성**: `finally` 블록에서 `return`을 사용하면, `try`나 `catch` 블록에서 이미 `return`을 했더라도 그 반환값을 **덮어쓰고**
  `finally`의 값이 최종 반환된다는 규칙은 예상치 못한 버그를 유발할 수 있는 매우 위험한 부분이라고 느꼈다.

---

## 정리 🖇️

### 1. `final` 키워드: 변경 불가능한 제약

`final`은 변수, 메서드, 클래스에 적용되어 '최종적임', 즉 '변경 불가능함'을 명시하는 키워드다.

* **학습 목표 (Why?)**:
  프로그램의 안정성과 예측 가능성을 높이기 위함이다. 중요한 값이 변경되는 것을 막고, 핵심적인 로직이 하위 클래스에서 임의로 변경되는 것을 방지할 수 있다.

* **핵심 원리 (What?)**:
  | 적용 대상 | 의미 |
  | :--- | :--- |
  | **`final` 필드** | **상수(Constant)**. 선언 시 또는 생성자에서 단 한 번만 초기화할 수 있으며, 이후 재할당이 불가능하다. |
  | **`final` 메서드**| **오버라이딩 불가**. 자식 클래스에서 이 메서드를 재정의할 수 없다. |
  | **`final` 클래스**| **상속 불가**. 어떤 클래스도 이 클래스를 `extends` 할 수 없다. (e.g., `String`, `Math` 클래스) |

* **문법 및 사용법 (How?)**:
  ```java
  // static final: 클래스 레벨의 공유 상수 (대문자와 스네이크 케이스로 명명)
  public static final double PI = 3.14159;

  public class UserProfile {
      public final String userId; // 객체마다 다른 값을 갖는 final 필드 (생성자에서 초기화)

      public UserProfile(String userId) {
          this.userId = userId;
      }

      public final void displayId() { // 오버라이딩 불가
          System.out.println("User ID: " + this.userId);
      }
  }
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * **싱글턴 패턴(Singleton Pattern)**: 생성자를 `private`으로 막고, `static final`로 자기 자신의 인스턴스를 단 하나만 생성하여 제공하는 디자인 패턴. 애플리케이션
      전체에서 유일해야 하는 객체(e.g., 설정 관리자)를 만들 때 사용된다.

---

### 2. 추상화: 추상 클래스(Abstract Class) vs. 인터페이스(Interface)

객체 지향의 핵심인 추상화를 구현하는 두 가지 주요 방법을 학습했다. 둘 다 미완성 설계도이며, 직접 객체를 생성할 수 없다.

* **학습 목표 (Why?)**:
  공통적인 특징이나 기능을 추출하여 상위 타입(추상 클래스, 인터페이스)을 정의하고, 하위 클래스들이 이를 상속받거나 구현하도록 '강제'함으로써, 일관성 있고 유연한 다형적 구조를 만들기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 추상 클래스 (Abstract Class) | 인터페이스 (Interface) |
  | :--- | :--- | :--- |
  | **키워드** | `abstract class` / `abstract` 메서드 | `interface` / 모든 메서드는 기본적으로 `public abstract` |
  | **핵심 관계**| **'is-a' (상속 관계)**. "A는 B의 한 종류다." | **'can-do' (구현 관계)**. "A는 B를 할 수 있다." |
  | **특징** | **일반 필드, 일반 메서드, 생성자**를 가질 수 있다. | **상수 필드(`static final`)**와 **추상 메서드**만 가질 수 있다. (Java 8부터 `default`,
  `static` 메서드 추가) |
  | **다중 상속**| ❌ **단일 상속**만 가능. | ✅ **다중 구현** 가능 (`implements A, B, C...`). |
  | **사용 목적**| 관련성이 높은 클래스들의 **공통된 필드와 메서드를 추출**하여 상속 계층을 만들 때. | 클래스의 종류와 상관없이, 특정 **기능(역할)을 구현하도록 강제**할 때. |

* **문법 및 사용법 (How?)**:
  ```java
  // 추상 클래스: 공통적인 구조와 구현을 일부 제공
  public abstract class ReportGenerator {
      // 공통 로직을 가진 일반 메서드
      public void generate() {
          createHeader();
          createBody(); // 추상 메서드 호출
          createFooter();
      }

      // 구현이 필요한 부분만 추상 메서드로 남겨둠
      protected abstract void createBody();
  }

  // 인터페이스: 구현해야 할 기능의 '명세서' 역할
  public interface Downloadable {
      void download(); // 구현은 각 클래스에 위임
  }
  public interface Uploadable {
      void upload(String fileName);
  }

  // 다중 인터페이스 구현
  public class FileHandler implements Downloadable, Uploadable {
      @Override
      public void download() { /* ... */ }
      @Override
      public void upload(String fileName) { /* ... */ }
  }
  ```

---

### 3. 예외 처리 (Exception Handling)

프로그램 실행 중 발생할 수 있는 오류(예외)에 대처하여 프로그램이 비정상적으로 종료되는 것을 막고, 안정적으로 계속 실행되도록 하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  정상적인 실행 흐름과 오류 처리 흐름을 명확히 분리하여 코드의 가독성과 안정성을 높이고, 문제가 발생했을 때 사용자에게 적절한 피드백을 주거나 복구 로직을 수행하기 위함이다.

* **핵심 원리 (What?)**:
  | 키워드 | 역할 |
  | :--- | :--- |
  | `try` | 예외가 발생할 가능성이 있는 코드를 감싸는 블록. |
  | `catch`| `try` 블록에서 특정 예외가 발생했을 때 실행되는 블록. |
  | `finally`| 예외 발생 여부와 상관없이 **항상 실행**되는 블록. 주로 자원 해제(e.g., 파일 닫기)에 사용됨. |
  | `throw` | 개발자가 의도적으로 예외 객체를 **생성하여 던지는** 행위. |
  | `throws` | 메서드 선언부에 사용하여, "이 메서드는 이러한 예외를 처리하지 않고 호출한 쪽으로 던지겠다"고 **책임을 전가**하는 선언. |

* **문법 및 사용법 (How?)**:
  ```java
  // 사용자 정의 예외 클래스
  public class AuthException extends Exception {
      public AuthException(String message) {
          super(message);
      }
  }

  public class AuthService {
      // 이 메서드는 AuthException을 직접 처리하지 않고 호출자에게 던짐 (throws)
      public void login(String id, String pw) throws AuthException {
          if (!id.equals("admin")) {
              // 특정 조건에서 예외를 직접 발생시킴 (throw)
              throw new AuthException("존재하지 않는 아이디입니다.");
          }
          // ... 로그인 성공 로직 ...
      }
  }

  // AuthService를 사용하는 쪽
  public class AuthController {
      public void tryLogin() {
          AuthService service = new AuthService();
          // throws로 던져진 예외를 try-catch로 처리
          try {
              service.login("user", "1234");
              System.out.println("로그인 성공!");
          } catch (AuthException e) {
              System.out.println("로그인 실패: " + e.getMessage());
          } finally {
              System.out.println("로그인 시도가 종료되었습니다.");
          }
      }
  }
  ```

---

## 오늘의 깨달음 💡

* **추상 클래스는 '유전', 인터페이스는 '자격증'이었다.** 추상 클래스는 부모의 특징(필드, 메서드)을 물려받는 상속의 확장 개념인 반면, 인터페이스는 클래스의 종류와 상관없이 '운전 가능(
  `Drivable`)', '수영 가능(`Swimmable`)'과 같은 특정 능력이나 역할을 부여하는 자격증과 같았다.

* `final`은 단순한 제약이 아니라, 코드에 **'신뢰성'**과 **'안정성'**을 부여하는 중요한 키워드다. `final`로 선언된 필드나 메서드는 "이것은 절대 변하지 않으니 안심하고 사용해도 좋다"는
  강력한 메시지를 전달한다.

* 예외 처리는 단순히 에러를 잡는 방어적인 코드가 아니라, 프로그램의 **정상 흐름과 예외 흐름을 명확히 분리**하여 코드를 더 깨끗하고 견고하게 만드는 **설계 기법**임을 깨달았다. `try` 블록에는 성공
  시나리오만 남기고, 모든 실패 시나리오는 `catch` 블록으로 분리할 수 있다.

* `enum`을 잘 설계하면 상태(State)와 그 상태에 관련된 데이터 및 행동을 하나의 응집도 높은 단위로 묶을 수 있다. 이는 `if`나 `switch` 문을 줄이고, 상태 관련 로직을 객체 지향적으로 관리할
  수 있게 해주는 강력한 도구였다.

* 싱글턴 패턴은 '객체를 단 하나만 존재하도록 강제하는 설계'라는 점에서 흥미로웠다. `private` 생성자와 `static` 메서드의 조합으로 클래스의 인스턴스화 과정을 완벽하게 통제하는 모습이 인상 깊었다.