# TIL - 2025.07.04 - Java 다형성 심화, 제네릭 및 핵심 API 클래스 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #Polymorphism #static #Generics #Object #String #Wrapper #java.time

---

## 오늘 배운 내용 🔍

- `static` 메서드 숨김(Hiding)과 인스턴스 메서드 오버라이딩(Overriding)의 동작 차이
- 모든 클래스의 최상위 조상인 `Object` 클래스의 주요 메서드 (`toString`, `equals`, `hashCode`)
- 불변(Immutable) 객체인 `String` 클래스와 Wrapper 클래스의 특징
- 기존 `Date`, `Calendar`의 단점을 보완한 `java.time` 패키지 (`LocalDate`, `LocalDateTime`)
- 컴파일 시점에 타입 안정성을 보장하는 제네릭(Generics)의 개념과 타입 제한
- `for-each` 루프의 동작 원리인 `Iterable`과 `Iterator` 인터페이스

---

## 어려웠던 점 💣

* **`static` 메서드는 오버라이딩되지 않는다는 점**: `Parent p = new Child();`와 같이 다형적으로 선언된 변수로 `static` 메서드를 호출했을 때, `p`가 가리키는 실제 객체(
  `Child`)의 메서드가 아닌, 참조 변수의 타입(`Parent`)에 있는 `static` 메서드가 호출되어 혼란스러웠다. 이는 인스턴스 메서드는 런타임에 실제 객체를 보고 호출될 메서드가 결정되는 반면,
  `static` 메서드는 클래스에 소속되어 컴파일 시점에 참조 변수의 타입을 보고 결정되기 때문이라는 근본적인 차이를 이해해야 했다.

* **`equals()`와 `hashCode()`를 함께 재정의해야 하는 이유**: 두 메서드를 왜 항상 함께 재정의해야 하는지 그 필요성이 와닿지 않았다. 이는 `HashSet`, `HashMap`과 같은 해시
  기반 컬렉션의 동작 원리와 관련이 있었다. 컬렉션은 먼저 `hashCode()`를 통해 객체가 저장될 '버킷(위치)'을 빠르게 찾고, 그 버킷 안에서 `equals()`를 통해 최종적으로 동등성을 확인한다.
  따라서 `equals()`만 재정의하고 `hashCode()`를 그대로 두면, 내용이 같은 객체라도 해시 코드가 달라 다른 버킷에 저장되어 '같은 객체를 찾지 못하는' 문제가 발생할 수 있음을 알게 되었다.

* **제네릭 클래스의 내부 구현**: `MyArrayList<T>`를 직접 구현해보니, 제네릭이 단순히 타입을 지정하는 문법이 아니라 내부적으로는 `Object[]` 배열을 사용하고, 값을 가져올 때마다 `(T)`
  로 타입 캐스팅을 해주는 방식으로 동작한다는 점이 인상 깊었다. 제네릭은 컴파일러에게 타입 정보를 제공하여, 개발자가 직접 해야 할 번거롭고 위험한 타입 캐스팅을 대신 해주는 '안전장치' 역할을 했다.

* **`Iterable`과 `Iterator` 인터페이스의 관계**: `for-each` 루프가 어떻게 동작하는지 그 원리가 궁금했다. `Iterable` 인터페이스를 구현한 클래스는 "나는 순회할 수 있는 데이터
  구조다"라고 선언하는 것이고, `iterator()` 메서드는 실제로 순회를 담당하는 '탐색기' 객체인 `Iterator`를 반환한다. `for-each` 루프는 이 `Iterator`의 `hasNext()`와
  `next()` 메서드를 내부적으로 호출하여 요소를 하나씩 꺼내오는 것이었다.

---

## 정리 🖇️

### 1. `static` 메서드 숨김(Hiding) vs. 인스턴스 메서드 오버라이딩

상속 관계에서 `static` 메서드와 인스턴스 메서드는 다르게 동작하며, 이는 다형성에 큰 영향을 미친다.

* **학습 목표 (Why?)**:
  다형성이 적용된 코드에서 메서드 호출 결과가 어떻게 달라지는지 예측하고, `static` 메서드가 다형성의 원칙을 따르지 않는 이유를 이해하기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 오버라이딩 (Overriding) - 인스턴스 메서드 | 숨김 (Hiding) - `static` 메서드 |
  | :--- | :--- | :--- |
  | **적용 대상** | 인스턴스 메서드 | `static` 메서드 |
  | **호출 결정 시점** | **런타임(Runtime)**. 참조 변수가 가리키는 **실제 객체**의 타입을 따른다. | **컴파일 타임(Compile-time)**. **참조 변수**의 타입을 따른다. |
  | **다형성** | ✅ **적용됨**. | ❌ **적용되지 않음**. |

* **문법 및 사용법 (How?)**:
  ```java
  class Service {
      public static void getInfo() { System.out.println("Service Info"); }
      public void process() { System.out.println("Service Process"); }
  }
  class ExtendedService extends Service {
      public static void getInfo() { System.out.println("Extended Info"); } // Hiding
      @Override
      public void process() { System.out.println("Extended Process"); } // Overriding
  }

  // 다형적 할당
  Service s = new ExtendedService();

  // static 메서드 호출: 참조 변수 타입인 Service의 메서드가 호출됨
  s.getInfo(); // 출력: Service Info

  // 인스턴스 메서드 호출: 실제 객체 타입인 ExtendedService의 메서드가 호출됨
  s.process(); // 출력: Extended Process
  ```

---

### 2. `Object` 클래스와 주요 메서드

모든 자바 클래스가 암묵적으로 상속받는 최상위 조상 클래스의 핵심 메서드를 학습했다.

* **학습 목표 (Why?)**:
  객체의 문자열 표현을 커스터마이징(`toString`)하고, 객체 간의 내용적 동등성을 올바르게 비교하며(`equals`, `hashCode`), 자바의 모든 객체가 갖는 기본 기능을 이해하기 위함이다.

* **핵심 원리 (What?)**:
  | 메서드 | 기본 동작 | 재정의(Override) 목적 |
  | :--- | :--- | :--- |
  | `toString()` | `클래스명@해시코드` 형태의 문자열 반환. | 객체의 주요 필드 값을 포함하는, 의미 있는 문자열을 반환하기 위해. |
  | `equals(Object obj)` | `==` 연산자와 동일. 두 참조 변수가 같은 객체를 가리키는지 비교. | **내용(값)이 같은지**를 비교하기 위해. 논리적 동등성을 정의. |
  | `hashCode()` | 객체의 메모리 주소를 기반으로 한 정수 값 반환. | `equals()`가 `true`를 반환하는 두 객체는 **반드시 같은 `hashCode()` 값을 반환**하도록. |

* **문법 및 사용법 (How?)**:
  ```java
  public class Product {
      private String productCode;

      @Override
      public boolean equals(Object obj) {
          if (this == obj) return true;
          if (!(obj instanceof Product other)) return false;
          // 제품 코드가 같으면 같은 객체로 간주
          return this.productCode.equals(other.productCode);
      }

      @Override
      public int hashCode() {
          // equals 비교에 사용된 필드(productCode)로 해시 코드를 생성
          return java.util.Objects.hash(productCode);
      }
  }
  ```

---

### 3. 제네릭 (Generics)

클래스나 메서드를 정의할 때, 다룰 데이터의 타입을 미리 지정하지 않고 실제 사용하는 시점에 지정할 수 있게 하는 메커니즘을 학습했다.

* **학습 목표 (Why?)**:
  **타입 안정성**을 높이고, 불필요한 **형 변환(Casting)** 코드를 줄이기 위함이다. 하나의 클래스나 메서드로 다양한 타입을 처리할 수 있어 코드의 재사용성이 극대화된다.

* **핵심 원리 (What?)**:
  클래스나 메서드 이름 뒤에 꺾쇠괄호(`< >`)를 사용하여 타입 매개변수(e.g., `<T>`, `<E>`, `<K, V>`)를 선언한다. 이 타입 매개변수는 해당 클래스나 메서드 내부에서 실제 타입처럼
  사용된다.
    * **타입 제한**: `<T extends 상위타입>` 형태로, 제네릭에 사용될 수 있는 타입을 특정 클래스나 인터페이스의 자식으로 제한할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  // 제네릭 클래스 정의
  public class Box<T> {
      private T item;
      public void setItem(T item) { this.item = item; }
      public T getItem() { return this.item; }
  }

  // 제네릭 클래스 사용
  Box<String> stringBox = new Box<>(); // T가 String으로 결정됨
  stringBox.setItem("Hello, Generics!");
  String content = stringBox.getItem(); // 강제 형 변환이 필요 없음

  Box<Integer> intBox = new Box<>(); // T가 Integer로 결정됨
  intBox.setItem(123);
  int number = intBox.getItem();
  ```

---

### 4. 주요 API 클래스 (`String`, `Wrapper`, `java.time`)

자바 표준 라이브러리에서 자주 사용되는 핵심 클래스들을 학습했다.
| 클래스 | 주요 특징 및 역할 |
| :--- | :--- |
| **`String`** | **불변(Immutable) 객체**. 한 번 생성되면 내부의 문자열 내용이 절대 바뀌지 않음. `replace`, `substring` 등은 모두 새로운 `String` 객체를
생성하여 반환. |
| **`Wrapper` 클래스**| `Integer`, `Double` 등 8개의 기본 타입을 객체로 감싼 클래스. 제네릭이나 컬렉션 프레임워크처럼 객체만 다룰 수 있는 곳에 기본 타입을 사용하기 위해 필요. **
박싱(Boxing)**과 **언박싱(Unboxing)**이 자동으로 일어남. |
| **`java.time` 패키지** | `LocalDate`(날짜), `LocalTime`(시간), `LocalDateTime`(날짜+시간). 불변 객체이며 `plusDays()`, `minusHours()` 등
직관적인 메서드를 제공하여 날짜/시간 계산을 쉽게 만들어줌. |

---

## 오늘의 깨달음 💡

* **`static` 메서드는 상속 계층이 아닌, 클래스 자체에 묶여있다.** 이 때문에 다형성이 적용되지 않고, 참조 변수의 '타입'을 따라 컴파일 시점에 호출될 함수가 결정된다는 것을 명확히 이해했다. 이는
  객체 지향의 다형성 원칙에서 중요한 예외 규칙이었다.

* **다형성은 '역할'에 따라 코드를 작성하게 해준다.** `Manager`는 상대가 `Developer`인지 `Designer`인지 구체적으로 알 필요 없이, 그냥 `Employee`라는 공통된 '역할'에 맞게
  `work()`를 시키면 된다. 이것이 바로 결합도를 낮추고 유연성을 높이는 좋은 설계의 핵심이다.

* **`equals`와 `hashCode`는 한 세트다.** `HashSet`과 같은 컬렉션은 객체의 동등성을 판단할 때 두 메서드를 모두 사용한다. `equals`가 '정밀 검사'라면, `hashCode`는 '
  사전 검사'와 같아서, 둘 중 하나라도 규칙에 맞지 않으면 컬렉션이 객체를 제대로 인식하지 못하는 문제가 발생할 수 있다.

* **제네릭은 '타입'을 매개변수처럼 다루게 해주는 강력한 추상화 도구다.** `ArrayList<String>`, `ArrayList<Integer>`처럼 매번 새로운 타입의 리스트 클래스를 만들 필요가 없게
  해주는 제네릭 덕분에, 개발자는 타입에 구애받지 않고 자료구조의 '로직'에만 집중할 수 있다.

* 직접 `MyArrayList`를 만들어보니, 우리가 편리하게 사용하던 `ArrayList`의 내부는 결코 간단하지 않다는 것을 깨달았다. 배열 복사, 타입 캐스팅, 용량 관리 등 복잡한 작업들이 추상화되어 숨겨져
  있었기에 우리가 편하게 사용할 수 있었던 것이다.

* 좋은 API는 사용하기 쉬워야 한다. `java.util.Date`의 복잡하고 혼란스러운 API와 달리, `java.time` 패키지는 `plusDays()`, `between()`처럼 사람이 생각하는 방식과
  유사한 직관적인 메서드를 제공하여 코드를 훨씬 읽기 쉽고 안전하게 만들어준다. 좋은 설계의 중요성을 다시 한번 느꼈다.