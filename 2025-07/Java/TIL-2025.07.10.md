# TIL - 2025.07.10 - 자바 서블릿(Servlet) 기본 및 웹 애플리케이션 동작 원리 개념 이해

## 카테고리 🏷️

#TIL #Java #Servlet #WAS #Tomcat #Web #HTTP #3TierArchitecture

---

## 오늘 배운 내용 🔍

- 웹 애플리케이션 서버(WAS)와 서블릿 컨테이너(Tomcat)의 역할
- 동적 웹 페이지를 만드는 자바 기술인 서블릿(Servlet)의 개념과 생명주기
- `@WebServlet` 애너테이션을 이용한 서블릿 클래스와 URL 요청 매핑
- `HttpServletRequest`를 통해 HTTP 요청 정보(파라미터, 메서드 등)를 읽는 방법
- `HttpServletResponse`를 통해 동적인 HTML 응답을 생성하는 방법
- 3계층 아키텍처(Controller-Repository-Model)를 서블릿 애플리케이션에 적용하는 방법

---

## 어려웠던 점 💣

* **웹 서버, WAS, 서블릿 컨테이너의 관계**: 세 용어가 혼재되어 있어 처음에는 혼란스러웠다. 웹 서버(e.g., Apache)는 정적 콘텐츠를, WAS(e.g., Tomcat)는 동적 콘텐츠를 처리하며,
  WAS 내부에 서블릿을 실행하고 관리하는 '서블릿 컨테이너'가 포함되어 있다는 계층적 관계로 정리했다.

* **제어의 역전 (IoC, Inversion of Control)**: 내가 작성한 서블릿 클래스를 직접 `new`로 생성하고 `main` 메서드에서 실행하는 것이 아니라, 톰캣(WAS)이 특정 URL 요청이
  들어왔을 때 대신 서블릿 객체를 생성하고 `doGet`, `doPost`와 같은 메서드를 '알아서' 호출해준다는 개념이 낯설었다. 프로그램의 실행 흐름을 내가 아닌 외부(컨테이너)가 제어한다는 것이 핵심이었다.

* **자바 코드로 HTML 작성의 한계**: `PrintWriter`를 이용해 `out.println("<h1>안녕하세요</h1>");` 와 같이 자바 코드 안에서 HTML 문자열을 직접 작성하는 방식은 매우
  번거롭고, 디자이너와의 협업이 거의 불가능할 정도로 비효율적으로 느껴졌다. 이는 왜 JSP나 Thymeleaf 같은 뷰 템플릿 엔진이 필요한지를 절실히 느끼게 했다.

* **Repository의 `static` 필드**: `DancerRepository`의 `dancerList`가 `static`으로 선언된 이유가 궁금했다. 서블릿은 각 HTTP 요청마다 새로운 스레드에서 처리될
  수 있지만, 서블릿 객체 자체는 싱글턴처럼 하나만 생성되어 재사용된다. 만약 `dancerList`가 인스턴스 필드라면 요청마다 새로운 리스트가 생성될 수 있다. `static`으로 선언함으로써, 모든 요청이 *
  *애플리케이션 전역에서 공유되는 단 하나의 데이터 저장소**에 접근하도록 보장하는 것이었다.

---

## 정리 🖇️

### 1. 서블릿(Servlet)과 웹 애플리케이션 서버(WAS)

정적인 HTML 파일을 넘어, 사용자의 요청에 따라 동적으로 변하는 웹 페이지를 만드는 자바 기술의 기초를 학습했다.

* **학습 목표 (Why?)**:
  복잡한 HTTP 프로토콜이나 소켓 통신을 직접 다루지 않고도, 자바 언어를 사용하여 웹 요청을 처리하고 동적인 응답(HTML, JSON 등)을 생성하는 서버 사이드 애플리케이션을 개발하기 위함이다.

* **핵심 원리 (What?)**:
    * **서블릿 (Servlet)**: 자바로 만든, 서버에서 실행되는 작은 프로그램. `HttpServlet` 클래스를 상속받아 만들며, 클라이언트의 요청(Request)을 처리하고 응답(Response)을
      생성하는 역할을 한다.
    * **서블릿 컨테이너 (Servlet Container)**: 서블릿의 생명주기(생성, 초기화, 소멸)를 관리하고, 특정 URL 요청을 해당 서블릿과 연결(매핑)하며, 멀티스레딩을 지원하는 런타임
      환경. **톰캣(Tomcat)**이 대표적인 서블릿 컨테이너 구현체다.
    * **서블릿의 생명주기**:
        1. **`init()`**: 최초 요청 시 단 한 번 호출되어 서블릿을 초기화한다.
        2. **`doGet()`, `doPost()` 등**: 각 요청마다 스레드에 의해 반복적으로 호출되어 실제 작업을 처리한다.
        3. **`destroy()`**: 서버가 종료될 때 단 한 번 호출되어 자원을 해제한다.

* **문법 및 사용법 (How?)**:
  ```java
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.io.PrintWriter;

  // @WebServlet 애너테이션으로 "/hello" URL 요청을 이 서블릿과 매핑
  @WebServlet("/hello")
  public class HelloServlet extends HttpServlet {

      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
          // 1. 요청 정보 확인 (여기서는 사용 안 함)

          // 2. 응답 설정
          resp.setContentType("text/html; charset=UTF-8");

          // 3. 동적 HTML 생성
          PrintWriter out = resp.getWriter();
          out.println("<html><body>");
          out.println("<h1>Hello, Servlet!</h1>");
          out.println("</body></html>");
      }
  }
  ```

---

### 2. `HttpServletRequest`와 `HttpServletResponse`

서블릿이 클라이언트와 소통하기 위한 두 가지 핵심 객체를 학습했다.

* **학습 목표 (Why?)**:
  클라이언트가 보낸 데이터를 읽고(`Request`), 그에 대한 처리 결과를 클라이언트에게 전달하는(`Response`) 웹의 기본 동작을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  | 객체 | 역할 | 주요 메서드 |
  | :--- | :--- | :--- |
  | **`HttpServletRequest` (요청)** | 클라이언트가 보낸 HTTP 요청의 모든 정보를 담고 있음. | `getParameter(name)`: 폼 데이터 등 단일 파라미터 값 조회.<br>
  `getParameterValues(name)`: 체크박스 등 여러 개의 값을 가진 파라미터 조회.<br>`getMethod()`: 요청 방식(`GET`/`POST`) 확인. |
  | **`HttpServletResponse` (응답)**| 클라이언트에게 보낼 HTTP 응답을 생성하는 객체. | `setContentType(type)`: 응답의 MIME 타입 설정 (e.g.,
  `"text/html"`).<br>`setCharacterEncoding(charset)`: 문자 인코딩 설정 (e.g., `"UTF-8"`).<br>`getWriter()`: 응답 본문에 텍스트를 쓸 수 있는
  `PrintWriter` 객체를 반환. |

* **문법 및 사용법 (How?)**:
  ```java
  // 폼에서 username과 hobbies (체크박스) 값을 받아 처리하는 서블릿
  @WebServlet("/register")
  public class RegisterServlet extends HttpServlet {
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
          // POST 요청의 한글 깨짐 방지
          req.setCharacterEncoding("UTF-8");

          // 요청 파라미터 읽기
          String username = req.getParameter("username");
          String[] hobbies = req.getParameterValues("hobbies");

          System.out.println("이름: " + username);
          System.out.println("취미: " + Arrays.toString(hobbies));

          // 처리 결과 응답
          resp.setContentType("text/html; charset=UTF-8");
          PrintWriter out = resp.getWriter();
          out.println("<h2>" + username + "님, 환영합니다.</h2>");
      }
  }
  ```

---

### 3. 서블릿을 이용한 3계층 아키텍처 적용

웹 애플리케이션의 복잡도가 증가함에 따라, 코드의 역할을 분리하여 유지보수성을 높이는 설계 방법을 학습했다.

* **학습 목표 (Why?)**:
  요청/응답 처리 로직, 데이터 관리 로직, 데이터 구조 정의를 각각 독립적인 클래스로 분리하여, 한 부분의 변경이 다른 부분에 미치는 영향을 최소화하고 코드의 재사용성을 높이기 위함이다.

* **핵심 원리 (What?)**:
    * **Controller (Servlet)**: 사용자의 HTTP 요청을 가장 먼저 받는 진입점. 요청 파라미터를 분석하고, 어떤 비즈니스 로직을 실행할지 결정한 뒤, 적절한 Repository에 작업을 *
      *위임**한다. 처리 결과를 받아 최종적으로 사용자에게 보여줄 뷰(HTML)를 생성한다.
    * **Repository (DAO)**: 데이터의 영속성(CRUD)을 전담. 데이터 소스(여기서는 `static` `ArrayList`)와의 상호작용을 책임진다.
    * **Model (DTO / VO)**: 데이터의 구조를 정의하는 순수한 자바 객체.

* **문법 및 사용법 (How?)**:
  ```java
  // === Dancer.java (Model) ===
  public class Dancer { /* ... 필드, 생성자, getter ... */ }

  // === DancerRepository.java (Repository) ===
  public class DancerRepository {
      // 모든 요청이 공유할 데이터 저장소 (static)
      private static List<Dancer> dancerList = new ArrayList<>();
      public void save(Dancer dancer) { dancerList.add(dancer); }
      public List<Dancer> findAll() { return dancerList; }
  }

  // === DancerListServlet.java (Controller) ===
  @WebServlet("/dancers")
  public class DancerListServlet extends HttpServlet {
      private final DancerRepository repository = new DancerRepository();

      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
          // 1. 데이터 조회는 Repository에 위임
          List<Dancer> dancers = repository.findAll();

          // 2. 조회된 데이터를 기반으로 동적 HTML 응답 생성
          resp.setContentType("text/html; charset=UTF-8");
          PrintWriter out = resp.getWriter();
          out.println("<h1>Dancer List</h1><ul>");
          for (Dancer d : dancers) {
              out.println("<li>" + d.getName() + "</li>");
          }
          out.println("</ul>");
      }
  }
  ```

---

## 오늘의 깨달음 💡

* **서블릿은 웹 개발의 '엔진'과 같았다.** 복잡한 HTTP 통신이나 멀티스레딩 처리는 서블릿 컨테이너(톰캣)에게 맡기고, 개발자는 `request`와 `response`라는 두 개의 핵심 객체만 다루어
  비즈니스 로직에만 집중할 수 있게 해준다.

* `@WebServlet` 애너테이션은 과거의 복잡한 XML 설정 파일을 대체하는 매우 직관적인 방법이다. URL 경로와 이를 처리할 자바 클래스를 코드 상에서 명확하게 연결해주어 가독성과 유지보수성을 크게
  높여준다.

* **역할 분리는 유연성의 핵심이다.** 사용자 등록 폼을 보여주는 서블릿, 등록 요청을 처리하는 서블릿, 전체 목록을 보여주는 서블릿을 각각 다른 클래스로 분리하니 각자의 책임이 명확해졌다. 나중에 등록 로직만
  변경하고 싶을 때, 다른 서블릿을 건드릴 필요가 전혀 없다.

* 자바 코드로 HTML을 직접 생성하는 `PrintWriter` 방식은 현대 웹 개발에서는 거의 사용되지 않는다는 것을 명확히 느꼈다. 이는 구조(HTML)와 로직(Java)이 심하게 결합되어 있어 유지보수가 매우
  어렵기 때문이다. 이 불편함 자체가 **JSP나 Thymeleaf 같은 뷰 템플릿 엔진**이 왜 필요한지를 가장 확실하게 보여주는 증거였다.

* 웹 개발은 결국 **'요청(Request)에 대한 응답(Response)을 설계하는 과정'** 이라는 본질을 이해했다. 사용자가 어떤 URL과 파라미터로 요청을 보낼지 정의하고, 그 요청에 대해 어떤 데이터를
  가공하여 어떤 형태(HTML, JSON 등)의 응답을 돌려줄지 결정하는 것이 웹 애플리케이션의 전부다.