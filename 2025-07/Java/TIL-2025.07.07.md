# TIL - 2025.07.07 - Java 컬렉션 프레임워크(List, Set, Map)와 파일 입출력 개념 이해

## 카테고리 🏷️

#TIL #Java #CollectionFramework #List #Set #Map #IO #Serialization

---

## 오늘 배운 내용 🔍

- 자바 컬렉션 프레임워크의 3대 인터페이스: `List`, `Set`, `Map`
- `List`: 순서가 있고 중복을 허용하는 데이터 집합 (`ArrayList`)
- `Set`: 순서가 없고 중복을 허용하지 않는 데이터 집합 (`HashSet`)
- `Map`: 키(Key)와 값(Value)을 쌍으로 저장하는 데이터 집합 (`HashMap`)
- 사용자 정의 객체를 `Set`과 `Map`에서 올바르게 사용하기 위한 `equals()`와 `hashCode()` 오버라이딩
- 객체를 파일에 저장하고 불러오는 객체 직렬화(Object Serialization)와 파일 입출력(I/O)

---

## 어려웠던 점 💣

* **List, Set, Map의 용도 구분**: 세 가지 컬렉션이 모두 '데이터를 담는 그릇'이라는 점은 같지만, 어떤 상황에 어떤 그릇을 써야 하는지 명확한 기준을 세우기 어려웠다. '순서'가 중요하면
  `List`, '유일성'이 중요하면 `Set`, '키를 통한 빠른 검색'이 중요하면 `Map`이라는 각각의 핵심적인 특징을 중심으로 사용 목적을 구분해야 했다.

* **`equals()`만 재정의했을 때 `HashSet`이 중복을 거르지 못하는 현상**: `Product` 객체의 `equals()`만 재정의하고 `HashSet`에 동일한 내용의 객체를 여러 번 추가했을 때,
  중복이 제거되지 않아 혼란스러웠다. `HashSet`은 먼저 `hashCode()`를 통해 객체가 저장될 '그룹(버킷)'을 결정하고, 그 그룹 내에서만 `equals()`로 최종 비교를 한다는 내부 동작 원리를
  이해하고 나서야, 왜 두 메서드를 항상 함께 재정의해야 하는지 납득할 수 있었다.

* **`Serializable`의 정체**: 아무런 메서드도 없는 `Serializable` 인터페이스를 왜 구현해야 하는지 그 이유가 궁금했다. 이는 JVM에게 "이 클래스의 객체는 파일에 저장하거나 네트워크로
  전송하는 등, 바이트 스트림 형태로 변환될 수 있음을 허용합니다"라고 알려주는 일종의 '표시(Marker)' 역할을 하는 마커 인터페이스(Marker Interface)라는 것을 알게 되었다.

* **파일 입출력(I/O) 코드의 복잡성**: `FileOutputStream` 안에 `ObjectOutputStream`을 감싸는 등, 여러 스트림 클래스를 조합하여 사용하는 방식이 낯설고 복잡하게 느껴졌다.
  이는 자바 I/O가 다양한 기능을 '데코레이터 패턴'처럼 조합하여 사용하도록 설계되었기 때문임을 알게 되었다.

---

## 정리 🖇️

### 1. 컬렉션 프레임워크 (Collection Framework)

데이터 그룹을 효율적으로 저장하고 관리하기 위해 자바에서 제공하는 표준화된 자료구조 라이브러리를 학습했다.

* **학습 목표 (Why?)**:
  단순 배열의 한계(크기 불변, 불편한 추가/삭제)를 극복하고, 데이터의 특성(순서, 중복, 키-값 관계)에 따라 최적화된 자료구조를 사용하여 더 유연하고 효율적인 프로그램을 만들기 위함이다.

* **핵심 원리 (What?)**:
  컬렉션 프레임워크는 크게 `List`, `Set`, `Map`이라는 3가지 핵심 인터페이스(규격)를 중심으로 구성된다.
  | 인터페이스 | 순서 | 중복 | Key-Value 쌍 | 대표 구현 클래스 | 주요 사용 목적 |
  | :--- | :--- | :--- | :--- | :--- | :--- |
  | **`List`** | ✅ 있음 (인덱스) | ✅ 허용 | ❌ 없음 | `ArrayList` | 순차적인 데이터 목록 관리 |
  | **`Set`** | ❌ 없음 | ❌ **허용 안 함** | ❌ 없음 | `HashSet` | 데이터의 유일성 보장, 중복 제거 |
  | **`Map`** | ❌ 없음 | Key: ❌, Value: ✅ | ✅ 있음 | `HashMap` | 고유한 키를 이용한 빠른 데이터 검색 및 관리 |

---

### 2. `List`, `Set`, `Map` 인터페이스 활용

각 컬렉션의 특징에 맞는 주요 메서드와 사용법을 학습했다.

* **`List<E>`: 순서가 있는 데이터 목록**
    * **특징**: 인덱스(0부터 시작)를 통해 요소에 접근할 수 있으며, 데이터의 중복을 허용한다.
    * **사용법**:
      ```java
      // 순서와 중복이 모두 유지됨
      List<String> userNames = new ArrayList<>();
      userNames.add("Alice"); // [Alice]
      userNames.add("Bob");   // [Alice, Bob]
      userNames.add(0, "Charlie"); // [Charlie, Alice, Bob]
      userNames.add("Alice"); // [Charlie, Alice, Bob, Alice]

      System.out.println(userNames.get(1)); // Alice
      userNames.set(2, "David"); // [Charlie, Alice, David, Alice]
      userNames.remove(0); // [Alice, David, Alice]
      ```

* **`Set<E>`: 중복 없는 데이터 집합**
    * **특징**: 요소의 중복을 허용하지 않으며, 순서를 보장하지 않는다. 데이터의 유일성을 보장하는 데 사용된다.
    * **`equals()`와 `hashCode()`**: 사용자 정의 객체를 `Set`(특히 `HashSet`)에 저장할 때, 중복 여부를 올바르게 판단하려면 반드시 `equals()`와
      `hashCode()` 메서드를 함께 재정의(Override)해야 한다.
    * **사용법**:
      ```java
      // 중복된 "ADMIN"은 무시됨
      Set<String> roles = new HashSet<>();
      roles.add("ADMIN");
      roles.add("USER");
      roles.add("ADMIN");
      System.out.println(roles); // [USER, ADMIN] (순서는 보장되지 않음)

      // List의 중복 제거에 활용
      List<Integer> numbers = List.of(1, 2, 2, 3, 4, 4);
      Set<Integer> uniqueNumbers = new HashSet<>(numbers); // {1, 2, 3, 4}
      ```

* **`Map<K, V>`: 키-값 쌍 데이터**
    * **특징**: 고유한 키(Key)에 하나의 값(Value)을 매핑하여 저장한다. 키를 이용해 매우 빠른 속도로 값을 검색할 수 있다.
    * **사용법**:
      ```java
      Map<String, String> userConfig = new HashMap<>();
      userConfig.put("theme", "dark");
      userConfig.put("language", "ko");

      String theme = userConfig.get("theme"); // "dark"
      userConfig.put("theme", "light"); // 기존 키에 새 값을 넣으면 덮어씀

      // Map 순회
      for (String key : userConfig.keySet()) {
          System.out.println(key + ": " + userConfig.get(key));
      }
      ```

---

### 3. 객체 직렬화(Serialization)와 파일 입출력

메모리 상의 객체를 파일에 저장하거나 네트워크로 전송할 수 있도록 바이트 스트림(byte stream) 형태로 변환하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  애플리케이션이 종료되더라도 데이터를 디스크에 저장하여 유지(영속성, Persistence)하고, 나중에 다시 실행될 때 저장된 데이터를 불러와 상태를 복원하기 위함이다.

* **핵심 원리 (What?)**:
    * **`Serializable` 인터페이스**: 직렬화가 가능한 클래스임을 JVM에게 알려주는 **마커 인터페이스(Marker Interface)**. 직렬화하려는 클래스는 반드시 이 인터페이스를
      `implements` 해야 한다.
    * **`ObjectOutputStream`**: 객체를 바이트 스트림으로 변환하여 출력(파일에 쓰기).
    * **`ObjectInputStream`**: 바이트 스트림을 다시 객체로 변환하여 입력(파일에서 읽기).

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 직렬화 대상 클래스는 Serializable을 구현해야 함
  public class User implements Serializable {
      // ... 필드, 생성자, 메서드 ...
  }

  public class UserRepository {
      private Map<String, User> userMap = new HashMap<>();
      private static final String SAVE_PATH = "users.sav";

      // 2. 객체를 파일에 저장하는 메서드 (직렬화)
      public void save() {
          try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_PATH))) {
              oos.writeObject(userMap); // userMap 객체를 파일에 씀
          } catch (IOException e) {
              e.printStackTrace();
          }
      }

      // 3. 파일에서 객체를 불러오는 메서드 (역직렬화)
      public void load() {
          try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_PATH))) {
              // 파일에서 읽어온 객체를 원래 타입으로 캐스팅
              userMap = (Map<String, User>) ois.readObject();
          } catch (IOException | ClassNotFoundException e) {
              // 파일이 없거나, 클래스 구조가 변경된 경우 등
              userMap = new HashMap<>(); // 비어있는 맵으로 초기화
          }
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `try-with-resources` 구문(`try (...)`)을 사용하면 `close()` 메서드를 자동으로 호출해주므로, 파일 스트림과 같은 외부 자원을 더 안전하고 간결하게 관리할 수 있다.
    * 직렬화된 후 클래스의 구조(필드 추가/삭제 등)가 변경되면, `InvalidClassException`이 발생하며 역직렬화에 실패할 수 있다. 이를 방지하기 위해 `serialVersionUID`를
      명시적으로 관리하는 것이 좋다.

---

## 오늘의 깨달음 💡

* **컬렉션 프레임워크는 '목적에 맞는 도구를 선택하는 것'이 핵심이다.** 데이터의 특성(순서가 중요한가? 중복은 허용되는가? 키로 빠른 검색이 필요한가?)을 먼저 파악하고, 그에 맞는 `List`, `Set`,
  `Map`을 선택하는 것이 효율적인 자료구조 설계의 첫걸음이다.

* **`equals()`와 `hashCode()`를 올바르게 재정의하는 것은, 내가 만든 객체에게 컬렉션 프레임워크라는 세상에서 살아갈 '신분증'을 발급해주는 것과 같았다.** 이 신분증이 없으면 `HashSet`
  이나 `HashMap`은 내 객체가 누구인지, 다른 객체와 같은지 제대로 인식하지 못한다.

* 애플리케이션의 복잡도가 증가할수록, 역할과 책임을 나누는 설계(Controller, Repository, Model)가 빛을 발한다. 각 클래스가 자신의 전문 분야에만 집중하니 코드가 명확해지고, 나중에 데이터
  저장 방식을 바꾸더라도 다른 부분에 미치는 영향을 최소화할 수 있는 유연한 구조가 만들어졌다.

* 객체 직렬화와 파일 입출력을 통해, 프로그램이 종료되면 모든 데이터가 사라지는 메모리의 한계를 넘어, 데이터를 디스크에 영구적으로 보존하는 **'영속성(Persistence)'**을 구현할 수 있었다. 이는
  단순한 프로그램을 넘어, 상태를 기억하고 유지하는 애플리케이션으로 나아가는 중요한 첫걸음이다.