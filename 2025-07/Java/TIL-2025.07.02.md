# TIL - 2025.07.02 - Java 다형성(Upcasting, Downcasting)과 static 멤버 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #Polymorphism #Upcasting #Downcasting #static

---

## 오늘 배운 내용 🔍

- 하나의 타입으로 여러 자식 객체를 다루는 다형성(Polymorphism)의 개념과 활용
- 자동으로 일어나는 형 변환인 업캐스팅(Upcasting)
- `instanceof` 연산자를 이용한 타입 확인과 강제 형 변환인 다운캐스팅(Downcasting)
- '클래스의 멤버'로 존재하는 `static` 필드와 `static` 메서드의 특징
- 객체마다 개별적으로 존재하는 인스턴스 멤버와 모든 객체가 공유하는 `static` 멤버의 차이
- `static` 멤버를 활용한 유틸리티 클래스 설계 방법

---

## 어려웠던 점 💣

* **다형적 변수의 메서드 호출 제약**: `Employee emp = new Developer();`와 같이 부모 타입 변수에 자식 객체를 할당했을 때, `emp` 변수로는 `Developer` 클래스에만 있는
  고유 메서드(`developCode()`)를 호출할 수 없다는 점이 혼란스러웠다. 이는 컴파일러가 코드를 검사하는 시점에는 변수의 '타입'(`Employee`)에 선언된 멤버만 알 수 있기 때문이었다. 자식의
  고유 기능에 접근하려면, 실제 객체의 타입을 확인하고 강제 형 변환(다운캐스팅)하는 과정이 필요했다.

* **`instanceof`의 필요성**: `instanceof` 연산자 없이 무작정 `(Developer) emp`와 같이 다운캐스팅을 시도하면, 만약 `emp` 변수가 `Designer` 객체를 가리키고 있을
  경우 `ClassCastException`이라는 런타임 예외가 발생할 수 있다는 것을 알게 되었다. `instanceof`는 이러한 위험한 캐스팅을 시도하기 전에 타입을 미리 확인하여 프로그램의 안정성을 보장하는
  필수적인 안전장치였다.

* **`static` 메서드 내에서 `this` 사용 불가**: `static` 메서드 안에서 인스턴스 필드에 접근하거나 `this` 키워드를 사용할 수 없는 이유가 궁금했다. `static` 메서드는 클래스
  자체에 소속되어 객체 생성(`new`) 없이도 호출될 수 있는 반면, `this`는 '현재 실행 중인 객체 자기 자신'을 가리키는 참조 변수다. 객체가 존재하지 않을 수도 있는 `static` 문맥에서는
  `this`가 가리킬 대상 자체가 존재하지 않으므로 사용할 수 없다는 것을 이해했다.

* **`static` 필드의 '공유' 개념**: `static` 필드가 모든 객체에 의해 '공유'된다는 개념이 추상적으로 느껴졌다. 하지만 `Count` 예제에서 객체 `c1`을 통해 `static` 필드 `x`의
  값을 변경했더니, 전혀 다른 객체인 `c2`에서 `x`를 조회했을 때 변경된 값이 나오는 것을 보고, `static` 필드는 각 객체에 속한 것이 아니라 클래스 레벨에 단 하나만 존재하는 '공동의 변수'임을
  명확히 알게 되었다.

---

## 정리 🖇️

### 1. 다형성 (Polymorphism)

하나의 객체가 여러 타입을 가질 수 있는 성질. 즉, 부모 타입의 참조 변수가 다양한 자식 타입의 객체를 가리킬 수 있는 능력을 학습했다.

* **학습 목표 (Why?)**:
  코드를 특정 자식 클래스에 종속되지 않고, 더 일반적인 부모 타입(역할)에 의존하게 만들어 유연하고 확장 가능한 프로그램을 설계하기 위함이다.

* **핵심 원리 (What?)**:
    * **업캐스팅 (Upcasting)**: 자식 클래스의 객체를 부모 클래스 타입의 변수에 할당하는 것. 이는 **자동으로** 이루어지며, 자식 객체는 부모 타입으로 취급된다.
      ```java
      // Developer 객체는 Employee 타입으로 자동 업캐스팅됨
      Employee emp1 = new Developer();
      ```
    * **다형성의 활용**:
      | 활용 형태 | 설명 |
      | :--- | :--- |
      | **다형적 매개변수**| 메서드가 부모 타입을 매개변수로 받으면, 모든 종류의 자식 객체를 인자로 전달할 수 있어 재사용성이 높아짐. |
      | **다형적 배열** | 부모 타입 배열에 다양한 종류의 자식 객체들을 함께 저장하고 일관된 방식으로 관리할 수 있음. |
      | **다형적 반환 타입**| 메서드가 부모 타입을 반환 타입으로 가지면, 조건에 따라 다양한 종류의 자식 객체를 생성하여 반환할 수 있음. |

* **문법 및 사용법 (How?)**:
  ```java
  // Employee: 부모 클래스, Developer/Designer: 자식 클래스
  public class Manager {
      // 매개변수 employee는 Developer 객체든, Designer 객체든 모두 받을 수 있다.
      public void assignTask(Employee employee) {
          System.out.println("업무를 지시합니다.");
          employee.work(); // 실제 실행되는 work()는 emp1의 실제 객체 타입인 Developer의 메서드
      }
  }

  // 다형적 배열 활용
  Employee[] team = {new Developer(), new Designer(), new Developer()};
  for (Employee member : team) {
      member.work(); // 각 member의 실제 타입에 맞는 work()가 실행됨
  }
  ```

---

### 2. `instanceof`와 다운캐스팅 (Downcasting)

다형적으로 관리되는 객체의 원래 타입을 확인하고, 해당 타입의 고유한 멤버에 접근하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  부모 타입 변수에서는 보이지 않는 자식 클래스 고유의 필드나 메서드를, 런타임 에러 없이 안전하게 사용하기 위함이다.

* **핵심 원리 (What?)**:
    * **`instanceof`**: `참조변수 instanceof 클래스타입` 형태로 사용. 참조 변수가 가리키는 실제 객체가 해당 클래스 타입으로 형 변환이 가능한지 여부를 `true`/`false`로
      확인한다.
    * **다운캐스팅 (Downcasting)**: `instanceof`로 타입이 확인된 부모 타입의 참조 변수를, `(자식클래스타입)` 구문을 사용하여 자식 타입으로 강제 형 변환한다. 업캐스팅과 달리 *
      *자동으로 이루어지지 않는다.**

* **문법 및 사용법 (How?)**:
  ```java
  public void assignSpecialTask(Employee employee) {
      // 1. instanceof로 실제 객체의 타입을 안전하게 확인
      if (employee instanceof Developer) {
          // 2. 확인 후, Developer 타입으로 강제 형 변환 (다운캐스팅)
          Developer dev = (Developer) employee;
          dev.developCode(); // Developer 클래스 고유의 메서드 호출
      } else if (employee instanceof Designer) {
          Designer designer = (Designer) employee;
          designer.designUI(); // Designer 클래스 고유의 메서드 호출
      }
  }
  ```

---

### 3. `static` 키워드: 클래스의 공동 자산

객체를 생성하지 않고도 접근할 수 있는, 클래스 자체에 소속된 멤버(필드, 메서드)를 선언하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  모든 객체가 공유해야 하는 공통의 값(e.g., 상수 `PI`, 애플리케이션 버전)을 관리하거나, 특정 객체의 상태와 무관하게 독립적으로 수행될 수 있는 기능(e.g., 계산 유틸리티)을 제공하기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 인스턴스 멤버 (non-static) | 정적 멤버 (static) |
  | :--- | :--- | :--- |
  | **소속** | **객체(인스턴스)**에 소속. | **클래스**에 소속. |
  | **메모리** | `new`로 객체를 생성할 때마다 힙(Heap)에 **개별적으로** 생성. | 프로그램 시작 시 클래스가 로드될 때 메서드 영역에 **단 하나만** 생성. |
  | **접근 방법**| `객체참조변수.멤버이름` | `클래스이름.멤버이름` (객체 생성 없이 접근 가능) |
  | **특징** | 각 객체마다 다른 값을 가질 수 있음. `this` 사용 가능. | 모든 객체가 **공유**하는 하나의 값을 가짐. `static` 메서드 내에서 `this` 사용 불가. |

* **문법 및 사용법 (How?)**:
  ```java
  public class AppConfig {
      // 인스턴스 필드: 객체마다 다른 값을 가짐
      String themeColor;
      // static 필드: 모든 AppConfig 객체가 공유하는 하나의 값
      public static double VERSION = 1.0;

      // static 메서드: 객체 생성 없이 호출 가능
      public static void printVersion() {
          System.out.println("App Version: " + VERSION);
          // this.themeColor = "blue"; // 에러! static 메서드에서는 인스턴스 멤버(this) 접근 불가
      }
  }

  // static 멤버 사용
  AppConfig.printVersion(); // App Version: 1.0

  // static 필드 값 변경
  AppConfig.VERSION = 1.1;

  AppConfig config1 = new AppConfig();
  AppConfig config2 = new AppConfig();

  System.out.println(config1.VERSION); // 1.1 (권장되지 않는 방식)
  System.out.println(config2.VERSION); // 1.1 (공유된 값이므로 동일)
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **유틸리티 클래스**: `Math` 클래스나 `InputUtils`처럼, 특정 객체의 상태와 무관하게 기능만 제공하는 클래스는 모든 멤버를 `static`으로, 생성자는 `private`으로 만들어 객체
      생성을 막는 것이 정석적인 설계 방법이다.

---

## 오늘의 깨달음 💡

* 다형성은 코드를 '역할'에 집중하게 만든다. `Manager`는 상대방의 구체적인 직업(`Developer`, `Designer`)이 무엇이든 상관없이, `Employee`라는 공통된 역할에 맞게 `work()`
  라는 일을 시키면 된다. 이는 코드를 특정 구현에 얽매이지 않고 유연하게 만든다.

* 업캐스팅은 편리하지만 기능의 **'제한'**을 가져오고, 다운캐스팅은 기능의 **'확장'**을 가져오지만 **'위험'**을 동반한다. `instanceof`는 그 위험을 막아주는 필수적인 안전장치였다.

* `static`은 "이것은 특정 객체의 소유물이 아니라, 클래스 전체의 공동 자산입니다"라고 선언하는 것과 같았다. 모든 객체가 하나의 변수를 공유한다는 개념은 애플리케이션 전역에서 사용될 설정값이나 상수를
  관리하는 데 매우 강력한 도구임을 알게 되었다.

* `static` 메서드는 '객체 없이도 존재하는 독립적인 기능'이고, 인스턴스 메서드는 '객체가 있어야만 의미를 갖는 기능'이라는 차이가 명확해졌다. `Math.max(a, b)`는 두 숫자만 있으면 계산할 수
  있지만, `myCar.accelerate()`는 `myCar`라는 실체가 없으면 가속할 수 없는 것과 같다.

* 좋은 코드는 '어떤 일이 벌어질지 예측 가능'해야 한다. 다형성은 객체의 실제 타입에 따라 동작이 달라지는 것을 '예측 가능'하게 만들고, `static`은 여러 객체에 걸쳐 공유되는 상태를 '예측 가능'하게
  만든다. 이러한 개념들은 결국 안정적인 소프트웨어를 만드는 규칙과 구조를 제공한다.