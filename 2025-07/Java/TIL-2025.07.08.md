# TIL - 2025.07.08 - Java 파일 I/O, 내부 클래스, 람다 및 스트림 API 기초 개념 이해

## 카테고리 🏷️

#TIL #Java #IO #InnerClass #Lambda #FunctionalInterface #StreamAPI

---

## 오늘 배운 내용 🔍

- `try-with-resources`를 이용한 안전한 파일 입출력(I/O) 스트림 관리
- 내부 클래스(Inner Class)와 일회성 객체 생성을 위한 익명 클래스(Anonymous Class)
- 함수형 프로그래밍의 시작, 람다 표현식(Lambda Expression)과 함수형 인터페이스
- 메서드에 데이터가 아닌 '동작(코드)'을 전달하는 동작 파라미터화(Behavior Parameterization) 패턴
- 데이터 컬렉션을 선언적으로 처리하는 스트림(Stream) API의 `filter`와 `map`
- 람다식을 더 간결하게 표현하는 메서드 참조(Method Reference)와 생성자 참조

---

## 어려웠던 점 💣

* **다양한 I/O 스트림의 용도 구분**: `InputStream`, `OutputStream`, `Reader`, `Writer` 등 종류가 많아 언제 어떤 것을 써야 할지 혼란스러웠다. 이진 데이터(이미지,
  실행 파일 등)는 **Byte 스트림**(`~Stream`), 텍스트 데이터(문자)는 **Character 스트림**(`~Reader`, `~Writer`)을 사용한다는 기본 원칙을 세우는 것이 중요했다.

* **익명 클래스의 낯선 문법**: `new Interface() { ... }` 구문이 인터페이스로부터 직접 객체를 생성하는 것처럼 보여 낯설었다. 실제로는 이름 없는 1회용 클래스를 그 자리에서 즉석으로
  정의하고, 그 클래스의 객체를 생성하는 것이라는 내부 동작을 이해해야 했다.

* **람다식의 사용 조건**: 람다 표현식이 왜 추상 메서드가 단 하나인 **함수형 인터페이스(`@FunctionalInterface`)**에만 사용 가능한지 궁금했다. 이는 컴파일러가 람다 바디(
  `-> { ... }`)를 여러 개의 추상 메서드 중 어떤 것의 구현체로 매핑해야 할지 알 수 없기 때문이라는 것을 깨달았다.

* **'동작 파라미터화'라는 패러다임의 전환**: 메서드에 데이터가 아닌 '코드(동작)' 자체를 인자로 전달한다는 개념이 가장 어려웠다. `filter(data, predicate)`처럼 필터링 '조건(
  predicate)'을 외부에서 주입받는 방식이, `if`문으로 조건을 하드코딩하는 것보다 왜 더 유연하고 재사용성이 높은 설계인지 고민하는 데 시간이 걸렸다.

* **메서드 참조(`::`)의 정체**: `User::getName`과 같은 메서드 참조 문법이 처음에는 암호처럼 보였다. 하지만 이는 `user -> user.getName()`처럼 단순히 객체를 받아 그 객체의
  메서드를 호출하는 단순한 람다 표현식을 더 간결하게 줄여 쓰는 '문법 설탕(Syntactic Sugar)'이라는 것을 알고 나니 편리하게 느껴졌다.

---

## 정리 🖇️

### 1. 파일 입출력(I/O)과 `try-with-resources`

프로그램이 외부 파일과 데이터를 주고받는 방법과, 사용한 자원을 안전하게 관리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  프로그램의 상태(객체, 데이터)를 파일에 저장하여 영속성을 부여하고, `close()` 메서드 호출 누락으로 인한 잠재적인 메모리 누수나 시스템 자원 문제를 방지하기 위함이다.

* **핵심 원리 (What?)**:
    * **스트림(Stream)**: 데이터가 흐르는 단방향 통로. 바이트 단위로 처리하는 **Byte 스트림**과 문자 단위로 처리하는 **Character 스트림**으로 나뉜다.
    * **`try-with-resources`**: `try`문의 소괄호 안에 `AutoCloseable` 인터페이스를 구현한 자원 객체(e.g., `FileWriter`, `FileInputStream`)를
      선언하면, `try` 블록이 종료될 때 JVM이 자동으로 해당 자원의 `close()` 메서드를 호출해준다.

* **문법 및 사용법 (How?)**:
  ```java
  // 텍스트 파일 쓰기 (Character 스트림)
  try (FileWriter writer = new FileWriter("log.txt")) {
      writer.write("Application log message.");
  } catch (IOException e) {
      e.printStackTrace();
  }

  // 객체 리스트 파일에 저장 (Byte 스트림 + 보조 스트림)
  // Product 클래스는 Serializable 인터페이스를 구현해야 함
  List<Product> products = List.of(new Product("A001"), new Product("B002"));
  try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("products.sav"))) {
      oos.writeObject(products);
  } catch (IOException e) {
      e.printStackTrace();
  }
  ```

---

### 2. 람다 표현식(Lambda Expression)과 함수형 인터페이스

익명 클래스의 번거로운 문법을 간결하게 표현하여, 코드를 함수 중심으로 작성할 수 있게 하는 Java 8의 핵심 기능을 학습했다.

* **학습 목표 (Why?)**:
  메서드를 마치 데이터 값처럼 다루어(동작 파라미터화), 더 유연하고 표현력 높은 코드를 작성하기 위함이다. 이는 스트림 API와 같은 현대적인 자바 기능의 기반이 된다.

* **핵심 원리 (What?)**:
    * **함수형 인터페이스 (`@FunctionalInterface`)**: **단 하나의 추상 메서드**만을 가진 인터페이스. 람다 표현식은 이 하나의 추상 메서드를 구현하는 축약형 문법이다.
    * **람다 표현식**: `(매개변수) -> { 실행문 }` 형태로, 이름 없는 함수(메서드)를 정의한다.
    * **익명 클래스 vs. 람다**:
        * 익명 클래스는 인터페이스를 구현하는 '이름 없는 객체'를 만드는 것이고, 람다는 '이름 없는 함수'를 만드는 것이다. 람다가 훨씬 더 가볍고 간결하다.

* **문법 및 사용법 (How?)**:
  ```java
  // 전통적인 익명 클래스 방식
  button.addActionListener(new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
          System.out.println("버튼 클릭!");
      }
  });

  // 람다 표현식 방식
  button.addActionListener(e -> System.out.println("버튼 클릭!"));

  // Runnable 인터페이스 (run() 메서드 하나만 가짐)
  Runnable task = () -> System.out.println("새로운 스레드에서 작업 실행");
  new Thread(task).start();
  ```

---

### 3. 동작 파라미터화와 스트림 API 기초

메서드의 동작 일부를 외부에서 주입받는 '동작 파라미터화' 패턴과, 이를 적극적으로 활용하는 스트림 API의 기본을 학습했다.

* **학습 목표 (Why?)**:
  데이터를 필터링하거나 변환하는 로직을 매번 새로 작성하는 대신, 재사용 가능한 `filter`, `map`과 같은 고차 함수를 만들고, 여기에 다양한 '조건'이나 '변환 로직'(동작)을 람다식으로 전달하여 코드
  중복을 최소화하고 유연성을 극대화하기 위함이다.

* **핵심 원리 (What?)**:
    * **`filter(Predicate<T>)`**: `Predicate`는 `boolean`을 반환하는 함수형 인터페이스. `filter`는 이 `Predicate`를 인자로 받아, 각 요소에 적용하여
      `true`를 반환하는 요소만으로 구성된 새로운 스트림을 만든다.
    * **`map(Function<T, R>)`**: `Function`은 입력(`T`)을 받아 출력(`R`)을 반환하는 함수형 인터페이스. `map`은 이 `Function`을 인자로 받아, 각 요소를 새로운
      형태의 값으로 변환한 결과로 구성된 새로운 스트림을 만든다.

* **문법 및 사용법 (How?)**:
  ```java
  // 동작 파라미터화 직접 구현 예시
  // Predicate<T>는 T를 받아 boolean을 반환하는 test() 메서드를 가진 함수형 인터페이스
  public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
      List<T> result = new ArrayList<>();
      for (T item : list) {
          if (predicate.test(item)) { // 외부에서 주입된 조건(동작)을 실행
              result.add(item);
          }
      }
      return result;
  }

  // 사용
  List<Integer> numbers = List.of(1, 2, 3, 4, 5);
  // 동작(n -> n % 2 == 0)을 filter 메서드에 전달
  List<Integer> evens = filter(numbers, n -> n % 2 == 0);


  // Stream API 활용
  List<User> users = List.of(new User("Alice", 30), new User("Bob", 25));

  List<String> userNames = users.stream() // 1. 스트림 생성
                                .filter(user -> user.getAge() >= 30) // 2. 필터링
                                .map(user -> user.getName()) // 3. 매핑 (User -> String)
                                .collect(Collectors.toList()); // 4. 결과 수집
  ```

---

### 4. 메서드 참조 (Method Reference)

람다 표현식을 더욱 간결하게 작성할 수 있는 문법을 학습했다.

* **학습 목표 (Why?)**:
  단순히 객체의 메서드를 호출하거나, 생성자를 호출하는 람다식을 더 짧고 명확하게 표현하여 코드의 가독성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  람다 바디가 단 하나의 메서드 호출로만 이루어진 경우, `::` 연산자를 사용하여 축약할 수 있다.
  | 람다 표현식 | 메서드 참조 |
  | :--- | :--- |
  | `user -> user.getName()` | `User::getName` |
  | `str -> System.out.println(str)` | `System.out::println` |
  | `() -> new ArrayList<>()` | `ArrayList::new` |

---

## 오늘의 깨달음 💡

* **'동작 파라미터화'는 하드코딩된 로직을 유연한 '부품'으로 만드는 핵심 열쇠였다.** `if (n % 2 == 0)`과 같은 특정 조건을 코드 안에 고정하는 대신, `n -> n % 2 == 0`이라는 '
  동작' 자체를 인자로 넘김으로써, `filter`라는 하나의 메서드가 '짝수 필터링', '5보다 큰 수 필터링' 등 무한히 많은 역할을 수행할 수 있게 되었다.

* **람다는 '일회용 메서드'를 만드는 것과 같았다.** 과거 익명 클래스가 '일회용 객체'를 만드는 번거로운 방식이었다면, 람다는 그보다 훨씬 더 가볍게 오직 '기능' 그 자체에만 집중할 수 있게 해준다.

* **`try-with-resources`는 개발자의 실수를 줄여주는 최고의 안전장치다.** 파일이나 네트워크 연결과 같은 외부 자원은 사용 후 반드시 `close()`를 호출해야 하는데, 이를 잊기 쉽다.
  `try-with-resources`는 이 과정을 자동화하여 코드를 더 안전하고 간결하게 만들어준다.

* **스트림 API는 데이터 처리의 '파이프라인'을 구축하는 것과 같았다.** 원본 데이터가 `stream()`을 통해 파이프라인에 들어가면, `filter`, `map`과 같은 여러 처리 단계를 거쳐 최종
  결과물로 `collect`된다. 이는 `for`문을 사용한 명령형 코드보다 "무엇을 할 것인지"에 대한 의도를 훨씬 명확하게 보여주는 선언적인 방식이다.

* 현대 자바는 과거의 명령형 스타일에서 벗어나, 람다와 스트림을 통해 **함수형 프로그래밍의 장점을 적극적으로 수용**하고 있음을 느꼈다. 이는 코드를 더 간결하고, 표현력 있으며, 병렬 처리에도 유리하게 만드는
  중요한 패러다임의 변화다.