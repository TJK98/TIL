# TIL - 2025.07.29 - Spring Data JPA 연관 관계 매핑과 성능 최적화 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #RelationshipMapping #NPlusOne #FetchJoin #JPQL

---

## 오늘 배운 내용 🔍

- JPA 엔티티 간의 1:N 연관 관계 설정 (`@ManyToOne`, `@OneToMany`)
- 단방향 매핑과 양방향 매핑의 차이, 그리고 연관 관계의 주인(`mappedBy`) 개념
- 지연 로딩(`LAZY`)과 즉시 로딩(`EAGER`) 전략, 그리고 N+1 문제의 발생 원인
- N+1 문제 해결을 위한 Fetch Join의 개념과 `@Query`를 이용한 JPQL 작성법
- Query Method의 한계를 넘어 복잡한 쿼리를 작성하는 `@Query` 애너테이션
- 양방향 관계에서 데이터 정합성을 유지하기 위한 연관 관계 편의 메서드의 필요성

---

## 어려웠던 점 💣

* **`toString()` 호출 시 `StackOverflowError` 발생**: 양방향 관계가 설정된 `Team`과 `Member` 객체를 `toString()`으로 출력하려다 무한 루프에 빠져 에러가
  발생했다. `Team`은 `Member` 목록을, 각 `Member`는 다시 `Team`을 출력하면서 순환 참조가 일어나는 것이 원인이었다. `@ToString(exclude = "...")` 애너테이션으로 연관
  관계 필드를 출력에서 제외해야만 문제를 해결할 수 있었다.

* **영속성 컨텍스트와 DB 상태 불일치**: 테스트 코드에서 특정 멤버의 팀을 A에서 B로 변경(`member.setTeam(teamB)`)했는데, 나중에 A팀의 멤버 목록을 조회하니 여전히 그 멤버가 남아있는
  현상을 마주했다. 이는 연관 관계의 주인인 `member` 객체의 참조만 변경했을 뿐, 반대쪽인 A팀 객체의 `members` 컬렉션에서는 제거하지 않아 영속성 컨텍스트(1차 캐시) 상에서 데이터 불일치가
  발생했기 때문이었다.

* **N+1 문제의 동작 원리**: 모든 팀 목록을 조회하는 쿼리(1)는 한 번만 실행되었으나, 각 팀의 멤버를 화면에 보여주려고 할 때 팀의 수(N)만큼 추가 쿼리가 발생하는 현상을 확인했다. 지연 로딩(
  `LAZY`)은 연관 엔티티를 실제로 사용하는 시점에 쿼리를 실행하는 전략이므로, 반복문 내에서 연관 엔티티를 조회하면 이러한 성능 문제가 발생한다는 것을 알게 되었다.

* **JPQL의 대상**: `@Query` 애너테이션 안에서 쿼리를 작성할 때 `FROM tbl_student`가 아닌 `FROM Student s`라고 쓰는 것이 낯설었다. 이는 JPQL이 데이터베이스 테이블이
  아닌, JPA가 관리하는 엔티티 객체를 대상으로 하는 객체지향 쿼리 언어이기 때문이었다.

---

## 정리 🖇️

### 1. JPA 연관 관계 매핑 (1:N 관계)

데이터베이스의 외래 키 관계를 객체지향적으로 표현하기 위해 엔티티 간의 관계를 설정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  테이블 중심의 데이터 모델링과 객체 중심의 애플리케이션 모델링 사이의 패러다임 불일치를 해결하고, 객체 그래프 탐색을 통해 연관된 데이터를 SQL JOIN 없이도 쉽게 조회하기 위함이다.

* **핵심 원리 (What?)**:
    * `@ManyToOne`: 다(N) 쪽 엔티티에서 일(1) 쪽 엔티티를 참조할 때 사용. (e.g., `Member` -> `Team`)
    * `@OneToMany`: 일(1) 쪽 엔티티에서 다(N) 쪽 엔티티의 컬렉션을 참조할 때 사용. (e.g., `Team` -> `List<Member>`)
    * `@JoinColumn(name = "fk_name")`: 외래 키를 매핑할 때 사용. **연관 관계의 주인**이 되는 N쪽 엔티티에 선언하여 실제 DB에 생성될 FK 컬럼의 이름을 지정한다.

* **문법 및 사용법 (How?)**: 하나의 `Team`에 여러 `Member`가 소속되는 1:N 관계 예시.
  ```java
  // N 쪽 (연관 관계의 주인): Member.java
  @Entity
  public class Member {
      @Id @GeneratedValue
      private Long id;
      
      @ManyToOne(fetch = FetchType.LAZY) // N:1 관계, 지연 로딩 전략
      @JoinColumn(name = "team_id") // DB에 생성될 FK 컬럼명
      private Team team;
  }

  // 1 쪽 (주인이 아님): Team.java
  @Entity
  public class Team {
      @Id @GeneratedValue
      private Long id;
      
      // mappedBy: "나는 주인이 아니며, Member 엔티티의 'team' 필드에 의해 매핑되었다"
      @OneToMany(mappedBy = "team")
      private List<Member> members = new ArrayList<>();
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **연관 관계의 주인(Owner)**: 양방향 관계에서는 외래 키를 관리할 권한을 가진 쪽을 정해야 한다. **외래 키가 있는 엔티티가 항상 주인**이 되며, 주인이 아닌 쪽에는 `mappedBy` 속성을
      사용하여 주인의 필드명을 명시해야 한다.
    * **연관 관계 편의 메서드**: 양방향 관계에서 한쪽의 참조만 변경하면 데이터 불일치가 발생할 수 있다. 이를 방지하기 위해, 양쪽 객체의 참조를 한 번에 설정해주는 편의 메서드를 연관 관계의 주인 쪽에
      만드는 것이 좋다.
      ```java
      // Member.java (주인)
      public void changeTeam(Team team) {
          this.team = team;
          team.getMembers().add(this); // 상대방의 컬렉션에도 자신을 추가
      }
      ```

---

### 2. 지연 로딩(LAZY), N+1 문제, 그리고 Fetch Join

연관된 엔티티를 조회하는 시점을 제어하고, 이로 인해 발생하는 성능 문제를 해결하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  불필요한 DB 조회를 최소화하여 애플리케이션의 성능을 최적화하기 위함이다. 특히, 반복문 안에서 연관 엔티티를 조회할 때 발생하는 N+1 쿼리 문제를 해결하는 것은 매우 중요하다.

* **핵심 원리 (What?)**:
    * **지연 로딩 (Lazy Loading)**: 연관된 엔티티를 실제로 사용하는 시점 (`team.getMembers()`)에 비로소 DB에서 조회하는 방식.
    * **즉시 로딩 (Eager Loading)**: 주 엔티티를 조회할 때 연관된 엔티티까지 JOIN을 통해 함께 조회하는 방식.
    * **N+1 문제**: 1개의 쿼리로 주 엔티티 목록을 가져온 뒤(1), 그 목록을 순회하며 각 엔티티의 연관 엔티티를 조회하기 위해 N개의 추가 쿼리가 발생하는 성능 저하 현상. 주로 지연 로딩 상태에서
      발생한다.
    * **Fetch Join**: JPQL의 `JOIN FETCH` 구문을 사용하여, N+1 문제없이 연관된 엔티티를 하나의 쿼리로 즉시 로딩하는 방법. SQL의 JOIN과 유사하지만, SELECT 절에 조회할
      엔티티를 명시적으로 포함시키는 것이 특징이다.

* **문법 및 사용법 (How?)**: `Team`을 조회하면서 소속된 `Member`들을 N+1 문제없이 함께 가져오기.
  ```java
  // TeamRepository.java
  public interface TeamRepository extends JpaRepository<Team, Long> {
      
      // JPQL을 사용하여 Fetch Join 정의
      @Query("SELECT DISTINCT t FROM Team t JOIN FETCH t.members")
      List<Team> findAllWithMembers();
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 모든 연관 관계는 **일단 지연 로딩(`LAZY`)으로 설정**하는 것이 기본 원칙이다. `@ManyToOne`의 기본값은 `EAGER`이므로 반드시 `LAZY`로 변경해야 한다.
    * N+1 문제가 발생하는 특정 조회 기능에 한해서만 **Fetch Join을 사용하여 최적화**하는 것이 좋다.
    * `...ToMany` 관계를 Fetch Join하면 데이터 뻥튀기(Cartesian Product)가 발생할 수 있으므로, JPQL에 `DISTINCT`를 추가하여 중복을 제거해야 한다.

---

### 3. @Query를 이용한 직접 쿼리 작성

Spring Data JPA의 Query Method만으로 표현하기 어려운 복잡한 쿼리를 JPQL이나 Native SQL로 직접 작성하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순 조회를 넘어, 통계, 그룹화, 서브쿼리 등 복잡한 비즈니스 요구사항을 만족시키는 동적이고 세밀한 쿼리를 Repository 인터페이스에 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **JPQL (Java Persistence Query Language)**: SQL과 유사하지만, 데이터베이스 테이블이 아닌 **엔티티 객체와 그 필드를 대상**으로 하는 객체지향 쿼리 언어. 특정
      DB에 종속되지 않는다.
    * **Native SQL**: 특정 데이터베이스의 고유한 SQL 문법을 그대로 사용하는 방식. `nativeQuery = true` 속성을 사용하며, DB에 특화된 함수나 기능을 사용할 때 유용하다.
    * **파라미터 바인딩**: `:paramName`과 `@Param("paramName")`을 사용하여 이름 기반으로 바인딩할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  public interface MemberRepository extends JpaRepository<Member, Long> {
  
      // JPQL 사용 예시: 특정 팀에 소속된 멤버 조회
      // Member는 클래스명, m은 별칭, m.team은 필드명, :teamId는 파라미터명
      @Query("SELECT m FROM Member m WHERE m.team.id = :teamId")
      List<Member> findMembersByTeamId(@Param("teamId") Long id);
      
      // Native SQL 사용 예시: 특정 이름을 가진 멤버 조회
      // tbl_member는 테이블명, member_name은 컬럼명
      @Query(value = "SELECT * FROM tbl_member WHERE member_name = ?1", nativeQuery = true)
      List<Member> findMembersByNameNative(String name);
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@Query`에 작성된 쿼리 문자열의 문법 오류는 애플리케이션 실행 전까지 발견하기 어렵다.
    * 가급적 DB에 비종속적인 JPQL을 우선적으로 사용하고, Native SQL은 최후의 수단으로 사용하는 것이 좋다.

---

## 오늘의 깨달음 💡

* JPA 연관 관계 매핑을 통해, 복잡한 JOIN 쿼리 없이도 `member.getTeam().getName()`처럼 객체의 참조를 따라 원하는 데이터로 쉽게 이동할 수 있었다.

* 양방향 관계에서 `mappedBy` 속성은 데이터베이스 외래 키를 관리할 책임이 어느 쪽에 있는지 JPA에게 알려주는 중요한 설정이다.

* 모든 연관 관계를 지연 로딩(`LAZY`)으로 설정하는 것이 성능상 기본 원칙이다. 즉시 로딩(`EAGER`)은 N+1 문제와 같은 예상치 못한 성능 문제를 유발할 가능성이 크다.

* N+1 문제는 지연 로딩 사용 시 발생할 수 있는 대표적인 성능 함정이며, Fetch Join은 이를 해결하기 위한 가장 효과적인 방법 중 하나다.

* JPQL은 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 하는 객체지향 쿼리 언어라는 점을 명확히 인지해야 한다.