# TIL - 2025.07.14 - Spring MVC 요청 매핑과 응답 처리 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringMVC #RequestMapping #PathVariable #RequestParam #RestController

---

## 오늘 배운 내용 🔍

- `@RequestMapping`을 이용한 URL 요청과 컨트롤러 메서드 매핑
- URL 경로의 일부를 변수로 사용하는 `@PathVariable`
- 쿼리 문자열 파라미터를 추출하는 `@RequestParam`
- HTTP 메서드별 요청 처리를 위한 `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`
- 메모리 저장소(`Map`)를 이용한 간단한 CRUD API 구현
- `@ResponseBody`와 Jackson 라이브러리를 통한 JSON 응답 처리 원리

---

## 어려웠던 점 💣

* **`@PathVariable`과 `@RequestParam`의 혼동**: `/products/1`과 `/products?id=1`의 차이가 모호했다. `@PathVariable`은 `/products/1`처럼
  경로의 일부로서 **특정 리소스를 고유하게 식별**하는 데 사용되고, `@RequestParam`은 `/products?category=books`처럼 정렬, 필터링 등 **부가적인 옵션을 전달**하는 데
  사용된다는 개념적 차이를 구분해야 했다.

* **Java 객체의 JSON 자동 변환 원리**: `@RestController`가 붙은 컨트롤러에서 `Product` 객체를 반환했을 뿐인데, 브라우저에는 완벽한 JSON 형식으로 출력되는 내부 동작 원리가
  궁금했다. 이는 Spring Boot에 내장된 **Jackson 라이브러리**가 자바 객체를 JSON 문자열로 자동으로 변환(직렬화)해주기 때문이라는 것을 알게 되었다.

* **`@Controller`와 `@RestController`의 차이**: 두 애너테이션의 차이가 `@ResponseBody` 유무라고만 생각했는데, 이로 인해 반환 값의 처리 방식이 완전히 달라졌다.
  `@Controller`에서 `String`을 반환하면 `ViewResolver`가 뷰 파일을 찾으려 하고, `@RestController`에서 `String`을 반환하면 순수한 텍스트 데이터로 응답한다는
  근본적인 차이를 깨달았다.

---

## 정리 🖇️

### 1. URL 요청과 데이터 매핑

클라이언트의 HTTP 요청 URL을 어떤 컨트롤러 메서드가 처리할지 지정하고, URL에 포함된 동적인 값을 추출하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순히 정적인 URL만 처리하는 것을 넘어, `/products/123`이나 `/search?keyword=java`처럼 동적인 값을 포함하는 유연한 URL 구조를 설계하고, 그 값들을 컨트롤러 메서드의
  파라미터로 손쉽게 받아 처리하기 위함이다.

* **핵심 원리 (What?)**:
  | 애너테이션 | 사용 목적 | URL 예시 |
  | :--- | :--- | :--- |
  | **`@RequestMapping`** | URL 경로를 컨트롤러 클래스나 메서드에 매핑하는 가장 기본적인 애너테이션. | `@RequestMapping("/products")` |
  | **`@PathVariable`** | URL 경로 자체에 포함된 값을 변수로 추출. **리소스 식별**에 주로 사용. | `/products/{productId}` → `productId` 변수에 값
  할당 |
  | **`@RequestParam`** | 쿼리 문자열(`?` 뒤)의 파라미터 값을 추출. **정렬, 필터링, 검색** 등 옵션 전달에 사용. | `/products?category=books` →
  `category` 변수에 'books' 할당 |

* **문법 및 사용법 (How?)**:
  ```java
  @RestController
  @RequestMapping("/api/v1/users") // 클래스 레벨에서 공통 경로 설정
  public class UserController {

      // 경로 변수(@PathVariable) 사용
      // 요청 URL: /api/v1/users/101
      @GetMapping("/{userId}")
      public User findUserById(@PathVariable long userId) {
          // userId 변수에는 101이 담김
          return userService.findOne(userId);
      }

      // 쿼리 파라미터(@RequestParam) 사용
      // 요청 URL: /api/v1/users?role=ADMIN&page=1
      @GetMapping
      public List<User> findUsersByRole(
              @RequestParam String role,
              @RequestParam(defaultValue = "1") int page) { // page 파라미터가 없으면 기본값 1 사용
          // role 변수에는 "ADMIN", page 변수에는 1이 담김
          return userService.findByRole(role, page);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@RequestParam`은 기본적으로 필수(`required=true`)다. 해당 파라미터가 요청 URL에 없으면 에러가 발생하므로, 선택적으로 받고 싶다면 `required=false` 속성을
      추가해야 한다.
    * `@PathVariable`의 변수명(`{userId}`)과 메서드 파라미터명(`long userId`)이 같으면, 애너테이션에서 값(`("userId")`)을 생략할 수 있어 코드가 간결해진다.

---

### 2. HTTP 메서드 기반 CRUD API 구현

각기 다른 HTTP 메서드(`GET`, `POST`, `PUT`, `DELETE`)의 목적에 맞게 CRUD(Create, Read, Update, Delete) 기능을 구현하고, RESTful API의 기본을
학습했다.

* **학습 목표 (Why?)**:
  리소스(데이터)에 대한 행위(조회, 생성, 수정, 삭제)를 HTTP 메서드로 명확하게 표현하여, 예측 가능하고 일관된 API를 설계하는 방법을 익히기 위함이다.

* **핵심 원리 (What?)**:
  `@RequestMapping`을 더 구체화한 단축 애너테이션을 사용한다.
  | 애너테이션 | HTTP 메서드 | CRUD 역할 |
  | :--- | :--- | :--- |
  | `@GetMapping` | `GET` | 리소스 **조회 (Read)** |
  | `@PostMapping`| `POST` | 리소스 **생성 (Create)** |
  | `@PutMapping` | `PUT` | 리소스 **전체 수정 (Update)** |
  | `@DeleteMapping`| `DELETE` | 리소스 **삭제 (Delete)** |

* **문법 및 사용법 (How?)**: `Product` 객체를 관리하는 REST API 컨트롤러 예시
  ```java
  @RestController
  @RequestMapping("/api/v2/products")
  public class ProductController {
      private final Map<Long, Product> productStore = new HashMap<>();
      private long nextId = 1L;

      // 전체 상품 목록 조회 (GET /api/v2/products)
      @GetMapping
      public List<Product> listProducts() { /* ... */ }

      // 특정 상품 상세 조회 (GET /api/v2/products/{id})
      @GetMapping("/{id}")
      public Product getProduct(@PathVariable Long id) { /* ... */ }

      // 새 상품 등록 (POST /api/v2/products)
      @PostMapping
      public Product createProduct(@RequestBody Product newProduct) {
           newProduct.setId(nextId++);
           productStore.put(newProduct.getId(), newProduct);
           return newProduct;
      }
      
      // 상품 정보 수정 (PUT /api/v2/products/{id})
      @PutMapping("/{id}")
      public Product updateProduct(@PathVariable Long id, @RequestBody Product updatedProduct) { /* ... */ }
      
      // 상품 삭제 (DELETE /api/v2/products/{id})
      @DeleteMapping("/{id}")
      public void deleteProduct(@PathVariable Long id) { /* ... */ }
  }
  ```

---

### 3. 다양한 형식의 응답 데이터 처리

서버가 처리 결과를 클라이언트에게 어떤 형식으로 전달할지 결정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  클라이언트의 요구에 맞춰 HTML 뷰(View)를 렌더링하거나, 순수 데이터(JSON, Text 등)를 직접 응답하는 등 다양한 응답 방식을 자유자재로 구현하기 위함이다.

* **핵심 원리 (What?)**:
  컨트롤러에 붙는 애너테이션에 따라 반환 값의 처리 방식이 근본적으로 달라진다.
  | 애너테이션 | `String` 반환 시 동작 | 객체/리스트 반환 시 동작 |
  | :--- | :--- | :--- |
  | **`@Controller`** | **뷰(View) 이름**으로 해석. `ViewResolver`가 JSP 등을 찾아 렌더링. | (단독 사용 시) 오류 발생. `Model`에 담아서 뷰로 전달해야 함. |
  | **`@Controller` + `@ResponseBody`** | **순수 텍스트(Text)**로 응답 본문에 직접 작성. | **JSON**으로 자동 변환되어 응답 본문에 직접 작성. |
  | **`@RestController`** | **순수 텍스트(Text)**로 응답 본문에 직접 작성. | **JSON**으로 자동 변환되어 응답 본문에 직접 작성. |

* **문법 및 사용법 (How?)**:
  ```java
  @Controller // 뷰를 반환하는 컨트롤러
  public class PageController {
      @GetMapping("/home")
      public String homePage() {
          return "index"; // /WEB-INF/views/index.jsp 렌더링
      }
  }

  @RestController // 데이터만 반환하는 컨트롤러
  @RequestMapping("/api/users")
  public class UserApiController {
      // User 객체가 JSON으로 자동 변환되어 응답됨
      @GetMapping("/{id}")
      public User getUser(@PathVariable Long id) {
          return new User("Alice", 30);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@RestController`는 `@Controller`와 `@ResponseBody`를 합친 애너테이션이다. RESTful API처럼 데이터만 제공하는 컨트롤러를 만들 때는 클래스 레벨에
      `@RestController`를 사용하는 것이 훨씬 편리하다.
    * 반대로, JSP나 Thymeleaf 같은 템플릿 엔진을 사용하여 서버 사이드 렌더링을 할 때는 `@Controller`를 사용해야 한다.

---

## 오늘의 깨달음 💡

* `@GetMapping`, `@RequestParam` 등의 애너테이션은 과거의 복잡한 서블릿 설정을 대신하는 편리한 '약속'이다. 이 약속의 규칙과 의미를 정확히 이해하고 사용해야만 Spring의 자동화 이점을
  제대로 활용할 수 있다.

* RESTful API는 URL로 리소스를 표현하고, HTTP 메서드로 행위를 표현하는 원칙에 따라 설계된다. 이를 통해 일관되고 예측 가능한 API를 만들 수 있다.

* `@ResponseBody` 애너테이션은 서버가 뷰(View)를 렌더링하는 대신, 순수한 데이터를 HTTP 응답 본문에 직접 작성하도록 하는 역할을 한다.

* `@RestController`는 `@Controller`와 `@ResponseBody`를 합친 것으로, 데이터만 제공하는 API 서버를 만들 때 컨트롤러 클래스에 적용하면 편리하다.