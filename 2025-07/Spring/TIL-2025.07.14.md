# TIL - 2025.07.14 - Spring MVC 요청 매핑과 응답 처리 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringMVC #RequestMapping #PathVariable #RequestParam #RestController

---

## 오늘 배운 내용 🔍

- `@RequestMapping`을 이용한 URL 요청과 컨트롤러 메서드 매핑
- URL 경로의 일부를 변수로 사용하는 `@PathVariable`
- 쿼리 문자열 파라미터를 추출하는 `@RequestParam`
- HTTP 메서드별 요청 처리를 위한 `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`
- 메모리 저장소(`Map`)를 이용한 간단한 CRUD API 구현
- `@ResponseBody`와 Jackson 라이브러리를 통한 JSON 응답 처리 원리

---

## 어려웠던 점 💣

* **`@PathVariable`과 `@RequestParam`의 혼동**: `/products/1`과 `/products?id=1`의 차이가 모호했다. 둘 다 'ID가 1인 상품'을 가리키는 것 같았지만,
  `@PathVariable`은 `/products/1`처럼 경로의 일부로서 **특정 리소스를 고유하게 식별**하는 데 사용되고(RESTful), `@RequestParam`은
  `/products?category=books`처럼 정렬, 필터링 등 **부가적인 옵션을 전달**하는 데 사용된다는 개념적 차이를 구분해야 했다.

* **Java 객체의 JSON 자동 변환 원리**: `@RestController`가 붙은 컨트롤러에서 `Product` 객체를 반환했을 뿐인데, 브라우저에는 완벽한 JSON 형식으로 출력되는 것이 마법처럼
  느껴졌다. 이는 Spring Boot에 내장된 **Jackson 라이브-러리**가 마치 통역사처럼 자바 객체를 JSON 문자열로 자동으로 변환(직렬화, Serialization)해주기 때문이라는 내부 동작 원리를
  이해했다.

* **`@Controller`와 `@RestController`의 미묘한 차이**: 두 애너테이션이 단순히 `@ResponseBody` 유무의 차이라고만 생각했는데, 이로 인해 반환 값의 처리 방식이 완전히
  달라졌다. `@Controller`에서 `String`을 반환하면 `ViewResolver`가 JSP 같은 뷰 파일을 찾으려 하고, `@RestController`에서 `String`을 반환하면 그 자체가 순수한
  텍스트 데이터로 응답 본문에 담긴다는 근본적인 차이를 깨달았다.

---

## 정리 🖇️

### 1. URL 요청과 데이터 매핑

클라이언트의 HTTP 요청 URL을 어떤 컨트롤러 메서드가 처리할지 지정하고, URL에 포함된 동적인 값을 추출하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순히 정적인 URL만 처리하는 것을 넘어, `/products/123`이나 `/search?keyword=java`처럼 동적인 값을 포함하는 유연한 URL 구조를 설계하고, 그 값들을 컨트롤러 메서드의
  파라미터로 손쉽게 받아 처리하기 위함이다.

* **핵심 원리 (What?)**:
  | 애너테이션 | 사용 목적 | URL 예시 |
  | :--- | :--- | :--- |
  | **`@RequestMapping`** | URL 경로를 컨트롤러 클래스나 메서드에 매핑하는 가장 기본적인 애너테이션. | `@RequestMapping("/products")` |
  | **`@PathVariable`** | URL 경로 자체에 포함된 값을 변수로 추출. **리소스 식별**에 주로 사용. | `/products/{productId}` → `productId` 변수에 값
  할당 |
  | **`@RequestParam`** | 쿼리 문자열(`?` 뒤)의 파라미터 값을 추출. **정렬, 필터링, 검색** 등 옵션 전달에 사용. | `/products?category=books` →
  `category` 변수에 'books' 할당 |

* **문법 및 사용법 (How?)**:
  ```java
  @RestController
  @RequestMapping("/api/v1/users") // 클래스 레벨에서 공통 경로 설정
  public class UserController {

      // 경로 변수(@PathVariable) 사용
      // 요청 URL: /api/v1/users/101
      @GetMapping("/{userId}")
      public User findUserById(@PathVariable long userId) {
          // userId 변수에는 101이 담김
          return userService.findOne(userId);
      }

      // 쿼리 파라미터(@RequestParam) 사용
      // 요청 URL: /api/v1/users?role=ADMIN&page=1
      @GetMapping
      public List<User> findUsersByRole(
              @RequestParam String role,
              @RequestParam(defaultValue = "1") int page) { // page 파라미터가 없으면 기본값 1 사용
          // role 변수에는 "ADMIN", page 변수에는 1이 담김
          return userService.findByRole(role, page);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@RequestParam`은 기본적으로 필수(`required=true`)다. 해당 파라미터가 요청 URL에 없으면 에러가 발생하므로, 선택적으로 받고 싶다면 `required=false` 속성을
      추가해야 한다.
    * `@PathVariable`의 변수명(`{userId}`)과 메서드 파라미터명(`long userId`)이 같으면, 애너테이션에서 값(`("userId")`)을 생략할 수 있어 코드가 간결해진다.

---

### 2. HTTP 메서드 기반 CRUD API 구현

각기 다른 HTTP 메서드(`GET`, `POST`, `PUT`, `DELETE`)의 목적에 맞게 CRUD(Create, Read, Update, Delete) 기능을 구현하고, RESTful API의 기본을
학습했다.

* **학습 목표 (Why?)**:
  리소스(데이터)에 대한 행위(조회, 생성, 수정, 삭제)를 HTTP 메서드로 명확하게 표현하여, 예측 가능하고 일관된 API를 설계하는 방법을 익히기 위함이다.

* **핵심 원리 (What?)**:
  `@RequestMapping`을 더 구체화한 단축 애너테이션을 사용한다.
  | 애너테이션 | HTTP 메서드 | CRUD 역할 |
  | :--- | :--- | :--- |
  | `@GetMapping` | `GET` | 리소스 **조회 (Read)** |
  | `@PostMapping`| `POST` | 리소스 **생성 (Create)** |
  | `@PutMapping` | `PUT` | 리소스 **전체 수정 (Update)** |
  | `@DeleteMapping`| `DELETE` | 리소스 **삭제 (Delete)** |

* **문법 및 사용법 (How?)**: `Product` 객체를 관리하는 REST API 컨트롤러 예시
  ```java
  @RestController
  @RequestMapping("/api/v2/products")
  public class ProductController {
      private final Map<Long, Product> productStore = new HashMap<>();
      private long nextId = 1L;

      // 전체 상품 목록 조회 (GET /api/v2/products)
      @GetMapping
      public List<Product> listProducts() { /* ... */ }

      // 특정 상품 상세 조회 (GET /api/v2/products/{id})
      @GetMapping("/{id}")
      public Product getProduct(@PathVariable Long id) { /* ... */ }

      // 새 상품 등록 (POST /api/v2/products)
      @PostMapping
      public Product createProduct(@RequestBody Product newProduct) {
           newProduct.setId(nextId++);
           productStore.put(newProduct.getId(), newProduct);
           return newProduct;
      }
      
      // 상품 정보 수정 (PUT /api/v2/products/{id})
      @PutMapping("/{id}")
      public Product updateProduct(@PathVariable Long id, @RequestBody Product updatedProduct) { /* ... */ }
      
      // 상품 삭제 (DELETE /api/v2/products/{id})
      @DeleteMapping("/{id}")
      public void deleteProduct(@PathVariable Long id) { /* ... */ }
  }
  ```

---

### 3. 다양한 형식의 응답 데이터 처리

서버가 처리 결과를 클라이언트에게 어떤 형식으로 전달할지 결정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  클라이언트의 요구에 맞춰 HTML 뷰(View)를 렌더링하거나, 순수 데이터(JSON, Text 등)를 직접 응답하는 등 다양한 응답 방식을 자유자재로 구현하기 위함이다.

* **핵심 원리 (What?)**:
  컨트롤러에 붙는 애너테이션에 따라 반환 값의 처리 방식이 근본적으로 달라진다.
  | 애너테이션 | `String` 반환 시 동작 | 객체/리스트 반환 시 동작 |
  | :--- | :--- | :--- |
  | **`@Controller`** | **뷰(View) 이름**으로 해석. `ViewResolver`가 JSP 등을 찾아 렌더링. | (단독 사용 시) 오류 발생. `Model`에 담아서 뷰로 전달해야 함. |
  | **`@Controller` + `@ResponseBody`** | **순수 텍스트(Text)**로 응답 본문에 직접 작성. | **JSON**으로 자동 변환되어 응답 본문에 직접 작성. |
  | **`@RestController`** | **순수 텍스트(Text)**로 응답 본문에 직접 작성. | **JSON**으로 자동 변환되어 응답 본문에 직접 작성. |

* **문법 및 사용법 (How?)**:
  ```java
  @Controller // 뷰를 반환하는 컨트롤러
  public class PageController {
      @GetMapping("/home")
      public String homePage() {
          return "index"; // /WEB-INF/views/index.jsp 렌더링
      }
  }

  @RestController // 데이터만 반환하는 컨트롤러
  @RequestMapping("/api/users")
  public class UserApiController {
      // User 객체가 JSON으로 자동 변환되어 응답됨
      @GetMapping("/{id}")
      public User getUser(@PathVariable Long id) {
          return new User("Alice", 30);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@RestController`는 `@Controller`와 `@ResponseBody`를 합친 애너테이션이다. RESTful API처럼 데이터만 제공하는 컨트롤러를 만들 때는 클래스 레벨에
      `@RestController`를 사용하는 것이 훨씬 편리하다.
    * 반대로, JSP나 Thymeleaf 같은 템플릿 엔진을 사용하여 서버 사이드 렌더링을 할 때는 `@Controller`를 사용해야 한다.

---

## 오늘의 깨달음 💡

* **애너테이션은 '마법'이 아니라 '약속'이다.** `@GetMapping`, `@RequestParam` 등의 애너테이션은 과거의 복잡한 서블릿 설정을 대신하는 편리한 '약속'이었다. 이 약속의 규칙과 의미를
  정확히 이해해야만, Spring이 제공하는 자동화의 이점을 제대로 누릴 수 있다.

* **RESTful API는 '잘 정리된 도서관'과 같았다.** URL은 '책의 위치(리소스)'를, HTTP 메서드는 '행위(대출, 반납)'를 나타낸다는 원칙에 따라 CRUD API를 구현해보니, 왜 이런 방식이
  체계적이고 누구나 쉽게 이해하고 예측할 수 있는지 알 수 있었다.

* **서버는 '요리사', 클라이언트는 '손님'이다.** `@RestController`를 통해 서버가 순수한 데이터를 JSON이라는 '요리(데이터)' 형태로 제공하면, 클라이언트(웹, 앱 등)라는 '손님'은 그
  요리를 받아 자신의 '접시(화면)'에 원하는 대로 예쁘게 담아낼 수 있다. 이 역할 분리가 현대적인 웹 개발의 핵심이라는 점을 깨달았다.

* Spring Boot와 Jackson 라이브러리의 자동화 덕분에, 개발자는 '자바 객체를 어떻게 JSON으로 바꿀까?'를 고민하는 대신, '어떤 데이터를 제공할까?'라는 비즈니스 로직의 본질에만 집중할 수 있게
  되었다. 이것이 프레임워크가 제공하는 진정한 가치임을 느꼈다.