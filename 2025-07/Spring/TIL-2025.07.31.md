# TIL - 2025.07.31 - QueryDSL 기본 사용법과 동적 쿼리 작성 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #QueryDSL #DynamicQuery #Paging

---

## 오늘 배운 내용 🔍

- QueryDSL의 등장 배경과 JPQL/Native SQL 대비 장점(타입 안정성)
- QueryDSL 사용을 위한 기본 설정 (`Q-Type` 클래스, `JPAQueryFactory` 빈 등록)
- `select`, `from`, `where`를 이용한 기본적인 쿼리 작성법과 빌더 패턴
- `eq`, `like`, `between`, `in` 등 다양한 `where` 조건절 메서드 활용법
- `fetch()`, `fetchOne()`, `fetchFirst()`를 이용한 결과 반환 전략
- `orderBy()`, `offset()`, `limit()`을 이용한 동적 정렬 및 페이징 처리
- Spring Data JPA의 `Pageable` 인터페이스와 QueryDSL을 통합하여 페이징 구현하기

---

## 어려웠던 점 💣

* **Q 클래스의 생성 원리**: `QIdol`과 같은 Q 클래스를 직접 만든 적이 없는데 코드에서 사용되는 것이 의문이었다. 이는 QueryDSL 플러그인이 컴파일 시점에 엔티티 클래스를 분석하여 자동으로
  생성해주는 메타 모델 클래스라는 것을 알게 되었다.

* **문자열 기반 쿼리의 문제점**: JPQL이나 Native SQL을 사용할 때 필드명에 오타가 나도 컴파일 시점에는 알 수 없고, 런타임에 에러를 마주하는 경험이 있었다. QueryDSL은 자바 코드로 쿼리를
  작성하므로, 오타가 발생하면 즉시 컴파일 에러로 알려주는 점을 통해 타입 안정성의 장점을 이해했다.

* **QueryDSL의 코드 길이**: 단순 조회 기능의 경우, Spring Data JPA의 쿼리 메서드 한 줄로 가능한 것을 QueryDSL은 여러 줄로 작성해야 해서 처음에는 더 번거롭다고 생각했다. 하지만
  검색 조건이 여러 개 붙는 복잡한 동적 쿼리 상황에서는, QueryDSL의 빌더 패턴이 오히려 각 조건을 명확하게 표현해주어 가독성이 더 좋아진다는 것을 알게 되었다.

* **`fetchOne()`의 반환 값**: 조회 결과가 단 한 건일 때 `fetchOne()`을 사용했는데, 조건에 맞는 데이터가 없을 경우 `null`을 반환하는 대신
  `NonUniqueResultException` 또는 `NullPointerException`이 발생할 수 있다는 점을 알게 되었다. `Optional.ofNullable()`로 결과를 감싸서 처리하는 방어적인
  코딩의 필요성을 인지했다.

---

## 정리 🖇️

### 1. QueryDSL 소개와 기본 설정

문자열 기반 쿼리의 한계를 극복하고, 자바 코드로 타입에 안전하고 동적인 쿼리를 작성하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  JPQL이나 Native SQL을 문자열로 작성할 때 발생하는 오타, 문법 오류 등의 런타임 에러를 컴파일 시점에 잡아내고, 복잡한 동적 쿼리를 더욱 쉽고 가독성 있게 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * **QueryDSL**: SQL, JPQL 등을 자바 코드를 통해 빌더 패턴으로 생성할 수 있게 해주는 쿼리 빌더 프레임워크.
    * **Q-Type 클래스**: QueryDSL의 핵심. 컴파일 시점에 `@Entity` 어노테이션이 붙은 엔티티 클래스를 기반으로 **자동 생성되는 쿼리용 메타 모델 클래스**이다. (e.g.,
      `Member` 엔티티 -> `QMember` 클래스 생성) 이 Q-Type을 통해 필드에 타입 세이프하게 접근할 수 있다.
    * **`JPAQueryFactory`**: QueryDSL 쿼리 작성을 위한 진입점 역할을 하는 클래스. `EntityManager`를 주입받아 생성하며, 스프링 빈으로 등록하여 재사용하는 것이 일반적이다.

* **문법 및 사용법 (How?)**:
    1. **`build.gradle`에 QueryDSL 의존성 및 플러그인 추가**: Q-Type 자동 생성을 위해 필요.
    2. **`JPAQueryFactory`를 스프링 빈으로 등록**:
       ```java
       @Configuration
       public class QueryDslConfig {
           @PersistenceContext
           private EntityManager em;
       
           @Bean
           public JPAQueryFactory jpaQueryFactory() {
               return new JPAQueryFactory(em);
           }
       }
       ```
    3. **Q-Type을 사용하여 쿼리 작성**:
       ```java
       // QMember를 static import하여 사용
       import static com.example.project.entity.QMember.member;

       @Repository
       @RequiredArgsConstructor
       public class MemberRepositoryCustom {
           private final JPAQueryFactory factory;

           public Member findMemberByName(String name) {
               return factory
                       .select(member)
                       .from(member)
                       .where(member.name.eq(name))
                       .fetchOne();
           }
       }
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * Q-Type 클래스는 직접 수정하는 것이 아니라, `build`나 `compileQuerydsl` 같은 빌드 태스크를 통해 항상 자동으로 생성/관리되도록 해야 한다.
    * 가독성을 위해 `QMember.member`와 같이 Q-Type 인스턴스를 `static import`하여 사용하는 것이 좋다.

---

### 2. 동적 조건절(WHERE)과 결과 조회

다양한 검색 조건에 따라 유연하게 쿼리를 생성하고, 상황에 맞는 방식으로 결과를 반환하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  사용자의 입력에 따라 검색 조건이 계속 바뀌는 동적인 상황(e.g., 다중 조건 검색 필터)에 효과적으로 대응하고, 조회된 결과의 개수(0, 1, N)에 따라 안전하게 데이터를 처리하기 위함이다.

* **핵심 원리 (What?)**:
    * **조건절 메서드**: QueryDSL은 `eq`(equal), `ne`(not equal), `like`, `contains`, `startsWith`, `between`, `in`, `goe`(>=),
      `lt`(<) 등 SQL의 거의 모든 연산자에 대응하는 직관적인 자바 메서드를 제공한다.
    * **결과 반환 메서드**:
      | 메서드 | 설명 |
      | :--- | :--- |
      | `fetch()` | 조건에 맞는 모든 결과를 `List<T>`로 반환. 결과가 없으면 빈 리스트를 반환. |
      | `fetchOne()`| 단 하나의 결과만 반환. 결과가 없으면 `null`, 2개 이상이면 `NonUniqueResultException` 발생. |
      | `fetchFirst()`| `limit(1).fetchOne()`과 유사. 조회된 결과 중 첫 번째 하나만 반환. 결과가 없으면 `null` 반환. |

* **문법 및 사용법 (How?)**:
  ```java
  import static com.example.project.entity.QMember.member;
  
  // 이름에 '팀'이 포함되고, 나이가 20~25세 사이인 멤버 조회
  List<Member> members = factory
          .selectFrom(member)
          .where(
              member.team.name.contains("팀"),
              member.age.between(20, 25) // and 조건은 쉼표(,)로 연결 가능
          )
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `where()` 메서드에 여러 조건을 쉼표(`,`)로 나열하면 `AND` 조건으로 자동 처리되어 코드가 간결해진다.
    * `fetchOne()`은 예외 발생 가능성이 있으므로, `Optional`로 감싸서 처리하거나 비즈니스 로직상 결과가 반드시 하나여야 하는 경우에만 제한적으로 사용하는 것이 안전하다.

---

### 3. 정렬(OrderBy)과 페이징(Paging)

조회된 결과를 특정 순서로 정렬하고, 대량의 데이터를 페이지 단위로 나누어 조회하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  사용자에게 정돈된 데이터를 보여주고, 대용량 데이터 조회 시 발생할 수 있는 성능 및 메모리 문제를 방지하기 위해 서버사이드 페이징을 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **`orderBy(정렬_기준)`**: 쿼리 결과의 정렬 순서를 지정한다. (`asc()`, `desc()`)
    * **`offset(시작_인덱스)`**: 조회 결과에서 건너뛸 로우(row)의 개수를 지정한다.
    * **`limit(개수)`**: 조회할 최대 로우의 개수를 지정한다.

* **문법 및 사용법 (How?)**:
  ```java
  int pageNumber = 2; // 2번째 페이지
  int pageSize = 10;  // 페이지 당 10개
  long offset = (pageNumber - 1) * pageSize;

  List<Member> members = factory
          .selectFrom(member)
          .orderBy(member.age.desc(), member.name.asc())
          .offset(offset)
          .limit(pageSize)
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 안정적인 페이징 결과를 얻기 위해서는 **`orderBy`를 반드시 포함**해야 한다. 정렬 기준이 없으면 DB에 따라 조회 시마다 데이터 순서가 달라질 수 있다.

---

### 4. Spring Data JPA 페이징(`Pageable`)과 통합

QueryDSL의 동적 쿼리 작성 능력과 Spring Data JPA의 편리한 페이징 처리(`Page` 인터페이스)를 결합하는 실무적인 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순히 데이터 목록만 반환하는 것을 넘어, 총 데이터 수, 전체 페이지 수, 현재 페이지 번호 등 풍부한 페이징 정보를 담은 `Page` 객체를 클라이언트에게 반환하기 위함이다.

* **핵심 원리 (What?)**:
    1. 사용자 정의 Repository 인터페이스(`MemberRepositoryCustom`)와 그 구현체(`...Impl`)를 생성하여 실제 페이징 로직을 구현한다.
    2. 구현 로직은 `pageable` 정보를 이용해 콘텐츠 목록을 조회하는 쿼리와, 전체 데이터 수를 조회하는 `count` 쿼리로 나뉜다.
    3. 조회된 `content`, `pageable`, `total` count를 사용하여 `new PageImpl<>(...)` 객체를 생성하여 반환한다.

* **문법 및 사용법 (How?)**:
  ```java
  // MemberRepositoryCustomImpl.java
  @Repository
  @RequiredArgsConstructor
  public class MemberRepositoryCustomImpl implements MemberRepositoryCustom {
      private final JPAQueryFactory factory;

      @Override
      public Page<Member> findAllWithPaging(Pageable pageable) {
          // 1. 데이터(콘텐츠) 조회 쿼리
          List<Member> content = factory
                  .selectFrom(member)
                  .orderBy(member.name.asc())
                  .offset(pageable.getOffset())
                  .limit(pageable.getPageSize())
                  .fetch();
          
          // 2. 전체 카운트 조회 쿼리
          Long total = Optional.ofNullable(
              factory.select(member.count()).from(member).fetchOne()
          ).orElse(0L);

          // 3. Page 객체로 포장하여 반환
          return new PageImpl<>(content, pageable, total);
      }
  }
  ```

---

## 오늘의 깨달음 💡

* QueryDSL은 자바 코드를 통해 SQL을 작성함으로써, 문자열 기반 쿼리에서 발생할 수 있는 런타임 오류를 컴파일 시점에 방지할 수 있는 타입 안정성을 제공한다.

* Q-Type이라는 자동 생성된 메타 모델 클래스를 사용하면, 엔티티의 필드에 문자열이 아닌 객체 필드처럼 접근하여 오타 가능성을 줄일 수 있다.

* 단순한 조회는 Spring Data JPA의 쿼리 메서드가 더 간결하지만, 여러 개의 검색 조건이 동적으로 결합되는 복잡한 쿼리에서는 QueryDSL의 빌더 패턴이 코드의 가독성과 유지보수성을 높여준다.

* Spring Data JPA의 `Pageable` 인터페이스와 QueryDSL을 통합하면, 동적인 쿼리 작성의 유연성과 표준화된 페이징 응답 객체의 편리함을 모두 취할 수 있다.