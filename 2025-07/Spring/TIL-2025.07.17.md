# TIL - 2025.07.17 - SOLID 원칙과 Spring IoC/DI, 그리고 MVC를 활용한 API 연동 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #OOP #SOLID #IoC #DI #SpringBean #SpringMVC #Controller #RestController #DTO #AJAX #fetch

---

## 오늘 배운 내용 🔍

- 좋은 객체 지향 설계를 위한 5가지 원칙 **SOLID**
- **제어의 역전(IoC)**과 **의존성 주입(DI)**의 개념 및 Spring에서의 구현
- Spring **IoC 컨테이너**가 관리하는 객체, **스프링 빈(Bean)**의 개념과 싱글톤 스코프
- `@Controller`(페이지 라우팅)와 `@RestController`(API)의 역할 분리 설계
- JavaScript `fetch` API를 이용한 비동기 통신(AJAX)으로 서버와 데이터 교환
- 요청(Request) DTO와 응답(Response) DTO를 분리하여 설계하는 이유와 장점
- `@Valid`와 `BindingResult`를 활용한 서버 측 데이터 유효성 검증
- Java Stream API와 `Comparator`를 활용한 서버 단에서의 데이터 정렬 및 가공

---

## 어려웠던 점 💣

* **제어의 역전(IoC) 개념의 추상성**: `new` 키워드로 직접 객체를 만들고 관계를 맺어주던 흐름에서, `ApplicationContext`에게 "객체를 달라"고 요청하면 모든 의존성이 조립된 완전한
  객체가 나오는 과정이 처음에는 어색했다. 제어의 주체가 개발자에서 Spring 프레임워크로 바뀌는 패러다임의 전환을 이해하는 데 시간이 필요했다.

* **`@Configuration`과 `@Bean`의 싱글톤 보장 원리**: `AppConfig` 설정 클래스에서 `userService()`가 `userRepository()`를 호출할 때,
  `new MemoryUserRepository()`가 매번 실행되지 않고 Spring이 항상 동일한 인스턴스를 반환해주는 내부 동작 원리가 궁금했다. 이는 Spring이 CGLIB 라이브러리를 통해 설정 클래스를
  동적으로 조작하여 싱글톤을 보장하기 때문이라는 것을 알게 되었다.

* **`@Controller`와 `@RestController`의 분리 필요성**: 처음에는 모든 요청을 하나의 컨트롤러에서 처리하면 안 되는지 의문이었다. 하지만 페이지를 보여주는 **'페이지 로더'** 역할과,
  JavaScript에 JSON 데이터를 제공하는 **'데이터 공급자'** 역할을 명확히 분리하는 것이 더 깔끔하고 확장성 있는 설계임을 깨달았다.

* **페이지 초기 로딩 시 데이터 렌더링 흐름**: JSP 페이지만 열었는데 어떻게 학생 목록이 저절로 그려지는지 그 과정이 궁금했다. 브라우저가 HTML 렌더링을 마친 후, 페이지 내 `<script>` 태그의
  `fetch` 함수가 즉시 호출되어 API 서버에 데이터를 비동기적으로 요청하고, 그 응답을 받아 동적으로 화면을 완성하는 흐름임을 알게 되었다.

* **서버 검증 에러와 프론트엔드 연동 방식**: 서버의 `BindingResult`에 담긴 에러 메시지가 어떻게 프론트엔드의 `<p class="error">` 태그 안에 나타나는지 그 과정이 명확하지 않았다.
  서버는 에러 발생 시 400 상태 코드와 함께 에러 메시지가 담긴 JSON 객체를 보내주고, JavaScript는 이 JSON을 받아 화면에 표시해주는 프론트엔드와 백엔드 간의 '에러 처리 약속'이 필요하다는
  것을 이해했다.

---

## 정리 🖇️

### 1. SOLID: 좋은 객체 지향 설계를 위한 5가지 원칙

유연하고, 확장 가능하며, 유지보수가 쉬운 소프트웨어를 만들기 위한 5가지 핵심 설계 원칙을 학습했다.

* **학습 목표 (Why?)**:
  특정 구현에 얽매여 변경이 어려운 코드(강한 결합)가 아닌, 필요에 따라 부품을 쉽게 교체할 수 있는 유연한 코드(느슨한 결합)를 작성하기 위함이다. Spring 프레임워크는 이 원칙들을 쉽게 지킬 수 있도록
  설계된 도구다.

* **핵심 원리 (What?)**:
  | 원칙 | 이름 | 핵심 아이디어 |
  | :--- | :--- | :--- |
  | **S** | **단일 책임 원칙 (SRP)** | 하나의 클래스는 단 하나의 책임만 가져야 한다. |
  | **O** | **개방-폐쇄 원칙 (OCP)** | 기능 확장에 대해서는 열려 있고, 기존 코드 수정에 대해서는 닫혀 있어야 한다. |
  | **L** | **리스코프 치환 원칙 (LSP)** | 자식 클래스는 언제나 부모 클래스의 역할을 완벽하게 대체할 수 있어야 한다. |
  | **I** | **인터페이스 분리 원칙 (ISP)**| 클라이언트는 자신이 사용하지 않는 기능에 의존해서는 안 된다. (역할에 따라 인터페이스 분리) |
  | **D** | **의존성 역전 원칙 (DIP)** | 구체적인 구현 클래스에 의존하지 말고, 추상적인 약속(인터페이스)에 의존해야 한다. |

* **문법 및 사용법 (How?)**: DIP와 OCP를 지키는 코드 예시
  ```java
  // === 추상화에 의존 (DIP) ===
  public interface UserRepository { /* ... */ }

  // === 구체적인 구현체들 ===
  public class MemoryUserRepository implements UserRepository { /* ... */ }
  public class JdbcUserRepository implements UserRepository { /* ... */ }

  // === 클라이언트 코드 ===
  public class UserService {
      // 구체적인 MemoryUserRepository가 아닌, UserRepository 인터페이스에 의존
      private final UserRepository userRepository;

      public UserService(UserRepository userRepository) {
          this.userRepository = userRepository;
      }
  }
  // -> 나중에 JdbcUserRepository로 바꾸더라도 UserService 코드는 전혀 수정할 필요가 없다 (OCP 만족)
  ```

---

### 2. 제어의 역전(IoC)과 의존성 주입(DI)

SOLID 원칙, 특히 DIP를 손쉽게 지킬 수 있도록 돕는 Spring의 핵심 철학이자 기술을 학습했다.

* **학습 목표 (Why?)**:
  객체 생성과 의존 관계 설정을 개발자가 직접하는 대신 프레임워크에 위임함으로써, 개발자는 비즈니스 로직에만 집중하고, 클래스 간의 결합도를 낮춰 유연한 설계를 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **IoC (Inversion of Control, 제어의 역전)**: `new` 키워드를 사용해 객체를 생성하고 관계를 맺어주던 **제어권**을 개발자가 아닌 **Spring 프레임워크**에게 위임하는
      설계 원칙이다.
    * **DI (Dependency Injection, 의존성 주입)**: IoC를 구현하는 구체적인 방법. 한 객체가 필요로 하는 다른 객체(의존성)를 외부(Spring 컨테이너)에서 만들어서 넣어주는(
      주입하는) 기술이다. **생성자 주입**이 가장 권장된다.

* **문법 및 사용법 (How?)**: Java 코드를 이용한 Spring 설정 (`@Configuration`, `@Bean`)
  ```java
  // AppConfig.java (애플리케이션의 설정 및 구성 정보)
  @Configuration
  public class AppConfig {
      @Bean // 이 메서드가 반환하는 객체를 Spring 컨테이너에 '빈(Bean)'으로 등록
      public UserRepository userRepository() {
          return new MemoryUserRepository(); // 사용할 구현체 선택
      }

      @Bean
      public UserService userService() {
          // Spring이 userRepository() 빈을 userService() 생성자에 '주입(DI)'해줌
          return new UserService(userRepository());
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **스프링 빈(Bean)**: Spring IoC 컨테이너가 생성, 관리, 관계 설정까지 모든 것을 책임지는 특별한 객체. 기본적으로 **싱글톤(Singleton)**으로 관리되어 애플리케이션 전체에서
      동일한 인스턴스가 재사용된다.

---

### 3. 페이지 라우팅(@Controller)과 API 라우팅(@RestController)의 분리

사용자가 보는 웹 페이지를 반환하는 역할과, 페이지 내부에서 비동기적으로 사용될 데이터를 반환하는 역할을 분리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  애플리케이션의 책임을 명확히 나누어 유지보수성을 높인다. 사용자가 직접 접속하는 URL(페이지)과 프로그램(JavaScript)이 데이터를 요청하는 URL(API)을 분리하여 관리의 효율성을 증대시킨다.

* **핵심 원리 (What?)**:
    * **`@Controller`**: 사용자의 요청에 대해 **렌더링할 뷰(View)의 논리적 이름**을 반환한다. Spring의 `ViewResolver`가 이 이름을 받아 실제 JSP 파일을 찾아 HTML
      페이지로 응답한다.
    * **`@RestController`**: `@Controller`와 `@ResponseBody`가 합쳐진 애너테이션. 뷰를 반환하는 대신, **데이터(주로 JSON) 자체를 HTTP 응답 본문에 직접**
      써서 반환한다. JavaScript의 `fetch` 요청에 응답하기 위해 사용된다.

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 페이지 로딩 요청 처리 (ScoreRouteController.java)
  @Controller
  public class ScoreRouteController {
      @GetMapping("/scores")
      public String scoreListPage() {
          return "scores/list"; // -> /WEB-INF/views/scores/list.jsp 렌더링
      }
  }

  // 2. 데이터(API) 요청 처리 (ScoreApiController.java)
  @RestController
  @RequestMapping("/api/v1/scores")
  public class ScoreApiController {
      @GetMapping
      public ResponseEntity<?> getScores() {
          List<ScoreListResponse> responses = scoreService.findAll();
          return ResponseEntity.ok().body(responses); // JSON 데이터 응답
      }
  }
  ```

---

### 4. Frontend-Backend 비동기 통신과 DTO 설계

JavaScript `fetch`를 이용해 서버 API와 통신하고, 목적에 맞는 DTO를 설계하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  전체 페이지를 새로고침하지 않는 동적인 웹 애플리케이션(AJAX)을 구축하고, Entity를 외부에 직접 노출하지 않고 목적에 맞게 가공된 데이터만 주고받아 시스템을 안전하고 유연하게 만들기 위함이다.

* **핵심 원리 (What?)**:
    1. **Frontend (요청)**: JavaScript의 `fetch` 함수가 백엔드 API 주소로 HTTP 요청을 보낸다.
    2. **Backend (처리 및 응답)**: Spring의 `@RestController`가 요청을 받아 처리한 후, 결과 데이터를 **Response DTO**에 담아 JSON 형태로 응답한다.
    3. **Frontend (렌더링)**: `fetch`가 응답받은 JSON 데이터를 JavaScript 객체로 변환하여, 동적으로 HTML 요소를 생성하거나 수정하여 화면에 반영한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // Frontend: fetch를 이용한 GET 요청 (score-list.jsp)
  async function fetchAndRenderScores() {
      const res = await fetch('/api/v1/scores');
      const scoreList = await res.json();
      renderScores(scoreList); // 받아온 데이터로 화면을 그리는 함수
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **DTO 분리**: **Request DTO**는 클라이언트의 요청 데이터와 유효성 검증 규칙을 담고, **Response DTO**는 서버가 클라이언트에게 보낼 가공된 데이터를 담는다. 두 DTO를
      분리하는 것은 역할과 책임을 명확히 하는 좋은 설계다.

---

### 5. Java Stream을 활용한 서버 데이터 가공

서버에서 가져온 데이터 컬렉션을 선언적이고 효율적으로 처리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  `for` 루프를 사용하는 명령형 코드보다 더 간결하고 가독성 높은 코드로 데이터 컬렉션을 변환, 필터링, 정렬하는 로직을 작성한다.

* **핵심 원리 (What?)**:
    * `map()`: 스트림의 각 요소를 다른 요소로 변환한다. (e.g., `Score` Entity를 `ScoreListResponse` DTO로 변환)
    * `collect()`: 스트림의 요소들을 새로운 컬렉션(List, Map 등)으로 수집한다.
    * `Comparator`: `sort()` 메서드나 `sorted()` 스트림 연산과 함께 사용되어 객체 리스트의 정렬 기준을 정의한다.

* **문법 및 사용법 (How?)**:
  ```java
  // ScoreService.java
  public List<ScoreListResponse> findAll(String sort) {
      // 1. 모든 Score 엔티티를 DTO 리스트로 변환
      List<ScoreListResponse> responseList = scoreRepository.findAll().stream()
              .map(ScoreListResponse::from)
              .collect(Collectors.toList());

      // 2. 정렬 기준(sort)에 따라 Comparator를 사용하여 정렬
      responseList.sort(getScoreComparator(sort));
      
      return responseList;
  }

  private Comparator<ScoreListResponse> getScoreComparator(String sort) {
      return switch (sort) {
          case "name" -> Comparator.comparing(ScoreListResponse::getStudentName);
          case "average" -> Comparator.comparing(ScoreListResponse::getAverage).reversed();
          default -> Comparator.comparing(ScoreListResponse::getStuNum);
      };
  }
  ```

---

## 오늘의 깨달음 💡

* SOLID 원칙은 유연한 설계를 위한 기반이며, Spring의 IoC/DI는 이 원칙들(특히 DIP, OCP)을 쉽게 지키도록 돕는 핵심 도구임을 이해했다.

* 개발자는 직접 객체를 생성하고 연결하는 '조립' 과정 대신, `@Configuration`으로 '설계도'를 그리고 `@Bean`으로 '부품 목록'을 정의하면, Spring이라는 '전문 조립공'이 알아서 완성품을
  만들어준다.

* 스프링 컨테이너를 이용한 테스트는, 각 부품이 아니라 모든 부품이 설계도대로 완벽하게 조립된 '완성품'의 동작을 검증하는 과정이다.

* 현대 웹 애플리케이션은 페이지를 보여주는 책임(`@Controller`)과 데이터를 제공하는 책임(`@RestController`)이 명확히 분리되는 추세임을 이해했다. 이 둘이 협력하여 동적인 웹 페이지를
  완성한다.

* DTO는 서버와 클라이언트 사이의 '외교 문서'와 같다. 내부 사정(Entity 구조)을 그대로 드러내는 대신, 서로 합의된 형식(DTO)에 맞춰 필요한 정보만 교환함으로써, 양측이 독립적으로 발전할 수 있는
  유연성을 확보한다.

* 사용자 화면 뒤에는 보이지 않는 '요청과 응답의 댄스'가 있다. 단순히 버튼을 누르면 목록이 정렬되는 화면 뒤에는, JavaScript(`fetch`)가 서버에 '정렬해주세요!'라고 요청을 보내고, Spring
  서버가 데이터를 가공(`Comparator`)한 뒤 '여기 있습니다!'라고 JSON으로 응답하는 복잡한 비동기 통신이 숨어있었다.