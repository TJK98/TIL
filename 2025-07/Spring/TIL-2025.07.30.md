# TIL - 2025.07.30 - JPA 심화: N+1, Cascade, 다대다 관계 매핑 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #NPlusOne #FetchJoin #Cascade #ManyToMany

---

## 오늘 배운 내용 🔍

- 연관된 엔티티 조회 시 발생하는 **N+1 문제**의 원인과 **Fetch Join**을 이용한 해결 방법
- 엔티티 생명주기 관리를 위한 영속성 전이(**Cascade**)와 고아 객체 제거(**Orphan Removal**)
- 양방향 연관 관계에서 데이터 정합성을 유지하기 위한 **연관 관계 편의 메서드**의 중요성
- 실무에서 `@ManyToMany`를 지양하고, **연결 엔티티(Junction Entity)**를 통해 다대다 관계를 1:N, N:1 관계로 풀어내는 방법
- 영속성 컨텍스트와 DB 상태를 동기화하는 `flush()`와 컨텍스트를 초기화하는 `clear()`의 역할

---

## 어려웠던 점 💣

* **`orphanRemoval`과 `CascadeType.REMOVE`의 차이**: 두 옵션 모두 연관된 자식 엔티티를 삭제한다는 점에서 혼동되었다. `orphanRemoval=true`는 부모의 컬렉션에서
  자식을 **제거(연결을 끊음)했을 때** 동작하고, `CascadeType.REMOVE`는 부모 엔티티 **자체가 삭제될 때** 동작한다는 차이점을 구분해야 했다.

* **N+1 문제의 발생 확인**: `findAll()`로 쿼리 한 번만 실행했다고 생각했으나, 테스트 로그에서 연관된 `employees` 리스트에 접근할 때마다 팀의 수(N)만큼 `SELECT` 쿼리가 추가로
  실행되는 것을 확인했다. JPA가 명시적인 `JOIN FETCH` 없이는 지연 로딩된 연관 관계를 개별적으로 조회한다는 동작 원리를 이해해야 했다.

* **`@ManyToMany`의 한계**: `@ManyToMany` 애너테이션을 사용하면 연결 테이블에 대한 추가적인 정보(e.g., 구매 날짜, 수량)를 저장할 수 없다는 점이 실무에서 사용을 지양하는 주된
  이유임을 알게 되었다. 중간 테이블을 별도의 엔티티로 승격시켜 `1:N - N:1` 관계로 풀어내는 것이 더 유연하고 확장성 있는 설계임을 이해했다.

* **연관 관계 편의 메서드의 필요성**: `member.setTeam(newTeam)`으로 팀을 변경한 후, 이전 팀의 멤버 목록을 조회했을 때 해당 멤버가 그대로 남아있는 현상을 마주했다. 이는 객체 관점의
  관계와 DB 관점의 관계(외래 키)를 모두 일관성 있게 맞춰줘야 한다는 사실을 간과했기 때문이었다. 양쪽 객체의 관계를 모두 업데이트해주는 편의 메서드의 필요성을 인지했다.

---

## 정리 🖇️

### 1. N+1 문제와 Fetch Join

연관된 엔티티를 조회할 때 발생하는 대표적인 성능 이슈와 그 해결책을 학습했다.

* **학습 목표 (Why?)**:
  의도치 않은 수많은 쿼리 발생을 막아 애플리케이션의 성능 저하를 방지하고, 단 하나의 최적화된 쿼리로 연관된 데이터를 함께 조회하는 방법을 익히기 위함이다.

* **핵심 원리 (What?)**:
    * **N+1 문제**: 연관 관계가 `LAZY` 로딩으로 설정된 엔티티 목록을 조회할 때 발생한다.
        1. 먼저 부모 엔티티 목록을 조회하는 쿼리 1번이 실행된다. (`SELECT * FROM team;`)
        2. 이후 각 부모 엔티티의 자식 컬렉션에 접근할 때마다, 자식을 조회하는 쿼리가 부모의 수(N)만큼 추가로 실행된다.
    * **Fetch Join**: N+1 문제를 해결하기 위한 JPQL의 기능. `JOIN FETCH` 구문을 사용하여 연관된 엔티티를 프록시 객체가 아닌 실제 데이터로 즉시 함께 조회한다. 이를 통해 모든
      데이터를 단 하나의 쿼리로 가져올 수 있다.

* **문법 및 사용법 (How?)**: `Team`을 조회하면서 `Member` 목록까지 한 번에 가져오기 위해 Repository에 `@Query`를 작성한다.
  ```java
  // TeamRepository.java
  public interface TeamRepository extends JpaRepository<Team, Long> {

      // JPQL의 JOIN FETCH 구문을 사용하여 N+1 문제를 해결한다.
      // DISTINCT를 사용하여 중복된 Team 객체가 반환되는 것을 방지한다.
      @Query("SELECT DISTINCT t FROM Team t JOIN FETCH t.members")
      List<Team> findAllWithMembers();
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 모든 연관 관계의 기본은 **`FetchType.LAZY`(지연 로딩)**로 설정하는 것이 원칙이다.
    * N+1 문제가 발생하는 특정 조회 기능에 한해서만 **Fetch Join을 선택적으로 사용하여 최적화**하는 것이 좋다.

---

### 2. 영속성 전이(Cascade)와 고아 객체(Orphan Removal)

부모 엔티티의 생명주기 변화를 자식 엔티티에 자동으로 반영하여, 코드를 간결하게 관리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  부모 엔티티를 저장하거나 삭제할 때, 연관된 자식 엔티티에 대한 `save()`나 `delete()`를 일일이 호출하는 번거로움을 줄이기 위함이다.

* **핵심 원리 (What?)**:
    * **영속성 전이 (Cascade)**: 부모 엔티티에 수행된 특정 작업(저장, 삭제 등)을 자식 엔티티에도 연쇄적으로 적용하는 옵션.
        * `CascadeType.PERSIST`: 부모를 저장(`save`)할 때, 자식도 함께 저장된다.
        * `CascadeType.REMOVE`: 부모를 삭제(`delete`)할 때, 자식도 함께 삭제된다.
    * **고아 객체 제거 (Orphan Removal)**: **부모 엔티티와의 연관 관계가 끊어진** 자식 엔티티를 자동으로 DB에서 삭제하는 기능. `orphanRemoval = true`로 설정한다.
      `team.getMembers().remove(member)`처럼 컬렉션에서 제거하는 것만으로도 `DELETE` 쿼리가 실행된다.

* **문법 및 사용법 (How?)**: `Team` 엔티티의 `@OneToMany` 관계에 옵션을 추가한다.
  ```java
  // Team.java
  @OneToMany(mappedBy = "team", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<Member> members = new ArrayList<>();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `CascadeType.REMOVE`는 부모가 삭제될 때, `orphanRemoval=true`는 부모와의 연결이 끊어질 때 자식을 삭제한다는 차이가 있다.
    * Cascade와 Orphan Removal은 해당 엔티티를 **독점적으로 소유하는 관계**에서만 신중하게 사용해야 한다. 여러 부모가 공유하는 자식에게 사용하면 예상치 못한 데이터 삭제가 발생할 수 있다.

---

### 3. 다대다(M:N) 관계 매핑의 올바른 접근법

실무에서 `@ManyToMany`를 사용하지 않고, 연결 엔티티를 통해 다대다 관계를 1:N, N:1 관계로 풀어내는 방법을 학습했다.

* **학습 목표 (Why?)**:
  `@ManyToMany`의 한계(관계에 대한 추가 정보 저장 불가, 복잡성)를 극복하고, 유연하고 확장 가능한 다대다 관계를 모델링하기 위함이다.

* **핵심 원리 (What?)**:
  `User`와 `Product` 간의 다대다 관계는 `Purchase`(구매)라는 **연결 엔티티(Junction Entity)**를 중간에 도입하여, `User` ↔ `Purchase` (1:N) 와
  `Product` ↔ `Purchase` (1:N) 관계로 분해한다. `Purchase` 엔티티에는 구매일시, 수량 등 **관계에 대한 추가 속성을 자유롭게 저장**할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  // Purchase.java (연결 엔티티)
  @Entity
  public class Purchase {
      @Id @GeneratedValue
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "product_id")
      private Product product;

      private LocalDateTime purchaseDate;
      private int quantity;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 이처럼 연결 엔티티를 사용하는 방식은 다대다 관계를 표현하는 **표준적이고 권장되는 실무 패턴**이다.

---

## 오늘의 깨달음 💡

* JPA의 지연 로딩은 기본적으로 효율적이지만, N+1 문제를 유발할 수 있는 잠재적 위험을 내포하고 있다. Fetch Join은 이러한 문제를 해결하기 위한 명시적인 최적화 기법이다.

* 영속성 전이(Cascade) 옵션은 부모와 자식 엔티티의 생명주기를 동기화하여 코드의 편의성을 높여준다. 단, 해당 엔티티를 단독으로 소유하는 관계에서만 신중하게 사용해야 한다.

* 객체지향 관점에서의 양방향 관계 설정과 데이터베이스의 외래 키 관계를 일치시키기 위해 연관 관계 편의 메서드를 작성하는 것은 데이터 정합성을 유지하는 데 필수적이다.

* `@ManyToMany`는 관계에 대한 추가 데이터를 저장할 수 없어 실무적인 한계가 명확하다. 다대다 관계는 중간에 연결 엔티티를 두어 1:N, N:1 관계로 풀어내는 것이 더 유연하고 확장성 있는 설계다.