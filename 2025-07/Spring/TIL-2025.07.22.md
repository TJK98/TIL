# TIL - 2025.07.22 - Spring 파일 업로드 처리, 검증 및 URL 제공 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #FileUpload #MultipartFile #UUID #WebMvcConfigurer

---

## 오늘 배운 내용 🔍

- `MultipartFile`을 이용한 Spring의 파일 업로드 처리 메커니즘
- 단일 및 다중 파일 업로드 컨트롤러 구현 방법
- `UUID`를 활용한 파일명 중복 방지 및 안전한 파일 저장 전략
- 파일 유형(MIME Type) 및 크기(Size) 검증을 통한 서버 보안 강화
- `WebMvcConfigurer`를 통해 서버의 로컬 저장소 파일을 외부 URL로 제공하는 방법

---

## 어려웠던 점 💣

* **파일의 저장 위치**: 코드를 통해 `/Users/.../uploads/` 같은 로컬 PC의 특정 경로에 파일이 저장되는 것을 보고, 이것이 실제 서버 환경에서는 어떻게 동작하는지 막연하게 느껴졌다. 업로드된
  파일이 웹 애플리케이션의 일부가 아니라, 서버의 특정 물리적 디스크 공간에 독립적으로 보관된다는 개념을 이해하는 데 시간이 걸렸다.

* **파일명 충돌 문제**: 여러 사용자가 각자 자신의 프로필 사진을 `profile.jpg`라는 동일한 이름으로 업로드하면, 서버에는 마지막에 업로드한 사람의 파일 하나만 남게 될 것이라는 우려가 있었다.
  `UUID`를 파일명 앞에 붙여 고유한 이름을 만들어주는 코드를 보고 나서야 파일명 중복 문제를 어떻게 해결하는지 명확히 이해할 수 있었다.

* **업로드된 파일의 웹 접근**: 파일을 `C:/uploads/` 경로에 저장했는데, 브라우저 `<img>` 태그의 `src`에 어떤 주소를 넣어야 그 이미지가 보이는지 알 수 없었다.
  `WebMvcConfigurer`를 통해 `/uploads/**` 라는 웹 URL 요청을 실제 서버의 `C:/uploads/` 디렉터리에 '매핑'해준다는 것을 알고 나서야 의문이 풀렸다. 웹 URL과 서버의
  물리적 경로는 별개이며, 이 둘을 연결해주는 설정이 필요하다는 것을 깨달았다.

* **설정 클래스의 분리**: 파일 업로드 경로를 `@Value`로 `FileUploadConfig`에서 관리하고, 이 설정을 `WebResourceConfig`와 `FileUploadController`가 가져다
  쓰는 구조가 복잡해 보였다. 하지만 이렇게 한곳에서 설정을 관리해야, 나중에 경로가 바뀌었을 때 `FileUploadConfig` 클래스 한 곳만 수정하면 되므로 유지보수가 훨씬 용이해진다는 것을 이해했다.

---

## 정리 🖇️

### 1. Spring 파일 업로드 기본: `MultipartFile`

클라이언트가 `multipart/form-data` 형식으로 전송한 파일을 서버에서 받아 처리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  사용자가 프로필 사진을 등록하거나, 게시물에 문서를 첨부하는 등 파일 기반 데이터를 서버에 저장하는 기능을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  Spring은 클라이언트가 전송한 파일 데이터를 **`MultipartFile`** 이라는 객체로 감싸 컨트롤러에 전달한다. 이 객체는 파일의 내용물(바이너리 데이터)뿐만 아니라 메타데이터(원본 파일명, 크기,
  타입 등)도 함께 담고 있다.
  | `MultipartFile` 주요 메서드 | 설명 |
  | :--- | :--- |
  | `getOriginalFilename()` | 사용자가 업로드한 파일의 원본 이름 (e.g., `my-photo.jpg`) |
  | `getSize()` | 파일 크기 (byte 단위) |
  | `getContentType()` | 파일의 MIME 타입 (e.g., `image/jpeg`, `application/pdf`) |
  | `transferTo(File dest)` | 메모리나 임시 디스크에 있는 파일 데이터를 지정된 영구 파일 경로로 저장(복사). |

* **문법 및 사용법 (How?)**:
    1. **Controller에서 파일 받기**: `@RequestParam` 애너테이션을 사용하여 요청 파라미터와 `MultipartFile` 객체를 매핑한다.
       ```java
       @RestController
       public class FileUploadController {
           @PostMapping("/upload/single")
           public ResponseEntity<?> uploadSingleFile(@RequestParam("file") MultipartFile file) {
               if (file.isEmpty()) {
                   return ResponseEntity.badRequest().body("업로드할 파일이 없습니다.");
               }
               // ... (파일 저장 및 검증 로직)
               return ResponseEntity.ok("업로드 성공");
           }
       }
       ```
    2. **`application.yml` 설정**: 파일 업로드 관련 제약사항을 설정한다.
       ```yaml
       spring:
         servlet:
           multipart:
             enabled: true
             max-file-size: 5MB    # 단일 파일 최대 크기
             max-request-size: 20MB # 요청 전체 최대 크기
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 다중 파일 업로드를 처리하려면 컨트롤러 메서드의 파라미터를 **`List<MultipartFile>`** 타입으로 선언하면 된다. (e.g.,
      `@RequestParam("files") List<MultipartFile> files`)

---

### 2. 안전한 파일 저장 및 관리 전략

업로드된 파일을 안전하고 체계적으로 서버에 저장하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  파일명 중복으로 인한 파일 유실을 방지하고, 경로 조작 같은 보안 공격으로부터 서버를 보호하기 위함이다.

* **핵심 원리 (What?)**:
    * **고유한 파일명 생성**: 사용자가 올린 원본 파일명을 그대로 사용하면 중복될 위험이 크다. **`UUID.randomUUID()`** 를 이용해 절대 중복되지 않는 문자열을 생성하고, 여기에 원본
      파일명을 덧붙여 서버에 저장할 고유한 파일명을 만든다.
    * **파일 경로 설정 외부화**: 파일 저장 경로 같은 주요 설정을 코드에 하드코딩하지 않고, `application.yml` 같은 외부 설정 파일로 분리한다. `@Value` 애너테이션으로 이 값을 읽어와
      사용하면, 나중에 경로 변경 시 코드 수정 없이 설정 파일만 바꾸면 된다.

* **문법 및 사용법 (How?)**:
    1. **`application.yml`에 경로 설정**:
       ```yaml
       file:
         upload:
           location: C:/project/uploads
       ```
    2. **설정 클래스에서 경로 값 주입받기**:
       ```java
       @Configuration
       @Getter
       public class FileUploadConfig {
           @Value("${file.upload.location}") // 설정 파일에서 값 주입
           private String location;
       }
       ```
    3. **고유 파일명 생성 및 파일 저장 로직**:
       ```java
       // FileUploadService.java
       public String saveFile(MultipartFile file) throws IOException {
           String originalFilename = file.getOriginalFilename();
           // UUID를 이용해 고유한 파일명 생성
           String uniqueFilename = UUID.randomUUID().toString() + "_" + originalFilename;

           // 설정된 루트 경로 + 고유 파일명으로 최종 저장 경로 생성
           File dest = new File(fileUploadConfig.getLocation(), uniqueFilename);
           file.transferTo(dest); // 파일 저장
           
           return uniqueFilename; // 서버에 저장된 최종 파일명 반환
       }
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **디렉터리 트래버설(Directory Traversal) 공격 방지**: 사용자 입력(`getOriginalFilename()`)에 `../../` 같은 상위 경로 이동 문자가 포함될 수 있다.
      `Path.getFileName()` 등으로 파일명 부분만 안전하게 추출하거나, `UUID`로 새 파일명을 만드는 것이 보안에 좋다.
    * 업로드 파일은 웹 애플리케이션 루트(e.g., `static` 폴더)가 아닌, **외부의 격리된 디렉터리**에 저장하는 것이 보안상 안전하다.

---

### 3. 파일 검증과 외부 URL 제공

업로드된 파일이 안전하고 유효한지 검증하고, 저장된 파일을 웹 브라우저가 접근할 수 있는 URL로 노출시키는 방법을 학습했다.

* **학습 목표 (Why?)**:
  악성 파일(e.g., `.exe`, `.sh`)의 업로드를 막아 서버를 보호하고, 사용자가 업로드한 이미지를 웹 페이지에 실제로 표시하기 위함이다.

* **핵심 원리 (What?)**:
    * **파일 검증**:
        * **MIME 타입 검증**: `file.getContentType()`을 통해 파일의 종류(`image/png`, `application/pdf` 등)를 확인하고, 허용된 타입 목록(
          Whitelist)에 포함되는지 검사한다. 확장자만 믿는 것은 위험하다.
        * **파일 크기 검증**: `application.yml`의 `max-file-size`는 1차 방어선이다. 코드 레벨에서 `file.getSize()`로 특정 기능에 맞는 더 세밀한 크기 제한을 둘
          수 있다.
    * **외부 URL 제공**:
        * 서버의 로컬 디렉터리는 기본적으로 외부에서 접근할 수 없다.
        * **`WebMvcConfigurer`** 인터페이스를 구현하고 `addResourceHandlers` 메서드를 오버라이드하여, 특정 URL 패턴(e.g., `/uploads/**`)을 실제 로컬
          파일 시스템 경로(e.g., `file:C:/project/uploads/`)에 매핑할 수 있다.

* **문법 및 사용법 (How?)**:
    1. **파일 검증 로직**:
       ```java
       private final List<String> ALLOWED_MIME_TYPES = List.of("image/jpeg", "image/png", "image/gif");
       
       // ... 컨트롤러 메서드 내부 ...
       String mimeType = file.getContentType();
       if (mimeType == null || !ALLOWED_MIME_TYPES.contains(mimeType)) {
           return ResponseEntity.badRequest().body("이미지 파일만 업로드 가능합니다.");
       }
       ```
    2. **URL 매핑 설정**:
       ```java
       // WebResourceConfig.java
       @Configuration
       @RequiredArgsConstructor
       public class WebResourceConfig implements WebMvcConfigurer {
           private final FileUploadConfig fileUploadConfig; // 업로드 경로 설정을 주입받음
       
           @Override
           public void addResourceHandlers(ResourceHandlerRegistry registry) {
               // 1. /uploads/** 패턴의 URL 요청이 오면,
               registry.addResourceHandler("/uploads/**")
                       // 2. file:C:/project/uploads/ 경로에서 파일을 찾아 응답하라.
                       .addResourceLocations("file:" + fileUploadConfig.getLocation() + "/");
           }
       }
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `addResourceLocations`에서 로컬 파일 시스템 경로를 지정할 때는 반드시 `file:` 접두사를 붙여야 한다.
    * 이 방식으로 URL을 제공하면 해당 디렉터리의 모든 파일이 공개된다. 사용자별 접근 권한 제어가 필요하다면, 컨트롤러에서 파일을 직접 읽어 `ResponseEntity<Resource>`로 스트리밍하는 더
      복잡한 방식이 필요하다.

---

## 오늘의 깨달음 💡

* 서버의 물리적 파일 경로는 외부에서 직접 접근할 수 없으며, `WebMvcConfigurer`의 `addResourceHandlers`를 통해 특정 URL 패턴과 매핑해야만 웹을 통해 접근할 수 있다.

* 사용자가 올린 원본 파일명을 그대로 사용하면 파일명 중복으로 인한 덮어쓰기 문제가 발생할 수 있다. `UUID`를 이용해 고유한 파일명을 생성하면 이 문제를 해결할 수 있다.

* 파일 업로드 기능 구현 시, 파일의 MIME 타입과 크기를 검증하는 것은 악성 파일 업로드를 막고 서버를 보호하기 위한 필수적인 보안 조치다.

* `MultipartFile` 객체는 파일의 바이너리 데이터뿐만 아니라, 원본 파일명, 크기, MIME 타입 등 파일과 관련된 다양한 메타데이터를 포함하고 있어 파일 처리에 필요한 대부분의 정보를 제공한다.

* 파일 저장 경로와 같은 주요 설정 값은 `application.yml`과 `@Value` 애너테이션을 통해 외부화하는 것이 좋다. 이를 통해 코드 수정 없이 설정 변경만으로 경로를 바꿀 수 있어 유지보수성이
  향상된다.