# TIL - 2025.07.21 - Spring 전역 예외 처리(@RestControllerAdvice) 및 사용자 정의 예외 설계 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #ExceptionHandling #RestControllerAdvice #CustomException #Logging

---

## 오늘 배운 내용 🔍

- `@ExceptionHandler`와 `@RestControllerAdvice`를 활용한 전역 예외 처리 메커-니즘
- 비즈니스 예외(4xx)와 시스템 예외(5xx)의 구분 및 사용자 정의 예외 설계
- 일관된 오류 응답을 위한 `ErrorResponse` DTO와 `ErrorCode` 열거형(Enum) 설계
- Service 계층의 책임(`throw`)과 ControllerAdvice의 책임(`catch` 및 응답 생성) 분리
- `@Slf4j`를 이용한 예외 상황별(WARN, ERROR) 로깅 전략

---

## 어려웠던 점 💣

* **`try-catch`의 반복 문제**: 처음에는 예외가 발생할 수 있는 모든 컨트롤러 메서드를 `try-catch` 블록으로 감싸야 한다고 생각했다. 하지만 동일한 예외 처리 코드가 여러 곳에 중복되는 것을
  보고, `@RestControllerAdvice`가 모든 예외를 한곳에서 통합 관리하는 방식이라는 것을 알게 되었다. 이는 AOP(관점 지향 프로그래밍)를 통해 관심사를 분리하는 방법이었다.

* **사용자 정의 예외의 필요성**: `Exception` 하나로 모든 예외를 처리하면 되는데, 왜 `MemberException`, `DuplicateEmailException`처럼 복잡하게 사용자 정의 예외를
  만들어야 하는지 의문이었다. 하지만 "회원을 찾을 수 없음"과 "계정명 길이 초과"는 원인과 해결 방법이 전혀 다른 문제임을 깨달았다. 각 상황에 맞는 구체적인 예외를 만드는 것은, 오류의 원인을 명확히 진단하고
  그에 맞는 처리를 하기 위함이었다.

* **예외 처리의 책임 분담**: `Service` 계층에서 예외를 `throw`하고, `Controller`에서 `try-catch`로 잡아 `ResponseEntity`를 만들어야 하는지 혼란스러웠다. 역할
  분담 관점에서, **Service는 비즈니스 규칙 위반 시 `throw`를 통해 문제를 알리는 역할에만 충실**하고, **`@RestControllerAdvice`가 그 문제를 잡아 클라이언트에게 보낼 최종
  응답(`ResponseEntity`)을 만드는 역할**을 전담하는 구조가 가장 책임 분리가 잘 된 설계였다.

* **로그 레벨의 구분 기준**: `WARN`과 `ERROR`를 언제 사용해야 할지 막연하게 느껴졌다. 이메일 중복처럼 **예상 가능하고, 비즈니스 규칙에 따른 예외는 `WARN`**으로 기록하고,
  `NullPointerException`처럼 **예상치 못했고 시스템 자체에 문제가 있을 수 있는 심각한 예외는 `ERROR`**로 기록하여 즉각적인 조치가 필요함을 알린다는 기준을 세울 수 있었다.

---

## 정리 🖇️

### 1. 전역 예외 처리: @RestControllerAdvice

애플리케이션 전반에 걸쳐 발생하는 예외를 한곳에서 통합 관리하여, 컨트롤러의 코드 중복을 제거하고 예외 처리 로직을 중앙 집중화하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  모든 컨트롤러 메서드에 `try-catch` 블록을 반복적으로 작성하는 것을 피하고, 예외 처리 로직을 단일 클래스에 모아 일관성 있고 유지보수하기 쉬운 코드를 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * `@RestControllerAdvice`: 모든 `@RestController` 전반에 걸쳐 적용되는 AOP(관점 지향 프로그래밍) 기반의 기능. 컨트롤러에서 발생하는 예외를 감지하고 가로채는 역할을
      하며, 반환하는 객체는 자동으로 JSON으로 변환된다.
    * `@ExceptionHandler(ExceptionType.class)`: `@RestControllerAdvice` 클래스 내에서, 특정 타입의 예외가 발생했을 때 해당 예외를 처리할 메서드를 지정하는
      애너테이션.

* **문법 및 사용법 (How?)**:
  ```java
  // GlobalExceptionHandler.java
  @RestControllerAdvice
  @Slf4j
  public class GlobalExceptionHandler {

      // 1. 직접 정의한 MemberException 타입의 예외를 전문적으로 처리
      @ExceptionHandler(MemberException.class)
      public ResponseEntity<ErrorResponse> handleMemberException(MemberException e) {
          log.warn("비즈니스 예외 발생: {}", e.getMessage());
          ErrorResponse response = new ErrorResponse(e.getErrorCode());
          return ResponseEntity.status(e.getErrorCode().getStatusCode()).body(response);
      }

      // 2. 위에서 잡지 못한 모든 예측 불가능한 예외는 여기서 처리 (Catch-all)
      @ExceptionHandler(Exception.class)
      public ResponseEntity<ErrorResponse> handleGlobalException(Exception e) {
          log.error("예상치 못한 서버 오류 발생!", e); // 스택 트레이스 포함 로깅
          ErrorResponse response = new ErrorResponse(ErrorCode.INTERNAL_SERVER_ERROR);
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `@ExceptionHandler`는 가장 구체적인 타입의 예외를 처리하는 핸들러가 우선적으로 선택된다. (`MemberException`은 `handleMemberException`이, 그 외
      `NullPointerException` 등은 `handleGlobalException`이 처리)
    * 핸들러 메서드의 파라미터로 `HttpServletRequest`를 받아오면, 예외가 발생한 요청의 URL 같은 추가 정보를 응답이나 로그에 포함시킬 수 있다.

---

### 2. 사용자 정의 예외와 응답 DTO 설계

단순히 `Exception`을 사용하는 것을 넘어, 비즈니스 상황에 맞는 구체적인 예외를 직접 정의하고, 클라이언트에게 일관된 형식의 오류를 응답하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  "무슨 에러가 발생했다"는 막연한 정보가 아닌, "왜(What) 에러가 발생했는지" 명확하게 표현하기 위함이다. 이를 통해 클라이언트는 오류 원인을 쉽게 파악할 수 있고, 서버는 오류 유형별로 체계적인 관리가
  가능해진다.

* **핵심 원리 (What?)**:
    * **사용자 정의 예외**: `RuntimeException`(Unchecked Exception)을 상속받아 특정 비즈니스 상황을 나타내는 예외 클래스를 직접 만드는 것. (e.g.,
      `MemberException`)
    * **`ErrorCode` 열거형(Enum)**: 오류 코드, HTTP 상태, 기본 메시지를 한곳에서 관리하여 일관성을 유지하고 코드 가독성을 높인다.
    * **`ErrorResponse` DTO**: 클라이언트에게 보낼 오류 응답의 형식을 정의한 객체. API 스펙의 일부가 되므로 신중하게 설계해야 한다.

* **문법 및 사용법 (How?)**:
    1. **`ErrorCode` Enum 정의**:
       ```java
       @Getter
       @AllArgsConstructor
       public enum ErrorCode {
           MEMBER_NOT_FOUND(404, "M001", "회원을 찾을 수 없습니다."),
           DUPLICATE_ACCOUNT(409, "M002", "이미 존재하는 계정입니다."),
           INTERNAL_SERVER_ERROR(500, "S001", "서버 내부 오류가 발생했습니다.");
           
           private final int statusCode;
           private final String errorCode;
           private final String message;
       }
       ```
    2. **사용자 정의 예외 클래스 정의**:
       ```java
       @Getter
       public class MemberException extends RuntimeException {
           private final ErrorCode errorCode;
   
           public MemberException(ErrorCode errorCode) {
               super(errorCode.getMessage());
               this.errorCode = errorCode;
           }
       }
       ```
    3. **Service 계층에서 예외 발생시키기(`throw`)**:
       ```java
       @Service
       public class MemberService {
           public Member findOneMember(String account) {
               return memberRepository.findByAccount(account)
                       .orElseThrow(() -> new MemberException(ErrorCode.MEMBER_NOT_FOUND));
           }
       }
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **Unchecked Exception 활용**: `RuntimeException`을 상속하는 Unchecked Exception으로 설계하면, Service 계층의 메서드에 `throws`를 일일이
      명시할 필요가 없어 코드가 간결해진다. 예외 처리는 `@RestControllerAdvice`에 위임한다.
    * **HTTP 상태 코드의 올바른 사용**: `400`(잘못된 요청), `401`(미인증), `403`(권한 없음), `404`(리소스 없음), `409`(데이터 충돌) 등 상황에 맞는 상태 코드를 사용하는
      것은 RESTful API 설계의 기본이다.

---

### 3. 예외 처리와 로깅(@Slf4j) 전략

문제 발생 시 원인을 추적하고 분석하기 위해, 예외 상황을 체계적으로 기록하는 방법을 학습했다. 로깅은 비행기의 '블랙박스'와 같은 역할을 한다.

* **학습 목표 (Why?)**:
  단순히 에러를 처리하고 끝내는 것이 아니라, 어떤 오류가, 언제, 어디서, 왜 발생했는지에 대한 상세한 기록을 남겨 사후 분석, 디버깅, 시스템 모니터링에 활용하기 위함이다.

* **핵심 원리 (What?)**:
    * **로그 레벨의 전략적 사용**:
      | 로그 레벨 | 상황 | 스택 트레이스 |
      | :--- | :--- | :--- |
      | `ERROR` | **예측하지 못한 시스템 장애**. 즉각적인 조치가 필요. (e.g., `NullPointerException`, `SQLException`) | ✅ **필수** |
      | `WARN` | **예측 가능한 비즈니스 문제**. 시스템 장애는 아니지만 주의가 필요한 상황. (e.g., 로그인 실패, 중복 데이터 요청) | ❌ 불필요 |
      | `INFO` | 주요 처리 흐름을 나타내는 일반 정보. (e.g., 서버 시작, 회원가입 완료) | ❌ 불필요 |

* **문법 및 사용법 (How?)**: `GlobalExceptionHandler`에서의 로깅 예시.
  ```java
  @RestControllerAdvice
  @Slf4j
  public class GlobalExceptionHandler {
      // 비즈니스 예외는 WARN 레벨로 기록
      @ExceptionHandler(MemberException.class)
      public ResponseEntity<?> handleMemberException(MemberException e) {
          log.warn("비즈니스 예외 발생: {}", e.getMessage());
          // ... 응답 처리
      }
  
      // 예상치 못한 모든 예외는 ERROR 레벨로 기록
      @ExceptionHandler(Exception.class)
      public ResponseEntity<?> handleGlobalException(Exception e) {
          // 문제 분석을 위해 스택 트레이스는 필수!
          log.error("예상치 못한 서버 오류 발생", e);

          // ... 응답 처리
      }
  }
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * **`{}` 플레이스홀더 사용**: `log.info("user: " + user.getName())` 보다 `log.info("user: {}", user.getName())` 방식이 성능상 유리하다.
    * **스택 트레이스 포함**: `log.error("메시지", exception 객체)`처럼 예외 객체를 마지막 인자로 넘겨주어야 전체 스택 트레이스가 로그에 기록된다.
    * **중복 로깅 금지**: 예외를 `catch`해서 로그를 남긴 뒤 다시 `throw`하면, 상위 핸들러에서 또 로그를 남겨 중복 기록이 발생할 수 있다. 예외 로깅은 책임지고 처리하는 최종 단계(주로
      `@RestControllerAdvice`)에서 한 번만 하는 것이 좋다.

---

## 오늘의 깨달음 💡

* `@RestControllerAdvice`와 `@ExceptionHandler`를 사용하면, 예외 처리 로직을 비즈니스 로직과 분리하여 한곳에서 중앙 관리할 수 있다. 이는 코드의 중복을 줄이고 유지보수성을
  높인다.

* 상황에 맞는 사용자 정의 예외 클래스와 `ErrorCode` 열거형을 설계하면, 예외 발생 시 더 구체적이고 유용한 정보를 전달할 수 있다. 이는 클라이언트와의 명확한 소통 규약이 된다.

* `RuntimeException`(Unchecked Exception)을 상속받아 사용자 정의 예외를 만들면, 메서드 시그니처에 `throws`를 반복적으로 선언하지 않아도 되므로 코드가 간결해진다.

* 로깅은 단순한 출력이 아니라, 문제 발생 시 원인을 추적하기 위한 중요한 기록이다. `WARN` 레벨은 예측된 비즈니스 문제에, `ERROR` 레벨은 예측하지 못한 시스템 장애에 사용하여 문제의 심각도를
  구분하고, `ERROR` 로깅 시에는 반드시 예외 스택 트레이스를 포함해야 원인 분석이 용이하다.