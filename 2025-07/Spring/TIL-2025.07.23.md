# TIL - 2025.07.23 - Spring JdbcTemplate을 이용한 데이터베이스 연동 및 리팩토링 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JDBC #JdbcTemplate #DataSource #RowMapper

---

## 오늘 배운 내용 🔍

- 순수 JDBC 프로그래밍의 반복적인 문제점 (리소스 관리, 예외 처리)
- 템플릿 콜백 패턴을 통해 반복 코드를 해결하는 `JdbcTemplate`의 역할
- `JdbcTemplate`의 주요 메서드: `update()`, `query()`, `queryForObject()`
- `RowMapper`를 이용하여 `ResultSet`의 데이터를 자바 객체로 매핑하는 방법
- `build.gradle` 및 `application.yml`을 통한 스프링 부트의 `DataSource` 및 `JdbcTemplate` 자동 설정

---

## 어려웠던 점 💣

* **반복적인 `try-catch-finally` 구조**: 순수 JDBC로 Repository를 구현할 때, 모든 메서드마다 `Connection`, `PreparedStatement`를 열고 닫는
  `try-catch-finally` 코드가 반복되어 지루하고 실수할 여지가 많았다. `JdbcTemplate`을 적용하자 이 모든 코드가 사라지고 핵심 로직만 남는 것을 보고, 템플릿 패턴의 강력함을 체감했다.

* **`RowMapper`의 람다식 형태**: `template.query(sql, (rs, rowNum) -> new Book(rs))` 코드에서 람다식이 갑자기 등장해 처음에는 당황스러웠다. 이 람다식이
  `ResultSet`의 각 행(row)을 순회하며 `Book` 객체로 변환해주는 '매핑 규칙'을 정의하는 `RowMapper` 인터페이스의 구현체라는 것을 이해하고 나서야 코드가 읽히기 시작했다.
  `while(rs.next())` 루프와 객체 생성 코드를 단 한 줄의 람다로 표현할 수 있었다.

* **`query`와 `queryForObject`의 차이**: 전체 조회를 할 때는 `query()`를, 단일 조회를 할 때는 `queryForObject()`를 사용했다. 만약 `queryForObject()`
  를 사용했는데 결과가 없거나 두 개 이상이면 어떻게 될지 궁금했다. `queryForObject()`는 결과가 **정확히 하나일 것이라고 확신할 때** 사용하며, 결과가 없으면
  `EmptyResultDataAccessException` 예외가 발생한다는 것을 알게 되었다. 메서드의 이름에 담긴 의도를 정확히 파악하고 사용해야 했다.

* **`DataSource`의 출처**: `new`로 생성한 적 없는 `DataSource` 객체를 Repository에서 주입받아 사용하는 것이 의아했다. `application.yml`에 DB 접속 정보를
  작성하면, 스프링 부트가 이를 읽어 `HikariCP` 커넥션 풀을 포함한 `DataSource` 빈을 자동으로 생성하고 컨테이너에 등록해준다는 것을 알게 되었다. 설정만으로 복잡한 객체를 바로 사용할 수 있다는
  점에서 스프링의 강력함을 느꼈다.

---

## 정리 🖇️

### 1. 순수 JDBC의 한계와 JdbcTemplate의 필요성

데이터베이스와 연동하기 위해 순수 JDBC API를 사용할 때 발생하는 문제점과 이를 해결하기 위한 `JdbcTemplate`의 등장 배경을 학습했다.

* **학습 목표 (Why?)**:
  순수 JDBC의 반복적인 상용구 코드(Boilerplate Code)를 제거하고, 개발자가 핵심 비즈니스 로직(SQL 실행 및 결과 처리)에만 집중할 수 있도록 하기 위함이다.

* **핵심 원리 (What?)**:
    * **순수 JDBC의 문제점**:
        1. **반복적인 코드**: 모든 DB 작업마다 `Connection` 열기, `PreparedStatement` 생성, 리소스 닫기(`finally`) 코드가 중복된다.
        2. **리소스 누수 위험**: `finally` 블록에서 리소스를 제대로 닫아주지 않으면, 커넥션이 계속 열려있어 시스템 장애로 이어질 수 있다.
        3. **번거로운 예외 처리**: `SQLException`(Checked Exception)을 처리하기 위한 코드가 길고 복잡하다.
    * **`JdbcTemplate`의 해결책 (템플릿 콜백 패턴)**: `JdbcTemplate`은 DB 커넥션을 얻고, `PreparedStatement`를 생성 및 실행하며, 최종적으로 리소스를 모두
      정리해주는 일련의 과정을 **템플릿**처럼 제공한다. 개발자는 이 템플릿의 비어있는 부분, 즉 **실행할 SQL**과 **결과를 객체로 매핑하는 로직(콜백)**만 채워 넣으면 된다.

* **문법 및 사용법 (How?)**: `BookJdbcRepository`(순수 JDBC)와 `BookSpringRepository`(JdbcTemplate)를 비교하면 그 효과를 명확히 알 수 있다.
    * **Before (순수 JDBC)**: `save` 메서드 하나를 구현하는 데 `try-catch`와 리소스 생성/정리 코드가 대부분을 차지한다.
      ```java
      public boolean save(Book book) {
          Connection conn = null;
          PreparedStatement pstmt = null;
          try {
              conn = dataSource.getConnection();
              String sql = "INSERT INTO ...";
              pstmt = conn.prepareStatement(sql);
              // ... 파라미터 바인딩 및 실행 ...
          } catch (SQLException e) {
              throw new RuntimeException(e);
          } finally {
              // ... 리소스 정리 ...
          }
      }
      ```
    * **After (JdbcTemplate)**: 핵심 로직인 `template.update()` 호출 한 줄로 끝난다.
      ```java
      public boolean save(Book book) {
          String sql = "INSERT INTO ...";
          return template.update(sql, book.getTitle(), ...) == 1;
      }
      ```

---

### 2. JdbcTemplate 주요 메서드와 RowMapper

`JdbcTemplate`을 사용하여 CRUD(Create, Read, Update, Delete) 작업을 수행하는 구체적인 방법을 학습했다.

* **학습 목표 (Why?)**:
  데이터를 생성/수정/삭제하는 작업과 조회하는 작업을 구분하여, 각 목적에 맞는 `JdbcTemplate`의 메서드를 올바르게 사용하기 위함이다.

* **핵심 원리 (What?)**:
  | 메서드 | 용도 | 반환 값 |
  | :--- | :--- | :--- |
  | `update()` | `INSERT`, `UPDATE`, `DELETE` 쿼리 실행. | `int` (영향을 받은 행의 수) |
  | `query()` | **여러 행**을 조회하는 `SELECT` 쿼리 실행. | `List<T>` (객체 목록) |
  | `queryForObject()`| **단 하나의 행**만 조회하는 `SELECT` 쿼리 실행. | `T` (단일 객체) |
    * **`RowMapper<T>`**: `ResultSet`의 데이터를 자바 객체 `T`로 변환하는 방법을 정의한 인터페이스. `mapRow(ResultSet rs, int rowNum)`라는 단일 추상
      메서드를 가지므로 람다식으로 간편하게 구현할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @Repository
  @RequiredArgsConstructor
  public class BookSpringRepository {
      private final JdbcTemplate template;

      // CUD: update() 사용
      public boolean deleteById(Long id) {
          String sql = "DELETE FROM BOOKS WHERE id = ?";
          return template.update(sql, id) == 1;
      }

      // 다중 행 조회: query()와 RowMapper 람다 사용
      public List<Book> findAll() {
          String sql = "SELECT * FROM books";
          return template.query(sql, (rs, rowNum) -> new Book(rs));
      }
  
      // 단일 행 조회: queryForObject() 사용
      public Book findById(Long id) {
          String sql = "SELECT * FROM books WHERE id = ?";
          try {
              return template.queryForObject(sql, (rs, rowNum) -> new Book(rs), id);
          } catch (EmptyResultDataAccessException e) {
              // 조회 결과가 없을 때 예외 발생 가능
              return null;
          }
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `queryForObject()`는 결과가 없으면 `EmptyResultDataAccessException`을 던지므로, `null`을 반환하고 싶다면 `try-catch`로 감싸줘야 한다.
    * `RowMapper`를 구현할 때, `new Book(rs)` 처럼 `ResultSet`을 받는 생성자를 엔티티에 미리 만들어두면 코드가 훨씬 간결해진다.

---

### 3. JdbcTemplate 사용을 위한 환경 설정

스프링 부트 프로젝트에서 `JdbcTemplate`을 사용하기 위해 필요한 의존성 추가와 설정 방법을 학습했다.

* **학습 목표 (Why?)**:
  스프링 부트의 자동 설정(Auto-configuration) 기능을 활용하여, 최소한의 설정으로 데이터베이스 연동 및 `JdbcTemplate` 사용 환경을 구축하기 위함이다.

* **핵심 원리 (What?)**:
    1. **`build.gradle` 의존성 추가**:
        * `spring-boot-starter-jdbc`: `JdbcTemplate`과 `DataSource`, `HikariCP` 커넥션 풀을 포함한다.
        * DB 드라이버: `mariadb-java-client` 등 실제 데이터베이스와 통신하기 위한 드라이버.
    2. **`application.yml` 설정**: `spring.datasource.*` 속성을 통해 DB 접속 정보를 명시한다.
    3. **스프링 부트의 자동 설정**: 애플리케이션 시작 시, 스프링 부트는 위 의존성과 설정을 감지하여 `DataSource` 빈과 `JdbcTemplate` 빈을 자동으로 생성하고 스프링 컨테이너에
       등록한다.

* **문법 및 사용법 (How?)**:
    * **`build.gradle`**
      ```groovy
      dependencies {
          implementation 'org.springframework.boot:spring-boot-starter-jdbc'
          runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
      }
      ```
    * **`application.yml`**
      ```yaml
      spring:
        datasource:
          driver-class-name: org.mariadb.jdbc.Driver
          url: jdbc:mariadb://localhost:3306/spring_db
          username: root
          password: your_password
      ```
    * **`Repository`에서 주입받아 사용**:
      ```java
      @Repository
      @RequiredArgsConstructor
      public class BookSpringRepository {
          private final JdbcTemplate template; // 자동 설정된 빈을 생성자 주입으로 사용
          // ...
      }
      ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 테스트 코드에서 `@SpringBootTest` 애너테이션을 사용하면, 실제 애플리케이션 실행 환경과 동일하게 컨테이너에 등록된 모든 빈을 `@Autowired`로 주입받아 통합 테스트를 수행할 수 있다.

---

## 오늘의 깨달음 💡

* `JdbcTemplate`을 사용하면 개발자는 DB 커넥션, PreparedStatement 생성, 리소스 정리 등 반복적이고 오류가 발생하기 쉬운 작업을 프레임워크에 위임할 수 있다. 이를 통해 핵심적인 SQL
  실행 및 결과 처리 로직에만 집중할 수 있다.

* 순수 JDBC 코드에서 반복적으로 나타나는 `try-catch-finally` 구조는 템플릿 콜백 패턴을 통해 효과적으로 추상화될 수 있다. `JdbcTemplate`이 바로 이 패턴의 구현체다.

* `RowMapper`에 람다식을 활용하면, `ResultSet`을 순회하며 자바 객체로 수동 매핑하던 기존의 명령형 코드를 간결한 선언형 코드로 대체할 수 있다.

* 스프링 부트의 자동 설정 기능은 `application.yml`의 설정 정보를 기반으로 `DataSource`나 `JdbcTemplate`과 같은 필수적인 빈들을 자동으로 생성하고 컨테이너에 등록해주므로,
  개발자는 복잡한 설정 없이 필요한 객체를 바로 주입받아 사용할 수 있다.