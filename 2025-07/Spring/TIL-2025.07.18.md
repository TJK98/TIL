# TIL - 2025.07.18 - 스프링 빈(Bean) 관리와 3계층 아키텍처(Controller-Service-Repository) 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #IoC #DI #SpringBean #Autowired #3TierArchitecture

---

## 오늘 배운 내용 🔍

- 스프링 IoC 컨테이너가 관리하는 객체, **스프링 빈(Bean)**의 정의와 싱글톤 스코프
- `@ComponentScan`과 스테레오타입 애너테이션(`@Component`, `@Service`, `@Repository`, `@Controller`)을 이용한 빈 자동 등록
- `@Autowired`를 이용한 의존성 주입(DI) 방식 비교 및 **생성자 주입**의 중요성
- `@Qualifier`를 활용하여 동일 타입의 빈 중에서 특정 빈을 명시적으로 선택하는 방법
- 관심사 분리를 위한 **3계층 아키텍처(Controller-Service-Repository)**의 역할과 데이터 흐름

---

## 어려웠던 점 💣

* **`@Autowired`의 위치**: 필드, 세터, 생성자 어디에나 `@Autowired`를 붙여도 동작하는 것을 보고 어떤 방식을 사용해야 할지 혼란스러웠다. 필드 주입이 코드가 가장 간결해 보였지만, *
  *생성자 주입**을 사용해야만 의존성을 `final`로 선언하여 **불변성**을 보장하고, 객체 생성 시점에 의존성이 누락되는 것을 컴파일 단계에서 막을 수 있다는 점을 배우고 나서야 왜 생성자 주입이 권장되는지
  명확히 이해할 수 있었다.

* **인터페이스 주입의 원리**: `UserService`에서 `UserRepository` 인터페이스 타입을 주입받는데, 실제로는 `UserMemoryRepository` 같은 구현 클래스의 객체가 어떻게
  주입되는지 그 원리가 궁금했다. 스프링 IoC 컨테이너가 `@Repository`가 붙은 구현 클래스를 미리 스캔해서 빈으로 등록해두었다가, `@Autowired` 요청이 오면 해당 인터페이스를 구현한 **유일한
  빈을 찾아 '알아서' 연결**해준다는 것을 알게 되었다.

* **동일 타입 빈의 충돌**: `UserRepository`를 구현한 `UserMemoryRepository`와 `UserDbRepository`를 둘 다 빈으로 등록하자, 스프링이 어떤 것을 주입해야 할지 몰라
  오류를 발생시키는 상황을 마주했다. 이때 `@Repository("memoryRepo")` 처럼 빈에 이름을 붙이고, 주입받는 곳에서 `@Qualifier("memoryRepo")`로 특정 이름을 지정해주니
  문제가 해결되었다.

* **DTO와 Entity의 분리 필요성**: 처음에는 `User`라는 Entity 객체 하나로 요청, DB 저장, 응답을 모두 처리하면 될 것이라 생각했다. 하지만 요청 시 필요한 데이터와 응답 시 제공해야 할
  데이터의 형태와 규칙이 다르다는 것을 깨달았다. `UserCreateRequest`, `UserResponse`, `User`처럼 역할을 나누는 것이 각 객체의 책임을 명확하게 하고, 민감한 데이터 노출을 막는
  안전하고 유연한 설계라는 것을 이해하게 되었다.

---

## 정리 🖇️

### 1. 스프링 빈(Bean)과 컴포넌트 스캔

스프링의 가장 근본적인 개념으로, 객체의 생성과 관리의 제어권이 개발자에서 프레임워크(컨테이너)로 역전되는 것을 학습했다.

* **학습 목표 (Why?)**:
  객체 간의 강한 결합(Coupling)을 끊어내고, 객체의 생성, 구성, 생명주기 관리를 스프링 컨테이너에 위임함으로써 유연하고 확장 가능한 애플리케이션을 구축하기 위함이다.

* **핵심 원리 (What?)**:
    * **스프링 빈(Bean)**: 스프링 **IoC(Inversion of Control) 컨테이너**에 의해 생성되고, 관리되며, 의존성이 주입되는 **객체**를 의미한다. 기본적으로 **싱글톤(
      Singleton)** 스코프로 관리되어, 컨테이너 내에서 해당 타입의 빈은 유일하게 하나만 생성된다.
    * **컴포넌트 스캔 (`@ComponentScan`)**: 설정 클래스에 명시된 `basePackages` 하위의 모든 클래스를 스캔하여, 특정 애너테이션이 붙은 클래스를 자동으로 빈으로 등록하는
      메커니즘이다.
    * **스테레오타입 애너테이션**: 컴포넌트 스캔의 대상이 됨을 표시하는 애너테이션들이다.
      | 애너테이션 | 계층 (Layer) | 역할 |
      | :--- | :--- | :--- |
      | `@Component`| - | 가장 기본이 되는 범용 컴포넌트. |
      | `@Controller`| Presentation Layer | HTTP 요청을 받고 응답을 처리. |
      | `@Service` | Business Layer | 핵심 비즈니스 로직을 구현. |
      | `@Repository`| Persistence Layer | 데이터베이스에 접근. DB 관련 예외를 스프링 예외로 변환. |

* **문법 및 사용법 (How?)**:
  ```java
  // AppConfig.java
  @Configuration
  @ComponentScan(basePackages = "com.example.project") // 이 패키지 아래를 스캔
  public class AppConfig {
  }

  // UserService.java
  @Service // ComponentScan이 이 클래스를 발견하고 'userService'라는 이름의 빈으로 등록
  public class UserService { /* ... */ }
  ```

---

### 2. 의존성 주입(DI): `@Autowired`와 생성자 주입

IoC 컨테이너가 관리하는 빈들 사이의 의존 관계를 자동으로 연결해주는 스프링의 핵심 기능을 학습했다.

* **학습 목표 (Why?)**:
  클래스가 필요한 의존 객체를 직접 생성(`new`)하지 않고 외부(컨테이너)로부터 주입받게 함으로써, 클래스 간의 결합도를 낮추고 단위 테스트가 용이한 코드를 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * `@Autowired`: 의존성 주입을 요청하는 애너테이션. 스프링 컨테이너는 주입 대상의 **타입과 일치하는 빈**을 찾아 자동으로 주입한다.
    * **생성자 주입 (Constructor Injection)**: **가장 권장되는 방식**. 생성자를 통해 의존성을 주입받는다.
    * `@Qualifier("빈이름")`: 주입하려는 타입의 빈이 컨테이너에 2개 이상일 때, 빈에 부여된 **특정 이름을 지정하여** 주입 대상을 명시한다.

* **문법 및 사용법 (How?)**:
  ```java
  @Service
  public class UserServiceImpl implements UserService {

      private final UserRepository userRepository; // 1. final로 불변성 확보

      // 2. 생성자를 통해 의존성 주입. 생성자가 하나뿐이면 @Autowired 생략 가능.
      // Lombok의 @RequiredArgsConstructor를 사용하면 이 생성자 코드를 자동으로 만들어준다.
      @Autowired
      public UserServiceImpl(@Qualifier("dbUserRepository") UserRepository userRepository) {
          this.userRepository = userRepository;
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **항상 생성자 주입을 사용해야 하는 이유**:
        1. **불변성**: `final` 키워드를 사용할 수 있어, 객체 생성 이후 의존성이 변경될 위험이 없다.
        2. **의존성 누락 방지**: 객체 생성 시점에 의존성이 주입되지 않으면 객체 자체가 생성되지 않으므로, `NullPointerException`을 원천적으로 방지할 수 있다.
        3. **순환 참조 발견**: `A -> B`, `B -> A`와 같은 순환 참조가 발생하면 애플리케이션 시작 시점에 에러를 발생시켜 문제를 조기에 발견할 수 있다.
        4. **테스트 용이성**: DI 프레임워크 없이도 순수 자바 코드로 테스트할 때 `new UserServiceImpl(new MockUserRepository())`와 같이 Mock 객체를 쉽게
           주입할 수 있다.

---

### 3. 3계층 아키텍처 (Controller - Service - Repository)

애플리케이션의 기능을 역할에 따라 3개의 논리적 계층으로 분리하는 설계 패턴이다.

* **학습 목표 (Why?)**:
  **관심사의 분리(Separation of Concerns)**를 통해 각 계층이 자신의 책임에만 집중하게 하여, 코드의 재사용성을 높이고 유지보수와 테스트를 용이하게 만들기 위함이다.

* **핵심 원리 (What?)**:
  | 계층 | 애너테이션 | 역할 및 책임 |
  | :--- | :--- | :--- |
  | **Controller** | `@Controller`, `@RestController` | **HTTP 요청/응답 처리**. 요청 파싱, 기본 검증, Service 호출, 결과(DTO)를 View나
  JSON으로 응답. |
  | **Service** | `@Service` | **핵심 비즈니스 로직 담당**. 트랜잭션 관리, 여러 Repository를 조합하여 기능 구현, Entity ↔ DTO 변환. |
  | **Repository**| `@Repository` | **데이터베이스와의 통신(영속성) 전담**. CRUD(Create, Read, Update, Delete) 작업 수행. |

* **데이터 흐름과 DTO**: 각 계층은 **DTO(Data Transfer Object)**를 통해 데이터를 주고받는다. Entity를 외부로 직접 노출하지 않아 API 스펙의 안정성을 높이고 민감 정보를
  보호한다.
    * `RequestDTO`: 클라이언트의 요청 데이터를 담는 객체. (`UserCreateRequest`)
    * `ResponseDTO`: 클라이언트에게 응답할 데이터를 담는 객체. (`UserResponse`)

* **문법 및 사용법 (How?)**:
  사용자(User) 생성 요청 처리 흐름 예시.
  ```java
  // 1. Controller: 요청을 받아 DTO로 변환하고 Service에 위임
  @RestController
  @RequiredArgsConstructor
  public class UserController {
      private final UserService userService;
      
      @PostMapping("/users")
      public ResponseEntity<?> createUser(@RequestBody UserCreateRequest dto) {
          UserResponse response = userService.createUser(dto); // Service 호출
          return ResponseEntity.ok(response);
      }
  }

  // 2. Service: DTO를 Entity로 변환하고 비즈니스 로직 처리 후 Repository에 저장 위임
  @Service
  @RequiredArgsConstructor
  public class UserService {
      private final UserRepository userRepository;

      public UserResponse createUser(UserCreateRequest dto) {
          User newUser = dto.toEntity(); // DTO -> Entity 변환
          // ... (중복 이메일 검사 등 비즈니스 로직) ...
          User savedUser = userRepository.save(newUser); // Repository 호출
          return UserResponse.from(savedUser); // Entity -> DTO 변환하여 반환
      }
  }
  
  // 3. Repository: 전달받은 Entity를 DB에 저장
  @Repository
  public class UserRepository {
      public User save(User user) {
          // ... (DB 저장 로직) ...
          return user;
      }
  }
  ```

---

## 오늘의 깨달음 💡

* 스프링 IoC 컨테이너는 `@Configuration` 설정이나 `@ComponentScan`을 통해 빈 설정 정보를 읽고, 객체의 생성, 관리, 의존성 주입을 대신 처리해준다.

* `@Bean`이나 `@Component`로 등록된 객체는 평범한 객체가 아니라, 스프링 컨테이너가 생명주기를 관리하는 특별한 객체인 '빈(Bean)'이 되며, 기본적으로 싱글톤으로 관리된다.

* 의존성 주입 방식 중 생성자 주입이 가장 권장되는 이유는, `final` 키워드를 통해 불변성을 확보하고, 필수 의존성이 누락되는 것을 컴파일 시점에 방지하며, 순환 참조 문제를 조기에 발견할 수 있기 때문이다.

* 3계층 아키텍처(Controller-Service-Repository)는 각 계층의 책임을 명확히 분리하여 코드의 유지보수성과 재사용성을 높이는 효과적인 설계 패턴이다. 의존성은 항상
  `Controller -> Service -> Repository` 방향으로 흘러야 한다.