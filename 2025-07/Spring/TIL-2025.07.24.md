# TIL - 2025.07.24 - Spring JdbcTemplate 기본 사용법과 RowMapper 활용 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JDBC #JdbcTemplate #RowMapper #Transactional

---

## 오늘 배운 내용 🔍

- `JdbcTemplate`을 이용한 CUD(Create, Update, Delete) 작업: `update()` 메서드 활용
- `JdbcTemplate`을 이용한 다양한 조회(Read) 작업: `query()`, `queryForObject()`
- `RowMapper`를 이용한 수동 객체 매핑과 `BeanPropertyRowMapper`를 이용한 자동 매핑
- `queryForObject()` 사용 시 발생할 수 있는 `EmptyResultDataAccessException` 처리 방법
- `@Transactional` 애너테이션을 활용한 테스트 데이터 격리 및 자동 롤백

---

## 어려웠던 점 💣

* **`update()` 메서드의 역할**: `update()`라는 메서드 이름 때문에 `UPDATE` 쿼리에만 사용되는 것으로 오해했다. `INSERT`, `DELETE` 등 데이터에 변경을 가하는 모든 작업에
  공통적으로 사용되며, 반환 값은 '영향받은 행의 수'라는 것을 알게 되었다.

* **`RowMapper`와 `BeanPropertyRowMapper`의 차이**: `RowMapper`를 람다식으로 직접 구현하는 방식과 `BeanPropertyRowMapper`를 사용하는 방식의 차이를
  구분해야 했다. `BeanPropertyRowMapper`는 DB 컬럼명과 자바 클래스 필드명이 규칙에 맞게 일치할 경우, 반복적인 매핑 코드를 자동으로 처리해주는 편리한 구현체임을 이해했다.

* **`queryForObject()`의 예외 처리**: 단일 행 조회 결과가 없을 때 `null`을 반환할 것으로 예상했지만, 실제로는 `EmptyResultDataAccessException` 예외가 발생하는
  것을 확인했다. 이 메서드는 결과가 정확히 하나일 것이라고 기대하는 상황에서 사용되며, 결과가 없거나 둘 이상인 경우는 예외적인 상황으로 처리한다는 설계 의도를 파악했다.

* **`@Transactional`의 동작**: `@Transactional` 애너테이션이 테스트 코드에 적용되었을 때, 각 테스트 메서드 실행 후 모든 데이터베이스 변경사항을 자동으로 롤백하여 테스트 간의
  독립성을 보장해준다는 것을 알게 되었다. 이를 통해 매번 깨끗한 상태에서 테스트를 실행할 수 있었다.

---

## 정리 🖇️

### 1. JdbcTemplate을 이용한 데이터 변경 (CUD)

`JdbcTemplate`을 사용하여 데이터베이스에 데이터를 삽입(Create), 수정(Update), 삭제(Delete)하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  데이터의 상태를 변경하는 모든 SQL(INSERT, UPDATE, DELETE)을 일관된 방식으로 처리하고, 각 작업의 성공 여부를 명확하게 확인하기 위함이다.

* **핵심 원리 (What?)**:
    * **`jdbcTemplate.update(sql, params...)`**: 데이터 변경(CUD)을 위한 핵심 메서드.
        * 첫 번째 인자로 실행할 SQL 문을, 두 번째 이후 인자로는 SQL의 `?` 파라미터에 순서대로 바인딩될 값들을 전달한다.
        * 메서드는 실행 후 **영향받은 행(row)의 개수**를 `int` 타입으로 반환한다. 이를 통해 작업의 성공 여부를 확인할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @Repository
  @RequiredArgsConstructor
  public class ProductRepository {
      private final JdbcTemplate template;

      // 1. 데이터 추가 (INSERT)
      public void save(Product product) {
          String sql = "INSERT INTO products (name, price, stock_quantity) VALUES (?, ?, ?)";
          template.update(sql, product.getName(), product.getPrice(), product.getStockQuantity());
      }

      // 2. 데이터 삭제 (DELETE)
      public boolean deleteById(Long productId) {
          String sql = "DELETE FROM products WHERE id = ?";
          int updatedRows = template.update(sql, productId);
          return updatedRows > 0; // 1개 이상의 행이 삭제되었다면 true
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `jdbcTemplate.update()`에 파라미터를 전달하면, 내부적으로 `PreparedStatement`를 사용하여 SQL 인젝션 공격을 안전하게 방지해준다.
    * `UPDATE`나 `DELETE` 쿼리 작성 시, `WHERE` 절에 조건을 명확하게 추가하여 의도치 않은 데이터가 변경되거나 삭제되지 않도록 주의해야 한다.

---

### 2. JdbcTemplate을 이용한 데이터 조회 (Read)

조회 목적(단일 값, 단일 행, 다중 행)에 따라 `JdbcTemplate`이 제공하는 다양한 조회 메서드를 학습했다.

* **학습 목표 (Why?)**:
  다양한 조회 요구사항에 맞춰 가장 적절하고 효율적인 메서드를 선택하여 사용하기 위함이다.

* **핵심 원리 (What?)**:
  | 메서드 | 용도 | 반환 값 | 특징 |
  | :--- | :--- | :--- | :--- |
  | `queryForObject(sql, type)`| **단일 값** 조회 (e.g., `COUNT`, `SUM`) | 지정된 타입(`type`)의 값 | - |
  | `queryForObject(sql, mapper)`| **단일 행** 조회 | `T` (단일 객체) | 결과가 없거나 2개 이상이면 예외 발생. |
  | `query(sql, mapper)` | **여러 행** 조회 | `List<T>` (객체 목록) | 결과가 없으면 빈 리스트 반환. |

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 다중 행 조회
  public List<Product> findAll() {
      String sql = "SELECT * FROM products";
      return template.query(sql, new BeanPropertyRowMapper<>(Product.class));
  }

  // 2. 단일 행 조회 - Optional로 감싸서 안전하게 처리
  public Optional<Product> findById(Long id) {
      String sql = "SELECT * FROM products WHERE id = ?";
      try {
          Product product = template.queryForObject(sql, new BeanPropertyRowMapper<>(Product.class), id);
          return Optional.of(product);
      } catch (EmptyResultDataAccessException e) {
          return Optional.empty(); // 결과가 없으면 빈 Optional 반환
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `queryForObject`를 사용할 때는 결과가 없을 수 있는 상황을 항상 고려해야 한다. `try-catch`로 `EmptyResultDataAccessException`을 처리하거나,
      `Optional`을 사용하여 `null` 안전성을 높이는 것이 좋다.
    * **이름 기반 파라미터**: `JdbcTemplate`과 함께 `NamedParameterJdbcTemplate`을 사용하면 `?` 대신 `:name`과 같은 이름 기반 파라미터를 사용할 수 있어,
      파라미터가 많은 복잡한 SQL에서 가독성과 안정성을 크게 높일 수 있다.

---

### 3. RowMapper의 이해와 활용

`ResultSet`의 로우 데이터를 자바 객체로 변환하는 `RowMapper`의 두 가지 주요 구현 방법을 학습했다.

* **학습 목표 (Why?)**:
  데이터베이스 조회 결과를 반복문으로 직접 처리하는 대신, 객체 지향적인 방식으로 손쉽게 자바 객체(또는 DTO)로 변환하기 위함이다.

* **핵심 원리 (What?)**:
    * **`RowMapper<T>`**: `ResultSet`의 한 행(row)을 순회하며 원하는 타입 `T`의 객체로 변환하는 규칙을 정의하는 인터페이스다.
    * **직접 구현 (람다식)**: `(rs, rowNum) -> { ... }` 형태로 `RowMapper`를 직접 구현한다. 복잡한 매핑 로직이나 커스텀 로직이 필요할 때 유용하다.
    * **`BeanPropertyRowMapper<T>`**: `RowMapper`의 편리한 구현체. **DB 컬럼명(snake_case)과 자바 클래스의 필드명(camelCase)이 일치하면, 자동으로 값을
      매핑**해준다.

* **문법 및 사용법 (How?)**:
  ```java
  // 1. BeanPropertyRowMapper를 사용한 자동 매핑 (권장)
  public List<Product> findAll() {
      String sql = "SELECT * FROM products";
      // Product 클래스의 필드명과 DB 컬럼명이 일치하므로 자동 매핑 가능
      return template.query(sql, new BeanPropertyRowMapper<>(Product.class));
  }

  // 2. 람다를 사용한 수동 매핑
  public Product findById_manual(Long id) {
      String sql = "SELECT id, name, price FROM products WHERE id = ?";
      return template.queryForObject(sql, (rs, rowNum) ->
          Product.builder()
              .id(rs.getLong("id"))
              .name(rs.getString("name"))
              .price(rs.getInt("price"))
              .build() // 필요한 필드만 선택적으로 매핑
      , id);
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `BeanPropertyRowMapper`를 사용하기 위해서는 매핑할 클래스에 **기본 생성자**가 반드시 필요하다.
    * 만약 컬럼명과 필드명이 다르다면, SQL 쿼리에서 `AS` 키워드를 사용하여 별칭(alias)을 필드명과 일치시켜주면 `BeanPropertyRowMapper`를 그대로 활용할 수 있다.

---

## 오늘의 깨달음 💡

* `JdbcTemplate`을 사용하면 개발자는 DB 커넥션, PreparedStatement 생성, 리소스 정리 등 반복적이고 오류가 발생하기 쉬운 작업을 프레임워크에 위임한다. 이를 통해 핵심적인 SQL 실행
  및 결과 처리 로직에만 집중할 수 있다.

* `update()` 메서드는 이름과 달리 `UPDATE` 쿼리뿐만 아니라, `INSERT`, `DELETE` 등 데이터베이스의 상태를 변경하는 모든 종류의 쿼리에 사용된다.

* `BeanPropertyRowMapper`는 DB 컬럼명과 자바 객체 필드명 사이의 네이밍 컨벤션(snake_case ↔ camelCase)을 지키면, 반복적인 `ResultSet` 매핑 코드를 자동으로
  처리해주는 매우 효율적인 도구다.

* `queryForObject()`는 조회 결과가 정확히 한 개일 것을 기대하는 메서드다. 결과가 없거나 여러 개일 경우 예외를 발생시키므로, `Optional`이나 `try-catch`를 이용한 예외 처리가
  필요하다.

* 테스트 코드에서 `@Transactional` 애너테이션을 사용하면, 각 테스트가 끝날 때마다 데이터베이스 변경사항을 자동으로 롤백하여 테스트 간의 독립성을 보장할 수 있다.