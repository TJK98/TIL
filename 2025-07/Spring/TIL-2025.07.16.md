# TIL - 2025.07.16 - Spring 서버 데이터 검증(Validation), DTO 설계 및 로깅 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #Validation #DTO #Logging #Slf4j #Jackson

---

## 오늘 배운 내용 🔍

- 계층 간 데이터 전송을 위한 DTO(Data Transfer Object)의 역할과 설계
- `@Valid`와 `BindingResult`를 이용한 서버 측 요청 데이터 유효성 검증
- 요청(Request) DTO와 응답(Response) DTO를 분리하는 이유와 장점
- Jackson 애너테이션(`@JsonProperty`, `@JsonIgnore`, `@JsonFormat`)을 이용한 응답 JSON 제어
- `Slf4j`와 Logback을 이용한 애플리케이션 로깅의 중요성과 사용법

---

## 어려웠던 점 💣

* **`BindingResult`의 자동 주입 원리**: 컨트롤러 메서드에서 `@Valid` DTO 파라미터 바로 뒤에 `BindingResult`를 선언하기만 하면 검증 결과가 담기는 내부 동작 원리가 궁금했다.
  이는 Spring의 `DispatcherServlet`이 `@Valid` 애너테이션을 인지하면, 컨트롤러 메서드를 호출하기 전에 먼저 검증을 수행하고 그 결과를 담을 `BindingResult` 객체를 생성하여
  뒤따르는 파라미터에 자동으로 주입해주는 것이었다. 프레임워크의 자동화된 기능임을 인지해야 했다.

* **Request/Response DTO 분리의 필요성**: 처음에는 `MemberDto` 하나로 요청과 응답을 모두 처리하면 될 것이라 생각했다. 하지만 회원 가입 시 필요한 데이터와 회원 목록 조회 시
  제공해야 할 데이터의 형태와 규칙이 다르다는 것을 깨달았다. 역할을 명확히 나누기 위해 DTO를 분리하는 것이 더 안전하고 유연한 설계임을 이해해야 했다.

* **`System.out.println`과 로깅의 차이**: `System.out.println()`은 단순히 콘솔에 문자열을 출력하는 기능이지만, `Slf4j`를 이용한 로깅은 **'누가, 언제, 어떤 심각도(
  레벨)로'** 남겼는지 체계적으로 기록하는 것이었다. 특히, 운영 환경에서는 로그 레벨 설정을 통해 성능 저하 없이 필요한 정보만 선택적으로 수집할 수 있다는 점에서 근본적인 차이가 있음을 알게 되었다.

---

## 정리 🖇️

### 1. 데이터 검증(Validation)과 Request DTO

클라이언트로부터 받은 데이터가 비즈니스 로직을 수행하기에 유효한지 서버 단에서 검증하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  잘못되거나 불완전한 데이터(e.g., 빈 비밀번호, 잘못된 이메일 형식)가 시스템에 저장되거나 처리되는 것을 원천적으로 차단하고, 애플리케이션의 안정성과 데이터 무결성을 확보하기 위함이다.

* **핵심 원리 (What?)**:
    * **DTO (Data Transfer Object)**: 계층 간 데이터 전송을 목적으로 하는 객체. **Request DTO**는 클라이언트의 요청 데이터를 캡슐화하고, 유효성 검증 규칙을 정의하는
      역할을 한다. Entity와 관심사를 분리하여 각자의 역할에 집중하게 만든다.
    * **`@Valid`**: 컨트롤러 메서드의 DTO 파라미터에 붙여, 해당 DTO에 정의된 유효성 검증 규칙을 활성화하라는 명령을 내린다.
    * **`BindingResult`**: `@Valid` 검증 과정에서 발생한 에러 정보를 담는 객체. 반드시 `@Valid` 파라미터 **바로 뒤**에 위치해야 한다. `BindingResult`가 있으면
      검증 실패 시 `400 Bad Request` 에러가 자동으로 발생하는 대신, 개발자가 직접 에러를 제어할 수 있는 기회를 얻게 된다.

* **문법 및 사용법 (How?)**:
    1. `build.gradle`에 `implementation 'org.springframework.boot:spring-boot-starter-validation'` 의존성을 추가한다.
    2. Request DTO 클래스의 필드에 검증 애너테이션을 적용한다.
       ```java
       @Getter @Setter @ToString
       public class MemberCreateRequest {
           @NotBlank @Email
           private String account;

           @NotBlank @Size(min = 4, max = 12)
           private String password;
           // ...
       }
       ```
    3. 컨트롤러에서 `@Valid`와 `BindingResult`를 사용하여 검증을 수행하고 결과를 처리한다.
       ```java
       @PostMapping
       public ResponseEntity<?> createMember(
               @RequestBody @Valid MemberCreateRequest dto,
               BindingResult bindingResult) {

           // 검증에 실패했는지 확인
           if (bindingResult.hasErrors()) {
               // 에러 정보를 가공하여 클라이언트에게 400 응답
               return ResponseEntity.badRequest().body(extractErrorMessages(bindingResult));
           }
           // ... (검증 통과 후 회원 생성 로직)
       }
       ```

---

### 2. Response DTO와 응답 JSON 제어

서버가 클라이언트에게 응답할 데이터의 형태를 제어하고, 민감한 정보를 보호하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  Entity 객체를 외부에 직접 노출하는 것의 위험성(불필요한 정보 노출, 내부 로직 변경 시 API 스펙 변경 등)을 피하고, 클라이언트의 요구사항에 맞는 구조와 형식으로 데이터를 가공하여 안전하게 전달하기
  위함이다.

* **핵심 원리 (What?)**:
    * **Response DTO**: 서버가 클라이언트로 보낼 응답 데이터를 담기 위한 전용 객체. Entity의 모든 필드를 그대로 보내는 것이 아니라, 필요한 데이터만 선별하거나 가공(예: 이름 마스킹,
      날짜 형식 변경)하여 포함시킨다.
    * **Jackson 애너테이션**: Spring Boot가 사용하는 Jackson 라이브러리는 객체를 JSON으로 변환(직렬화)할 때, 특정 애너테이션을 통해 그 과정을 세밀하게 제어할 수 있다.
      | 애너테이션 | 설명 |
      | :--- | :--- |
      | `@JsonProperty("newName")` | 필드명을 JSON `key`로 변환할 때 지정된 `newName`으로 변경한다. |
      | `@JsonIgnore` | 해당 필드를 JSON 응답에서 완전히 제외시킨다. (e.g., 비밀번호, 주민등록번호) |
      | `@JsonFormat(pattern = "...")`| `LocalDate`, `LocalDateTime` 같은 날짜/시간 타입의 필드를 지정된 패턴의 문자열로 변환한다. |

* **문법 및 사용법 (How?)**:
  ```java
  @Getter @Setter @Builder
  public class MemberListResponse {
      private String id;
      @JsonProperty("account_email") // JSON key를 "account_email"로 지정
      private String account;
      private String nickname;
      @JsonFormat(pattern = "yyyy-MM-dd HH:mm")
      private LocalDateTime joinDate;

      // Entity를 Response DTO로 변환하는 정적 팩토리 메서드
      public static MemberListResponse from(Member member) {
          return MemberListResponse.builder()
                  .id(member.getUid())
                  .account(member.getAccount())
                  .nickname(mask(member.getNickname())) // 이름 마스킹
                  .joinDate(member.getJoinDate())
                  .build();
      }

      private static String mask(String original) { /* ... 마스킹 로직 ... */ }
  }
  ```

---

### 3. Slf4j를 이용한 애플리케이션 로깅

`System.out.println()`을 대체하여, 애플리케이션의 상태와 동작을 체계적으로 기록하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순 출력이 아닌, 로그 레벨, 시간, 위치 등의 정보를 포함하는 구조화된 로그를 남겨 디버깅, 운영 모니터링, 장애 추적에 효과적으로 활용하기 위함이다.

* **핵심 원리 (What?)**:
    * **Slf4j (Simple Logging Facade for Java)**: 로깅에 대한 '표준 인터페이스' 역할을 하는 라이브러리. Spring Boot는 기본 구현체로 **Logback**을
      사용한다.
    * **로그 레벨 (Log Level)**: 로그의 중요도를 나타내는 등급. 설정된 레벨 이상의 로그만 출력된다. `ERROR > WARN > INFO > DEBUG > TRACE` 순서.
* **문법 및 사용법 (How?)**:
    1. 클래스에 Lombok의 `@Slf4j` 애너테이션을 붙이면 `log`라는 이름의 Logger 객체가 자동으로 생성된다.
       ```java
       @RestController
       @RequestMapping("/api/v5-3/members")
       @Slf4j // Logger 객체 자동 생성
       public class MemberController { ... }
       ```
    2. 각 레벨에 맞는 메서드를 호출하여 로그를 남긴다.
       ```java
       log.info("새로운 회원 가입 요청이 들어왔습니다. 요청 데이터: {}", dto);
       log.debug("검증 결과: 에러 없음");
       try {
           // ...
       } catch (Exception e) {
           log.error("회원 생성 중 심각한 서버 에러 발생!", e); // 예외 객체를 함께 넘기면 스택 트레이스도 기록됨
       }
       ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * 문자열을 `+`로 합치는 방식(`"data: " + dto`)보다 `{}` 플레이스홀더를 사용하는 것이 성능상 유리하다. 로그 레벨이 비활성화 상태일 때 불필요한 문자열 연산을 피할 수 있기 때문이다.
    * `application.properties` 또는 `application.yml` 파일에서 `logging.level.패키지경로=DEBUG` 와 같이 특정 패키지의 로그 레벨을 손쉽게 변경할 수 있다.
      개발 환경에서는 `DEBUG`, 운영 환경에서는 `INFO`로 설정하는 것이 일반적이다.

---

## 오늘의 깨달음 💡

* `@Valid`를 이용한 서버 측 데이터 검증은, 클라이언트가 보낸 데이터의 유효성을 서버가 직접 통제함으로써 시스템의 안정성과 데이터 무결성을 확보하는 중요한 장치임을 이해했다.

* 요청(Request)과 응답(Response)의 목적이 다르므로, 각각의 목적에 맞는 전용 DTO를 설계하고 사용하는 것이 계층 간의 역할을 명확히 하고, 외부 노출이 불필요한 데이터를 안전하게 보호하는 방법임을
  알게 되었다.

* `System.out.println()`은 일회성 확인에 그치지만, 로깅은 애플리케이션의 동작을 체계적으로 기록하여 디버깅 및 장애 추적에 활용할 수 있는 중요한 자산이다. 로그 레벨을 통해 상황에 맞는 기록을
  남기는 것이 효율적인 시스템 운영에 필수적임을 깨달았다.

* Spring 프레임워크는 `BindingResult`의 자동 주입처럼, 정해진 규칙을 따를 때 많은 반복적인 작업을 대신 처리해준다. 개발자는 프레임워크의 동작 원리를 이해하고, 핵심적인 비즈니스 로직에 더
  집중할 수 있다.