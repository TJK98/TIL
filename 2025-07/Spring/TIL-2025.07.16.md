# TIL - 2025.07.16 - Spring 서버 데이터 검증(Validation), DTO 설계 및 로깅 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #Validation #DTO #Logging #Slf4j #Jackson

---

## 오늘 배운 내용 🔍

- 계층 간 데이터 전송을 위한 DTO(Data Transfer Object)의 역할과 설계
- `@Valid`와 `BindingResult`를 이용한 서버 측 요청 데이터 유효성 검증
- 요청(Request) DTO와 응답(Response) DTO를 분리하는 이유와 장점
- Jackson 애너테이션(`@JsonProperty`, `@JsonIgnore`, `@JsonFormat`)을 이용한 응답 JSON 제어
- `Slf4j`와 Logback을 이용한 애플리케이션 로깅의 중요성과 사용법

---

## 어려웠던 점 💣

* **`BindingResult`의 출처**: 컨트롤러 메서드에서 `@Valid` DTO 파라미터 바로 뒤에 `BindingResult`를 선언하기만 하면 검증 결과가 '마법처럼' 담기는 내부 동작 원리가
  궁금했다. 이는 Spring의 `DispatcherServlet`이 `@Valid` 애너테이션을 인지하면, 컨트롤러 메서드를 호출하기 전에 먼저 검증을 수행하고 그 결과를 담을 `BindingResult` 객체를
  생성하여 뒤따르는 파라미터에 자동으로 주입해주는 것이었다. 프레임워크의 강력한 기능을 체감할 수 있었다.

* **Request/Response DTO를 분리하는 이유**: 처음에는 `MemberDto` 하나로 요청과 응답을 모두 처리하면 될 것이라 생각했다. 하지만 회원 가입 시에는 `account`,
  `password`를 받아야 하고, 회원 목록 조회 시에는 `password`는 숨기고 `nickname`은 마스킹하는 등, **요청 시 필요한 데이터와 응답 시 제공해야 할 데이터의 형태와 규칙이 다르다**는
  것을 깨달았다. 역할을 명확히 나누기 위해 `MemberCreateRequest`, `MemberListResponse`처럼 DTO를 분리하는 것이 더 안전하고 유연한 설계라는 것을 이해했다.

* **`sout`과 로깅의 근본적인 차이**: `System.out.println()`은 단순히 콘솔에 문자열을 출력하는 기능일 뿐이지만, `Slf4j`를 이용한 로깅은 **'누가(어떤 클래스), 언제, 어떤
  심각도(레벨)로'** 남겼는지 체계적으로 기록하는 '운항 기록 장치(블랙박스)'와 같다는 것을 알게 되었다. 특히, 운영 환경에서는 `DEBUG` 레벨 로그는 끄고 `INFO`나 `ERROR` 레벨만 활성화하여
  성능 저하 없이 필요한 정보만 선택적으로 수집할 수 있다는 점에서 `sout`과는 차원이 다른 기능임을 깨달았다.

---

## 정리 🖇️

### 1. 데이터 검증(Validation)과 Request DTO

클라이언트로부터 받은 데이터가 비즈니스 로직을 수행하기에 유효한지 서버 단에서 검증하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  잘못되거나 불완전한 데이터(e.g., 빈 비밀번호, 잘못된 이메일 형식)가 시스템에 저장되거나 처리되는 것을 원천적으로 차단하고, 애플리케이션의 안정성과 데이터 무결성을 확보하기 위함이다.

* **핵심 원리 (What?)**:
    * **DTO (Data Transfer Object)**: 계층 간 데이터 전송을 목적으로 하는 객체. **Request DTO**는 클라이언트의 요청 데이터를 캡슐화하고, 유효성 검증 규칙을 정의하는
      역할을 한다. Entity와 관심사를 분리하여 각자의 역할에 집중하게 만든다.
    * **`@Valid`**: 컨트롤러 메서드의 DTO 파라미터에 붙여, 해당 DTO에 정의된 유효성 검증 규칙을 활성화하라는 명령을 내린다.
    * **`BindingResult`**: `@Valid` 검증 과정에서 발생한 에러 정보를 담는 객체. 반드시 `@Valid` 파라미터 **바로 뒤**에 위치해야 한다. `BindingResult`가 있으면
      검증 실패 시 `400 Bad Request` 에러가 자동으로 발생하는 대신, 개발자가 직접 에러를 제어할 수 있는 기회를 얻게 된다.

* **문법 및 사용법 (How?)**:
    1. `build.gradle`에 `implementation 'org.springframework.boot:spring-boot-starter-validation'` 의존성을 추가한다.
    2. Request DTO 클래스의 필드에 검증 애너테이션을 적용한다.
       ```java
       @Getter @Setter @ToString
       public class MemberCreateRequest {
           @NotBlank @Email
           private String account;

           @NotBlank @Size(min = 4, max = 12)
           private String password;
           // ...
       }
       ```
    3. 컨트롤러에서 `@Valid`와 `BindingResult`를 사용하여 검증을 수행하고 결과를 처리한다.
       ```java
       @PostMapping
       public ResponseEntity<?> createMember(
               @RequestBody @Valid MemberCreateRequest dto,
               BindingResult bindingResult) {

           // 검증에 실패했는지 확인
           if (bindingResult.hasErrors()) {
               // 에러 정보를 가공하여 클라이언트에게 400 응답
               return ResponseEntity.badRequest().body(extractErrorMessages(bindingResult));
           }
           // ... (검증 통과 후 회원 생성 로직)
       }
       ```

---

### 2. Response DTO와 응답 JSON 제어

서버가 클라이언트에게 응답할 데이터의 형태를 제어하고, 민감한 정보를 보호하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  Entity 객체를 외부에 직접 노출하는 것의 위험성(불필요한 정보 노출, 내부 로직 변경 시 API 스펙 변경 등)을 피하고, 클라이언트의 요구사항에 맞는 구조와 형식으로 데이터를 가공하여 안전하게 전달하기
  위함이다.

* **핵심 원리 (What?)**:
    * **Response DTO**: 서버가 클라이언트로 보낼 응답 데이터를 담기 위한 전용 객체. Entity의 모든 필드를 그대로 보내는 것이 아니라, 필요한 데이터만 선별하거나 가공(예: 이름 마스킹,
      날짜 형식 변경)하여 포함시킨다.
    * **Jackson 애너테이션**: Spring Boot가 사용하는 Jackson 라이브러리는 객체를 JSON으로 변환(직렬화)할 때, 특정 애너테이션을 통해 그 과정을 세밀하게 제어할 수 있다.
      | 애너테이션 | 설명 |
      | :--- | :--- |
      | `@JsonProperty("newName")` | 필드명을 JSON `key`로 변환할 때 지정된 `newName`으로 변경한다. |
      | `@JsonIgnore` | 해당 필드를 JSON 응답에서 완전히 제외시킨다. (e.g., 비밀번호, 주민등록번호) |
      | `@JsonFormat(pattern = "...")`| `LocalDate`, `LocalDateTime` 같은 날짜/시간 타입의 필드를 지정된 패턴의 문자열로 변환한다. |

* **문법 및 사용법 (How?)**:
  ```java
  @Getter @Setter @Builder
  public class MemberListResponse {
      private String id;
      @JsonProperty("account_email") // JSON key를 "account_email"로 지정
      private String account;
      private String nickname;
      @JsonFormat(pattern = "yyyy-MM-dd HH:mm")
      private LocalDateTime joinDate;

      // Entity를 Response DTO로 변환하는 정적 팩토리 메서드
      public static MemberListResponse from(Member member) {
          return MemberListResponse.builder()
                  .id(member.getUid())
                  .account(member.getAccount())
                  .nickname(mask(member.getNickname())) // 이름 마스킹
                  .joinDate(member.getJoinDate())
                  .build();
      }

      private static String mask(String original) { /* ... 마스킹 로직 ... */ }
  }
  ```

---

### 3. Slf4j를 이용한 애플리케이션 로깅

`System.out.println()`을 대체하여, 애플리케이션의 상태와 동작을 체계적으로 기록하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순 출력이 아닌, 로그 레벨, 시간, 위치 등의 정보를 포함하는 구조화된 로그를 남겨 디버깅, 운영 모니터링, 장애 추적에 효과적으로 활용하기 위함이다.

* **핵심 원리 (What?)**:
    * **Slf4j (Simple Logging Facade for Java)**: 로깅에 대한 '표준 인터페이스' 역할을 하는 라이브러리. Spring Boot는 기본 구현체로 **Logback**을
      사용한다.
    * **로그 레벨 (Log Level)**: 로그의 중요도를 나타내는 등급. 설정된 레벨 이상의 로그만 출력된다. `ERROR > WARN > INFO > DEBUG > TRACE` 순서.
* **문법 및 사용법 (How?)**:
    1. 클래스에 Lombok의 `@Slf4j` 애너테이션을 붙이면 `log`라는 이름의 Logger 객체가 자동으로 생성된다.
       ```java
       @RestController
       @RequestMapping("/api/v5-3/members")
       @Slf4j // Logger 객체 자동 생성
       public class MemberController { ... }
       ```
    2. 각 레벨에 맞는 메서드를 호출하여 로그를 남긴다.
       ```java
       log.info("새로운 회원 가입 요청이 들어왔습니다. 요청 데이터: {}", dto);
       log.debug("검증 결과: 에러 없음");
       try {
           // ...
       } catch (Exception e) {
           log.error("회원 생성 중 심각한 서버 에러 발생!", e); // 예외 객체를 함께 넘기면 스택 트레이스도 기록됨
       }
       ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * 문자열을 `+`로 합치는 방식(`"data: " + dto`)보다 `{}` 플레이스홀더를 사용하는 것이 성능상 유리하다. 로그 레벨이 비활성화 상태일 때 불필요한 문자열 연산을 피할 수 있기 때문이다.
    * `application.properties` 또는 `application.yml` 파일에서 `logging.level.패키지경로=DEBUG` 와 같이 특정 패키지의 로그 레벨을 손쉽게 변경할 수 있다.
      개발 환경에서는 `DEBUG`, 운영 환경에서는 `INFO`로 설정하는 것이 일반적이다.

---

## 오늘의 깨달음 💡

* **서버는 '깐깐한 문지기'가 되어야 한다.** `@Valid`를 이용한 데이터 검증은, 클라이언트가 어떤 데이터를 보내든 무작정 받아들이는 것이 아니라, 서버가 정한 규칙에 맞는 '올바른 손님'만 안으로
  들여보내는 문지기의 역할과 같았다. 이 문지기 덕분에 내 애플리케이션의 내부 로직은 안전하게 보호받을 수 있다.

* **DTO는 '목적에 맞는 옷'이다.** 집에서 입는 옷(Entity)과 외출할 때 입는 옷(Response DTO)이 다르듯, 데이터도 목적에 따라 다른 옷을 입어야 했다. 내부적으로는 모든 정보를 가진
  Entity를 사용하더라도, 외부에 보여줄 때는 민감한 정보는 가리고 필요한 정보만 예쁘게 가공한 Response DTO를 입혀 내보내야 한다는 것을 깨달았다.

* **로그는 미래의 나에게 보내는 '편지'다.** `System.out.println()`은 허공에 외치는 소리와 같아서 금방 사라지지만, `log.error()`나 `log.info()`는 문제가 발생했을 때 "
  그때 상황은 이랬어"라고 알려주는 상세한 편지와 같았다. 지금 조금 귀찮더라도 로그를 꼼꼼히 남기는 것이, 미래에 발생할 알 수 없는 버그로부터 나를 구해줄 것이라는 확신이 들었다.

* **프레임워크는 '규칙'을 통해 '자유'를 준다.** `@Valid` 뒤에 `BindingResult`를 두는 것과 같은 규칙을 지키면, 개발자는 번거로운 검증 객체 생성이나 주입 과정 없이 핵심 로직에만 집중할
  수 있는 자유를 얻게 된다. 프레임워크의 동작 원리를 이해하는 것이 중요한 이유다.