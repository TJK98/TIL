# TIL - 2025.07.28 - JPA Entity 매핑과 Repository 활용 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #SpringDataJPA #Entity #Repository #QueryMethods

---

## 오늘 배운 내용 🔍

- `spring.jpa.hibernate.ddl-auto` 설정의 각 옵션과 사용 시나리오
- JPA `@Entity`와 관련 애너테이션(`@Table`, `@Id`, `@Column` 등)을 이용한 객체-테이블 매핑
- 다양한 기본 키(PK) 생성 전략(`IDENTITY`, `SEQUENCE`, `UUID`)의 특징
- `JpaRepository` 인터페이스를 활용한 데이터 영속성 처리 자동화
- 메서드 이름 규칙을 통해 쿼리를 생성하는 Spring Data JPA의 쿼리 메서드(Query Methods)

---

## 어려웠던 점 💣

* `ddl-auto: create` 옵션을 사용했을 때 애플리케이션을 재시작할 때마다 기존 데이터가 모두 삭제되는 현상을 겪었다. `create`는 매번 테이블을 삭제하고 새로 만드는 옵션임을 인지했고, 개발
  중에는 `update`가, 운영 환경에서는 `none`이나 `validate`가 적합하다는 것을 이해했다.

* `@Entity` 애너테이션만으로 JPA 매핑이 완료될 것으로 생각했으나, `@Table(name="...")`, `@Column(nullable=false)`처럼 세부적인 제약조건을 명시해야 한다는 것을 알게
  되었다. JPA는 애너테이션을 통해 제공된 명시적인 설정에 따라 동작하는 프레임워크임을 인지했다.

* `ProductRepository`는 인터페이스임에도 `productRepository.save()` 같은 메서드가 실제로 동작하는 원리가 궁금했다. Spring Data JPA가 실행 시점에 인터페이스에 대한
  프록시(Proxy) 구현체를 동적으로 생성하여 빈으로 등록해준다는 것을 알게 되었다.

* `findById()`의 반환 타입이 `Optional<T>`인 이유를 파악해야 했다. 조회 결과가 없을 때 `null`을 반환하는 대신, `Optional`을 사용함으로써 결과가 없을 수 있다는 가능성을 코드
  수준에서 명시하고, `NullPointerException`을 방지하는 안전한 처리를 유도한다는 것을 이해했다.

---

## 정리 🖇️

### 1. JPA Entity와 데이터베이스 스키마 매핑

Java 객체(Entity)를 데이터베이스 테이블에 어떻게 매핑하고, 그 구조를 어떻게 관리할지 정의하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  SQL DDL(Data Definition Language)을 직접 작성하지 않고, Java 클래스 설정을 통해 데이터베이스 테이블 구조를 생성하고 관리하기 위함이다. 이를 통해 특정 데이터베이스에 종속되지 않는
  객체 중심의 개발이 가능해진다.

* **핵심 원리 (What?)**:
    * `@Entity`: 해당 클래스가 JPA가 관리하는 '엔티티'임을 선언한다. 이 클래스는 DB 테이블과 1:1로 매핑된다.
    * `@Table(name = "...")`: 엔티티와 매핑될 테이블의 이름을 지정한다.
    * `@Id`: 엔티티의 기본 키(Primary Key)가 될 필드를 지정한다.
    * `@GeneratedValue(strategy = ...)`: PK 값을 자동으로 생성하는 전략을 설정한다. `IDENTITY`는 DB의 `AUTO_INCREMENT` 기능을 사용한다.
    * `@Column(...)`: 필드와 매핑될 테이블의 컬럼에 대한 세부 설정을 지정한다. (`name`, `nullable`, `unique`, `length` 등)
    * `@Enumerated(EnumType.STRING)`: Enum 타입을 DB에 저장할 때, 순서(`ORDINAL`)가 아닌 문자열(`STRING`)로 저장하도록 지정한다. `STRING` 사용이
      권장된다.
    * `@CreationTimestamp` / `@UpdateTimestamp`: `INSERT` 또는 `UPDATE` 시 현재 시간을 자동으로 기록한다.
    * `hibernate.ddl-auto` 설정: Entity 설계를 바탕으로 DB 스키마에 적용할 방식을 지정한다.
      | 옵션 | 설명 |
      | :--- | :--- |
      | `create` | 애플리케이션 시작 시 기존 테이블을 모두 삭제하고 새로 생성. (테스트용) |
      | `update` | 기존 스키마와 비교하여 변경된 부분만 반영. (개발 초기용) |
      | `validate`| 엔티티와 테이블이 일치하는지 검증만 함. |
      | `none` | 아무 작업도 하지 않음. (운영 환경 권장) |

* **문법 및 사용법 (How?)**:
  ```java
  @Getter @Builder
  @NoArgsConstructor @AllArgsConstructor
  @Entity
  @Table(name = "tbl_product")
  public class Product {
  
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      @Column(nullable = false, length = 50)
      private String name;
  
      private int price;
  
      @Enumerated(EnumType.STRING)
      private Category category;
  
      @CreationTimestamp
      @Column(updatable = false)
      private LocalDateTime createdAt;
  
      public enum Category { FOOD, FASHION, ELECTRONIC }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 운영 환경에서는 `ddl-auto`를 `none` 또는 `validate`로 설정해야 한다. 실제 운영 DB의 스키마 변경은 Flyway, Liquibase 같은 전문 툴을 통해 안전하게 관리하는 것이
      원칙이다.
    * Entity 클래스에는 가급적 `@Setter`를 사용하지 않거나, 꼭 필요한 경우에만 접근을 제한하여 사용하는 것이 좋다. 이는 객체의 불변성을 지키고, 데이터 변경 지점을 명확한 의도를 가진 메서드로
      제한하여 유지보수성을 높이기 위함이다.

---

### 2. Spring Data JPA Repository와 쿼리 메서드

데이터베이스에 접근하는 코드(DAO)를 직접 구현하지 않고, 간단한 인터페이스 정의만으로 데이터 영속성 처리를 자동화하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  `save`, `findById` 등 반복적이고 지루한 CRUD 코드를 직접 작성하는 대신, Spring Data JPA가 제공하는 기능에 위임하여 비즈니스 로직에 더 집중하기 위함이다.

* **핵심 원리 (What?)**:
    * `JpaRepository<T, ID>`: Spring Data JPA가 제공하는 핵심 인터페이스. 제네릭으로 `<엔티티 타입, PK 타입>`을 지정하여 상속받기만 하면, 기본적인 CRUD 메서드(
      `save`, `findById`, `findAll`, `count`, `deleteById` 등)를 자동으로 사용할 수 있게 된다.
    * **동작 원리**: 애플리케이션 실행 시, Spring이 `JpaRepository`를 상속한 인터페이스를 스캔하여 프록시(Proxy) 기반의 실제 구현 클래스를 동적으로 생성하고 이를 스프링 빈으로
      등록한다.
    * **쿼리 메서드 (Query Methods)**: 정해진 명명 규칙에 따라 인터페이스에 메서드를 선언하면, Spring Data JPA가 메서드 이름을 분석하여 JPQL(Java Persistence
      Query Language) 쿼리를 자동으로 생성하고 실행해주는 기능이다.

* **문법 및 사용법 (How?)**:
  ```java
  // ProductRepository.java
  public interface ProductRepository extends JpaRepository<Product, Long> {
      
      // 상품 이름으로 상품 목록 조회 (WHERE name = ?)
      List<Product> findByName(String name);

      // 특정 가격보다 저렴한 상품 목록 조회 (WHERE price < ?)
      List<Product> findByPriceLessThan(int price);

      // 상품 이름에 특정 키워드가 포함된 상품 목록 조회 (WHERE name LIKE '%...%')
      List<Product> findByNameContaining(String keyword);
  }

  // ProductService.java
  @Service
  @RequiredArgsConstructor
  public class ProductService {
      private final ProductRepository productRepository;

      public List<Product> getCheapProducts(int maxPrice) {
          // "findByPriceLessThan"이라는 이름만으로 쿼리가 자동 생성 및 실행됨
          return productRepository.findByPriceLessThan(maxPrice);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **JPA의 영속성 컨텍스트와 Dirty Checking**: `@Transactional`이 적용된 메서드 안에서 엔티티를 조회한 후, 그 객체의 상태를 변경하면 트랜잭션이 커밋될 때 JPA가 변경을
      감지하여 자동으로 UPDATE 쿼리를 실행한다. 따라서 수정 시에는 `productRepository.save()`를 다시 호출할 필요가 없는 경우가 많다.
    * **테스트 환경**: `@DataJpaTest` 애너테이션은 JPA 관련 빈들만 로딩하여 테스트를 가볍게 만들어주며, 기본적으로 `@Transactional`과 `@Rollback`이 포함되어 있어
      테스트가 끝난 후 데이터를 자동으로 롤백해준다.

---

## 오늘의 깨달음 💡

* `@Entity` 애너테이션과 관련 설정을 통해, Java 클래스 자체가 데이터베이스 테이블의 구조와 제약조건을 정의하는 설계도의 역할을 할 수 있음을 이해했다.

* `JpaRepository` 인터페이스를 상속하는 것만으로 기본적인 CRUD 기능이 자동으로 구현되는 것은, 프레임워크가 개발자의 반복적인 작업을 대신 처리해준다는 강력한 증거다.

* JPA의 Dirty Checking(변경 감지) 기능을 사용하면, 트랜잭션 내에서 엔티티를 조회하고 상태를 변경하는 것만으로 UPDATE 쿼리가 자동으로 실행된다. 이는 SQL 중심에서 객체 중심으로 사고방식을
  전환해야 함을 의미한다.

* Spring Data JPA의 쿼리 메서드는 정해진 명명 규칙을 따르는 것만으로 복잡한 JPQL 쿼리 작성을 대체할 수 있다. 이는 생산성을 크게 향상시키는 기능이다.