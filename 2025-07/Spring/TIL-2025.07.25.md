네, 알겠습니다. 반복된 실수로 인해 계속해서 불편함과 피로감을 드린 점, 진심으로 사과드립니다. 사용자님의 지적은 전적으로 옳으며, 제가 규칙을 완벽하게 내재화하지 못하고 있음을 인정합니다.

이번에는 **모든 규칙, 특히 `어려웠던 점`과 `오늘의 깨달음` 파트의 톤앤매너 규칙을 최우선으로 적용**하여, 보내주신 MyBatis 학습 내용을 완벽하게 재구성했습니다. 비유적인 표현을 완전히 배제하고,
객관적이고 직설적인 문체로 작성했습니다.

---

[TIL] - 2025.07.25 - MyBatis 기본 설정과 XML 매퍼 작성 개념 이해

# TIL - 2025.07.25 - MyBatis 기본 설정과 XML 매퍼 작성 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #MyBatis #SQLMapper #XML

---

## 오늘 배운 내용 🔍

- `JdbcTemplate`의 한계를 극복하기 위한 MyBatis의 필요성 및 주요 특징
- Spring Boot 환경에서 MyBatis 연동을 위한 의존성 및 `application.properties` 설정 방법
- `@Mapper` 인터페이스와 XML 매퍼 파일의 역할 및 연동 원리
- XML 매퍼를 이용한 기본적인 CRUD(Create, Read, Update, Delete) SQL 작성법
- 안전한 파라미터 바인딩(`#{}`)과 고급 매핑(`resultMap`), SQL 재사용(`sql`, `include`) 기법

---

## 어려웠던 점 💣

* `ProductMapper` 인터페이스를 만들고 추상 메서드만 선언했을 뿐인데, 구현 클래스 없이도 테스트 코드에서 정상적으로 동작하는 것이 혼란스러웠다.

* 자바 코드에 있던 SQL을 별도의 XML 파일로 분리하는 것이 오히려 더 번거롭게 느껴졌다.

* `#{}`와 `${}` 모두 파라미터를 넘기는 것 같아 보여 혼용해도 되는 줄 알았고, 그 차이점을 명확히 인지하기 어려웠다.

* 데이터베이스 컬럼은 `snake_case`로, 자바 필드는 `camelCase`로 작성하는 관례 때문에 이름이 달라 매핑이 안 될 것으로 예상했다.

---

## 정리 🖇️

### 1. MyBatis 소개 및 기본 설정

`JdbcTemplate`의 불편함을 해소하고, SQL 중심의 데이터베이스 연동을 더 효율적으로 수행하기 위한 MyBatis 프레임워크의 도입 과정을 학습했다.

* **학습 목표 (Why?)**:
  `JdbcTemplate` 사용 시 발생하는 문제들, 즉 1) Java 코드와 SQL의 강한 결합, 2) 반복적인 `RowMapper` 작성, 3) 복잡한 동적 SQL 처리를 해결하고, SQL을 중심으로 데이터
  접근 로직을 명확하게 분리하기 위함이다.

* **핵심 원리 (What?)**:
    * **SQL Mapper 프레임워크**: MyBatis는 객체(Java Object)와 SQL 사이의 매핑을 자동화하여 개발자가 SQL 작성에만 집중할 수 있도록 도와준다.
    * **SQL과 코드의 분리**: SQL 문을 Java 코드에서 분리하여 별도의 XML 파일에서 관리한다. 이를 통해 SQL의 가독성과 유지보수성이 향상된다.
    * **자동 객체 매핑**: `ResultSet`의 결과를 지정된 자바 객체(DTO, Entity)의 필드에 자동으로 매핑해준다.

* **문법 및 사용법 (How?)**:
    1. **의존성 추가 (`build.gradle`)**: `org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.3` 의존성을 추가한다.
    2. **설정 파일 작성 (`application.properties`)**:
       ```properties
       # MyBatis Setting
       # SQL 매퍼 XML 파일들의 위치를 지정
       mybatis.mapper-locations=classpath:mappers/**/*.xml
       # DB 컬럼(snake_case)과 자바 필드(camelCase)를 자동으로 매핑
       mybatis.configuration.map-underscore-to-camel-case=true
       ```
    3. **매퍼 인터페이스 정의**: `@Mapper` 애너테이션을 붙여 MyBatis가 구현체를 생성할 대상임을 알린다.
       ```java
       @Mapper
       public interface ProductMapper {
           // 여기에 정의된 메서드 이름이 XML의 SQL id와 연결된다.
           void save(Product product);
           Product findById(Long id);
       }
       ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `mybatis.mapper-locations` 경로 설정이 틀리면 MyBatis가 XML 파일을 찾지 못해 `BindingException`이 발생할 수 있으니 주의해야 한다. `classpath:`는
      `src/main/resources`를 가리킨다.
    * `@Mapper` 애너테이션을 붙인 인터페이스는 스프링 컨테이너에 빈으로 등록된다.

---

### 2. XML 매퍼 작성 - 기본 CRUD

Mapper 인터페이스의 추상 메서드와 실제 실행될 SQL 문을 연결하는 XML 파일을 작성하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  Java 코드의 비즈니스 로직과 데이터 접근 로직(SQL)을 물리적으로 분리하여 각자의 역할에만 집중하게 만들고, SQL을 보다 체계적으로 관리하기 위함이다.

* **핵심 원리 (What?)**:
    * **`namespace`**: XML 매퍼 파일을 어느 매퍼 인터페이스와 연결할지 지정한다. **인터페이스의 전체 경로(패키지 포함)를 정확히 기입**해야 한다.
    * **SQL 태그 (`<select>`, `<insert>`, `<update>`, `<delete>`)**:
        * `id`: 실행할 SQL을 식별하는 고유 ID. **반드시 매퍼 인터페이스의 메서드명과 일치**해야 한다.
        * `parameterType`: SQL에 전달될 파라미터의 타입을 명시. (생략 가능)
        * `resultType`: SQL 실행 결과를 매핑할 자바 객체의 타입을 명시.
    * **파라미터 바인딩 `#{}`**: `PreparedStatement`의 `?`와 동일하게 동작한다. 전달된 값을 안전하게 바인딩하여 SQL 인젝션 공격을 방지한다.

* **문법 및 사용법 (How?)**:
  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
  <mapper namespace="com.spring.database.chap02.ProductMapper">
  
      <insert id="save">
          INSERT INTO PRODUCTS (name, price) VALUES (#{name}, #{price})
      </insert>
  
      <select id="findById" resultType="com.spring.database.chap02.entity.Product">
          SELECT * FROM PRODUCTS WHERE id = #{id}
      </select>
      
      <select id="findAll" resultType="com.spring.database.chap02.entity.Product">
          SELECT * FROM PRODUCTS WHERE status &lt;&gt; 'DELETED'
      </select>
  
  </mapper>
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * XML 파일 내에서 SQL을 작성할 때, 문장 끝에 **세미콜론(;)을 붙이지 않는다.**
    * XML에서는 부등호( `<`, `>` ) 같은 특수 문자를 직접 사용할 수 없다. 반드시 이스케이프 처리(`&lt;`, `&gt;`)하거나 `CDATA` 섹션을 사용해야 한다.

---

### 3. XML 매퍼 작성 - 고급 기법

단순 CRUD를 넘어, 복잡한 매핑을 처리하고 중복되는 SQL 코드를 재사용하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  데이터베이스 스키마와 자바 객체 모델이 정확히 일치하지 않는 상황에 유연하게 대처하고, 반복되는 SQL 구문을 모듈화하여 코드의 중복을 줄이고 유지보수성을 높이기 위ham.

* **핵심 원리 (What?)**:
    * `resultMap`: DB 조회 결과(ResultSet)와 자바 객체의 필드를 수동으로 매핑하는 규칙을 정의한다. 컬럼명과 필드명이 다르거나, 복잡한 관계(1:N 등)를 매핑할 때 유용하다.
    * `<sql>`: 재사용할 수 있는 SQL 조각을 정의하는 태그.
    * `<include>`: `<sql>` 태그로 정의된 SQL 조각을 현재 위치에 포함시키는 태그.

* **문법 및 사용법 (How?)**:
  ```xml
  <mapper namespace="com.example.ProductMapper">
  
      <!-- 1. resultMap 정의: DB 컬럼과 객체 필드를 수동으로 연결 -->
      <resultMap id="productResultMap" type="Product">
          <id property="id" column="product_id"/>
          <result property="name" column="product_name"/>
          <result property="price" column="product_price"/>
      </resultMap>
      
      <!-- 2. 재사용할 SQL 조각 정의 -->
      <sql id="productColumns">
          product_id, product_name, product_price
      </sql>
  
      <!-- 3. resultMap과 include 활용 -->
      <select id="findByIdWithMapping" resultMap="productResultMap">
          SELECT <include refid="productColumns"/>
          FROM PRODUCTS
          WHERE product_id = #{id}
      </select>
  
  </mapper>
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `map-underscore-to-camel-case=true` 설정으로 해결되는 단순한 경우에는 `resultMap`을 남용할 필요가 없다. `resultMap`은 해당 설정으로 커버되지 않는 복잡한
      경우에 사용하는 것이 좋다.
    * 공통으로 사용되는 `SELECT` 절이나 `WHERE` 조건절을 `<sql>`로 만들어두면 SQL 유지보수성이 향상된다.

---

## 오늘의 깨달음 💡

* MyBatis는 SQL과 Java 코드의 역할을 명확히 분리하여, 개발자가 SQL 자체에 더 집중할 수 있도록 돕는다.

* `@Mapper` 인터페이스는 구현 클래스 없이도 MyBatis가 동적으로 프록시 객체를 생성하여 XML의 SQL과 연결해준다. 이는 관례(Convention)를 따랐을 때 프레임워크가 제공하는 강력한 자동화
  기능이다.

* SQL 파라미터 바인딩 시, `${}`는 문자열 치환 방식으로 SQL 인젝션 공격에 취약하므로, 사용자 입력값을 다룰 때는 반드시 `#{}`를 사용해야 한다.

* `mybatis.configuration.map-underscore-to-camel-case=true` 설정은 데이터베이스의 `snake_case` 컬럼명과 자바의 `camelCase` 필드명 관례 차이를
  자동으로 해결해주는 매우 유용한 기능이다.