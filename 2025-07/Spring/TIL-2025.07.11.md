# TIL - 2025.07.11 - Java 웹 개발 발전사: JSP, MVC 패턴, Spring Framework 입문 개념 이해

## 카테고리 🏷️

#TIL #Java #Web #JSP #MVC #Servlet #SpringFramework #SpringBoot #IoC

---

## 오늘 배운 내용 🔍

- JSP(JavaServer Pages)의 기본 문법 (`<%-- --%>`, `<%= %>`, `<% %>`)과 한계
- 관심사 분리를 위한 MVC(Model-View-Controller) 디자인 패턴의 개념과 필요성
- 서버 내부에서 제어권을 넘기는 뷰 포워딩(Forward)과 클라이언트에게 재요청을 유도하는 리다이렉트(Redirect)의 차이
- JSP에서 자바 코드를 제거하는 JSTL(JSP Standard Tag Library)과 EL(Expression Language)
- Spring Framework의 등장 배경과 핵심 철학 (IoC/DI, AOP)
- Spring Boot를 통한 설정의 자동화와 프로젝트 간소화
- Spring MVC의 핵심 애너테이션 (`@Controller`, `@RequestMapping`, `@RequestParam` 등)

---

## 어려웠던 점 💣

* **JSP와 MVC 패턴의 연결고리**: JSP 파일 하나만으로도 요청 처리와 화면 렌더링이 모두 가능해 보이는데, 왜 굳이 서블릿(Controller)을 중간에 두어 MVC 패턴을 적용해야 하는지 그 필요성을
  이해하기 어려웠다. JSP에 비즈니스 로직과 표현 로직이 섞이면 유지보수가 어려워진다는 문제를 통해 역할 분리의 중요성을 깨달았다.

* **Forward vs. Redirect의 차이**: 두 방식 모두 다른 페이지로 이동하는 것처럼 보였지만, 동작 주체와 방식이 완전히 달랐다. Forward는 **서버 내부**에서 `request` 객체를
  유지한 채로 제어권을 JSP로 넘기는 방식이고, Redirect는 **클라이언트에게** 다른 주소로 다시 요청하라고 지시하여 URL이 바뀌고 `request` 객체가 새로 생성되는 방식이라는 차이를 구분해야
  했다.

* **Spring Framework의 자동화**: `@Controller`나 `@GetMapping` 같은 애너테이션만 붙이면 복잡한 서블릿 코드 없이도 URL 요청이 처리되는 것이 자동화되어 보였다. 이는
  프레임워크가 내부적으로 `DispatcherServlet`을 통해 요청을 가로채고, 애너테이션 정보를 분석하여 적절한 메서드를 대신 호출해주는 **제어의 역전(IoC)** 덕분이라는 것을 이해했다.

---

## 정리 🖇️

### 1. JSP(JavaServer Pages)와 그 한계

HTML 문서 안에 자바 코드를 삽입하여 동적인 웹 페이지를 생성하는 템플릿 엔진 기술을 학습했다.

* **학습 목표 (Why?)**:
  서블릿에서 `PrintWriter`를 이용해 HTML을 문자열로 작성하는 방식의 극심한 비효율성을 해결하고, 디자이너와 개발자의 작업을 분리하기 위함이다.

* **핵심 원리 (What?)**:
  JSP 파일은 최초 요청 시 서블릿 컨테이너(Tomcat)에 의해 자바 서블릿 코드로 자동 변환된 후 컴파일되어 실행된다.
  | JSP 요소 | 문법 | 설명 |
  | :--- | :--- | :--- |
  | **스크립틀릿** | `<% ... %>` | 자바 코드를 작성하는 영역. 비즈니스 로직과 데이터 처리를 수행. |
  | **표현식** | `<%= ... %>`| 변수나 연산의 결과를 문자열로 출력하는 영역. `out.print()`와 동일. |
  | **지시어** | `<%@ ... %>` | 페이지 설정 정보(인코딩, import 등)를 정의. |

* **한계**:
  JSP 파일 하나에 HTML(View)과 자바 코드(Controller, Model)가 모두 섞여 있어, 코드가 복잡해지고 유지보수가 매우 어려워지는 **스파게티 코드** 문제를 야기한다.
  ```jsp
  <!-- JSP의 문제점을 보여주는 예시 -->
  <%
    // 비즈니스 로직 (Controller + Model 역할)
    String username = request.getParameter("username");
    int age = Integer.parseInt(request.getParameter("age"));
    boolean isAdult = age >= 19;
  %>
  <html> <!-- 표현 로직 (View 역할) -->
    <h1>환영합니다, <%= username %>님!</h1>
    <% if (isAdult) { %>
      <p>성인용 콘텐츠를 이용할 수 있습니다.</p>
    <% } %>
  </html>
  ```

---

### 2. MVC 디자인 패턴: 역할과 책임의 분리

JSP의 한계를 극복하기 위해, 애플리케이션의 구성 요소를 **Model**, **View**, **Controller**라는 세 가지 역할로 분리하는 설계 패턴을 학습했다.

* **학습 목표 (Why?)**:
  비즈니스 로직과 화면 로직을 분리하여 코드의 결합도를 낮추고, 각 구성 요소가 자신의 책임에만 집중하게 만들어 유지보수성과 재사용성을 극대화하기 위함이다.

* **핵심 원리 (What?)**:
    * **Model**: 데이터와 비즈니스 로직을 담당. (e.g., `DancerRepository`, `Dancer` DTO)
    * **View**: 사용자에게 보여줄 화면(UI)을 렌더링하는 역할. (e.g., JSP 파일)
    * **Controller (Servlet)**: 사용자의 요청을 받아 어떤 Model을 사용할지, 어떤 View를 보여줄지 결정하고 제어하는 '교통정리' 역할.

* **문법 및 사용법 (How?)**:
  ```java
  // === Controller (Servlet) ===
  @WebServlet("/dancers/list")
  public class DancerListServlet extends HttpServlet {
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
          // 1. Model로부터 데이터를 조회
          List<Dancer> dancers = DancerRepository.findAll();

          // 2. 조회된 데이터를 request 객체에 담아 View에 전달
          req.setAttribute("dancers", dancers);

          // 3. View(JSP)로 제어권을 포워딩
          RequestDispatcher dp = req.getRequestDispatcher("/WEB-INF/views/dancers/list.jsp");
          dp.forward(req, resp);
      }
  }
  ```
  ```jsp
  <%-- === View (JSP with JSTL & EL) === --%>
  <%-- /WEB-INF/ 폴더에 위치시켜 사용자의 직접적인 URL 접근을 막음 (보안) --%>
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  <ul>
      <c:forEach var="dancer" items="${dancers}">
          <li>이름: ${dancer.name}, 크루: ${dancer.crewName}</li>
      </c:forEach>
  </ul>
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **Forward vs. Redirect**:
      | 구분 | 포워드 (Forward) | 리다이렉트 (Redirect) |
      | :--- | :--- | :--- |
      | **개념** | **서버 내부 이동**. 제어권을 다른 서블릿이나 JSP로 넘김. | **클라이언트 재요청**. 브라우저에게 다른 URL로 다시 요청하라고 지시. |
      | **URL** | 변경되지 않음. | 변경됨. |
      | **`request` 객체**| **공유됨**. | 공유되지 않음 (새로운 요청). |
      | **사용 시점**| 조회(SELECT) 요청 처리 후 화면을 보여줄 때. | 등록/수정/삭제(C/U/D) 처리 후 중복 전송을 방지하고 다른 페이지로 이동시킬 때. |

---

### 3. Spring Framework와 Spring Boot

순수 서블릿/JSP 기반의 MVC 패턴에서 발생하는 반복적이고 번거로운 작업을 자동화하여, 개발자가 비즈니스 로직에만 집중할 수 있도록 도와주는 강력한 프레임워크를 학습했다.

* **학습 목표 (Why?)**:
  객체 생성, 의존 관계 설정, 요청 매핑 등 웹 애플리케이션 개발에 필요한 공통적이고 반복적인 작업을 프레임워크에 위임하여, 생산성을 높이고 더 견고한 애플리케이션을 만들기 위함이다.

* **핵심 원리 (What?)**:
    * **Spring Framework**: **제어의 역전(IoC)**과 **의존성 주입(DI)**, **관점 지향 프로그래밍(AOP)**을 핵심 철학으로 하는 자바 애플리케이션 프레임워크.
    * **Spring Boot**: Spring Framework를 더 쉽게 사용할 수 있도록 **설정을 자동화**하고 내장 WAS(Tomcat)를 포함하여, 복잡한 설정 없이도 빠르게 독립 실행 가능한
      애플리케이션을 만들 수 있게 해주는 도구.
    * **Spring MVC**: `DispatcherServlet`이라는 단일 컨트롤러가 모든 요청을 받아, `@RequestMapping`과 같은 애너테이션 정보를 바탕으로 적절한 핸들러 메서드에 요청을
      분배하는 방식으로 동작.

* **문법 및 사용법 (How?)**:
  ```java
  @Controller // 이 클래스가 웹 요청을 처리하는 컨트롤러임을 선언
  public class DancerController {

      // "/dancers/list" GET 요청을 이 메서드와 매핑
      @GetMapping("/dancers/list")
      public String list(Model model) {
          // 1. Model로부터 데이터 조회 (실제로는 Service 계층을 통해)
          List<Dancer> dancers = DancerRepository.findAll();

          // 2. Model 객체에 데이터를 담아 View에 전달
          model.addAttribute("dancers", dancers);

          // 3. 렌더링할 View의 논리적 이름을 반환 (ViewResolver가 실제 경로로 변환)
          return "dancers/list"; // -> /WEB-INF/views/dancers/list.jsp
      }

      // @RequestParam: 요청 파라미터를 메서드 매개변수에 자동으로 바인딩
      @PostMapping("/dancers/register")
      public String register(@RequestParam String name, @RequestParam String crewName) {
          // ... 등록 로직 ...
          return "redirect:/dancers/list"; // 등록 후 목록 페이지로 리다이렉트
      }
  }
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * **Lombok**: `@Getter`, `@Setter`, `@ToString` 등의 애너테이션을 사용하면, 반복적인 보일러플레이트 코드를 컴파일 시점에 자동으로 생성해주어 코드를 매우 깔끔하게 유지할
      수 있다.

---

## 오늘의 깨달음 💡

* 웹 기술의 발전은 불편함을 해결하는 과정에서 이루어졌다. 서블릿의 불편함이 JSP를, JSP의 복잡함이 MVC 패턴을, MVC 패턴의 반복 코드가 Spring 프레임워크를 이끌었다.

* `/WEB-INF` 폴더는 웹 애플리케이션의 보안을 위한 중요한 디렉터리다. 이 폴더 안의 리소스는 사용자가 URL로 직접 접근할 수 없으며, 반드시 컨트롤러를 통해서만 접근하도록 강제할 수 있다.

* 프레임워크는 제어의 역전(IoC)을 통해, 개발자가 작성한 코드를 필요한 시점에 대신 실행해준다. 개발자는 프레임워크가 정한 규칙(설정, 애너테이션)을 잘 지키는 것이 중요하다.

* '관례가 설정을 이긴다(Convention over Configuration)'는 Spring Boot의 철학은 개발자가 사소한 설정보다 중요한 비즈니스 로직에 집중하게 해준다.