# TIL - 2025.07.15 - RESTful API 설계, ResponseEntity, CORS 및 SSR 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #RESTful #API #ResponseEntity #CORS #SSR #Thymeleaf

---

## 오늘 배운 내용 🔍

- 자원(Resource) 중심의 RESTful API 설계 원칙과 6가지 제약 조건
- `@RestController`와 `@RequestBody`를 이용한 JSON 기반의 REST API 요청 처리
- HTTP 응답 상태 코드와 헤더를 정밀하게 제어하는 `ResponseEntity`의 활용
- 브라우저의 동일 출처 정책(Same-Origin Policy)과 이를 해결하기 위한 CORS(Cross-Origin Resource Sharing)
- 서버에서 동적으로 HTML을 생성하는 서버 사이드 렌더링(SSR)과 템플릿 엔진(JSP, Thymeleaf)

---

## 어려웠던 점 💣

* **RESTful의 진정한 의미**: 처음에는 RESTful을 `/users/1`처럼 의미 있는 URL을 만드는 '주소 디자인 규칙' 정도로만 생각했다. 하지만 학습을 통해 `Stateless(무상태성)`,
  `Cacheable(캐시 가능)` 등 6가지 원칙을 지키는 아키텍처 '스타일'이자, 클라이언트와 서버가 어떻게 상호작용해야 하는지에 대한 '철학'에 가깝다는 것을 알게 되었다.

* **`ResponseEntity`의 필요성**: 객체를 그냥 반환해도 JSON으로 잘 변환되는데, 굳이 `ResponseEntity`로 감싸는 이유가 와닿지 않았다. 하지만 계정 생성 시 빈 값을 보냈을 때
  `400 Bad Request`를, 존재하지 않는 계정을 조회할 때 `404 Not Found`를 반환하는 예제를 보며, 단순히 데이터만 보내는 것이 아니라 **요청 처리 결과의 '상태'까지 명확하게 전달**하기
  위해 필요하다는 것을 깨달았다.

* **CORS의 등장 배경**: API를 잘 만들고 있는데, 갑자기 다른 출처(Origin)에서의 접속을 제어하는 CORS 개념이 등장해 흐름이 끊기는 느낌을 받았다. 이는 브라우저의 강력한 보안 정책인 **'동일
  출처 정책(Same-Origin Policy)'** 때문에 발생하는 필연적인 문제였고, API 서버를 만들었다면 반드시 고려해야 할 실무적인 장벽이라는 것을 알게 되었다.

* **JSP vs. Thymeleaf**: 두 템플릿 엔진이 모두 서버 사이드 렌더링(SSR)이라는 비슷한 역할을 하는 것 같아 각각의 장단점이 혼란스러웠다. JSP는 전통적이고 강력하지만 HTML과 자바 코드가
  섞이는 반면, Thymeleaf는 순수 HTML 구조를 유지하면서 `th:*` 속성으로 데이터를 바인딩하여 디자이너와의 협업에 더 유리하다는 차이점을 이해하는 과정이 필요했다.

---

## 정리 🖇️

### 1. RESTful API 설계 원칙

현대적인 웹 서비스의 기반이 되는 아키텍처 스타일인 REST(Representational State Transfer)의 핵심 원칙을 학습했다.

* **학습 목표 (Why?)**:
  '자원(Resource)'을 기반으로 URL을 설계하고, HTTP 메서드를 통해 해당 자원에 대한 '행위(Verb)'를 표현함으로써, 일관되고 예측 가능하며 확장 가능한 API를 설계하는 능력을 기르기 위함이다.

* **핵심 원리 (What?)**:
  REST는 특정 기술이 아닌 아키텍처 '스타일'이며, 다음의 원칙들을 준수한다.
    * **자원(Resource) 중심 설계**: 모든 것은 '자원'으로 표현되며, URL은 이 자원을 고유하게 식별한다. (e.g., `/users`, `/products/1`)
    * **행위(Verb)는 HTTP 메서드로 표현**: 자원에 대한 행위는 `GET`(조회), `POST`(생성), `PUT`(수정), `DELETE`(삭제)와 같은 표준 HTTP 메서드를 사용한다. URL에
      행위를 나타내는 동사(e.g., `/getUsers`)를 포함하지 않는다.
    * **자체 서술성(Self-descriptiveness)**: 요청/응답 메시지 자체에 그 내용을 어떻게 처리해야 하는지에 대한 정보(e.g., `Content-Type: application/json`)가
      포함되어야 한다.
    * **무상태성(Stateless)**: 서버는 클라이언트의 상태를 저장하지 않는다. 각 요청은 자신을 처리하는 데 필요한 모든 정보를 담고 있어야 한다.

* **문법 및 사용법 (How?)**: `@RequestBody` 애너테이션은 클라이언트가 보낸 JSON 데이터를 자바 객체로 자동 변환(역직렬화)하는 역할을 한다.
  ```java
  @RestController
  @RequestMapping("/api/v3-2/members")
  public class MemberController {
      private Map<String, Member> memberStore = new HashMap<>();

      // @RequestBody를 통해 요청 본문의 JSON 데이터가 Member 객체로 자동 매핑됨
      @PostMapping
      public String join(@RequestBody Member member) {
          // ... (생성 로직) ...
          return "새로운 멤버 생성 완료!";
      }
  }
  ```

---

### 2. `ResponseEntity`: 정밀한 응답 제어

단순히 데이터만 반환하는 것을 넘어, HTTP 응답 상태 코드와 헤더까지 세밀하게 제어하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  요청 처리 결과(성공, 실패, 클라이언트 오류, 서버 오류 등)에 따라 적절한 HTTP 상태 코드를 동적으로 반환하고, 필요에 따라 커스텀 헤더를 추가하여 클라이언트에게 더 명확하고 풍부한 정보를 전달하기
  위함이다.

* **핵심 원리 (What?)**:
  `ResponseEntity<T>`는 HTTP 응답 전체(본문, 상태 코드, 헤더)를 표현하는 객체다. 메서드의 반환 타입을 `ResponseEntity<?>`로 지정하면, 로직 분기를 통해 다양한 상태의 응답을
  생성할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @RestController
  @RequestMapping("/api/v3-3/members")
  public class MemberResponseController {
      private Map<String, Member> memberStore = new HashMap<>();

      @PostMapping
      public ResponseEntity<?> join(@RequestBody Member member) {
          if (member.getAccount() == null || member.getAccount().isBlank()) {
              // 400 Bad Request 상태 코드와 에러 메시지 반환
              return ResponseEntity.badRequest().body("계정은 필수 값입니다.");
          }
          // ... (생성 로직) ...
          // 200 OK 상태 코드와 성공 메시지 반환
          return ResponseEntity.ok("새로운 멤버가 생성되었습니다.");
      }

      @GetMapping("/{account}")
      public ResponseEntity<?> findOne(@PathVariable String account) {
          Member foundMember = findMemberByAccount(account);
          if (foundMember == null) {
              // 404 Not Found 상태 코드와 에러 메시지 반환
              return ResponseEntity.notFound().build();
          }
          // 200 OK 상태 코드와 회원 객체(JSON) 반환
          return ResponseEntity.ok(foundMember);
      }
  }
  ```

---

### 3. CORS (Cross-Origin Resource Sharing)

다른 출처(도메인, 프로토콜, 포트)의 클라이언트가 내 API 서버의 리소스에 접근할 수 있도록 허용하는 정책을 설정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  브라우저의 강력한 보안 정책인 **'동일 출처 정책(Same-Origin Policy)'**을 이해하고, 이를 극복하여 프론트엔드 서버와 백엔드 API 서버가 분리된 현대적인 웹 아키텍처를 구현하기 위함이다.

* **핵심 원리 (What?)**:
  CORS는 서버가 특정 응답 헤더(`Access-Control-Allow-Origin` 등)를 추가하여, 다른 출처의 접근을 선택적으로 허용하도록 브라우저에게 알려주는 메커니즘이다. Spring에서는
  `WebMvcConfigurer`를 구현한 설정 클래스를 통해 애플리케이션 전체에 일관된 CORS 정책을 적용할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @Configuration
  public class CorsConfig implements WebMvcConfigurer {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/api/**") // /api/로 시작하는 모든 경로에 적용
                  .allowedOrigins("http://127.0.0.1:5500") // 허용할 클라이언트 출처
                  .allowedMethods("GET", "POST", "PUT", "DELETE") // 허용할 HTTP 메서드
                  .allowedHeaders("*") // 허용할 요청 헤더
                  .allowCredentials(true); // 쿠키 전송 허용
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 보안을 위해 `.allowedOrigins("*")` 처럼 모든 출처를 허용하는 것은 실제 운영 환경에서는 매우 위험하다. 반드시 허용할 클라이언트의 주소만 명시해야 한다.

---

### 4. 서버 사이드 렌더링 (SSR)과 템플릿 엔진

서버에서 최종 HTML을 모두 완성하여 클라이언트에게 전달하는 서버 사이드 렌더링 방식과, 이를 돕는 템플릿 엔진의 기본 개념을 학습했다.

* **학습 목표 (Why?)**:
  REST API + CSR(Client-Side Rendering) 방식과의 차이점을 이해하고, 서버에서 동적인 데이터를 HTML에 삽입하여 완성된 페이지를 만드는 원리를 파악한다.

* **핵심 원리 (What?)**:
    * **SSR**: 브라우저가 서버에 페이지를 요청하면, 서버는 데이터베이스 조회 등 필요한 로직을 수행한 뒤, **데이터가 모두 채워진 완성된 HTML**을 생성하여 응답한다.
    * **템플릿 엔진**: 미리 만들어진 HTML 템플릿 파일에 서버에서 전달된 데이터를 동적으로 결합하여 최종 HTML을 만들어주는 도구다. `@Controller`와 `Model` 객체를 사용한다.

* **문법 및 사용법 (How?)**: `@Controller`가 `Model`에 데이터를 담아 뷰 이름을 반환하는 구조.
  ```java
  @Controller
  public class SsrController {
      @GetMapping("/products")
      public String productList(Model model) {
          List<Product> products = productService.findAll();
          // "products"라는 이름으로 서버의 상품 목록 데이터를 Model에 담는다.
          model.addAttribute("products", products);
          // "product-list" 라는 이름의 뷰 파일을 찾아 렌더링하라고 지시.
          return "product-list";
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * SSR은 초기 로딩 속도가 빠르고 SEO(검색 엔진 최적화)에 유리하다는 장점이 있다.
    * 최근 웹 개발 트렌드는 초기 페이지만 SSR로 제공하고, 이후의 동적인 상호작용은 REST API와 CSR을 혼용하는 방식을 많이 사용한다.

---

## 오늘의 깨달음 💡

* REST는 단순히 URL을 설계하는 기술이 아니라, 자원의 '상태'를 특정 '표현(JSON 등)'으로 클라이언트와 서버가 주고받는 방식에 대한 **'철학'**이었다. 이 철학을 따를 때 비로소 예측 가능하고
  확장성 있는 API가 만들어진다.

* **`ResponseEntity`는 서버의 '표정'을 전달하는 도구다.** 단순히 데이터만 보내는 것은 무표정한 응답과 같다. `ResponseEntity`를 사용하면 "성공했어(200 OK)", "네 요청이
  이상해(400 Bad Request)", "찾아봤는데 없어(404 Not Found)" 와 같이 서버의 정확한 상태와 표정까지 전달할 수 있었다.

* **API와 웹 페이지는 다른 '문'으로 들어간다.** `/api/...`로 시작하는 주소는 데이터만 오고 가는 '화물용 문(`@RestController`)'이고, `/page/...` 같은 주소는 사람이 보는
  완성된 페이지가 나오는 '정문(`@Controller`)'과 같았다. 두 문의 역할을 구분하니, 왜 컨트롤러를 분리해야 하는지 명확해졌다.

* **CORS는 남의 집 문을 열기 위한 '서버의 허락'이다.** 브라우저라는 경비원이 "다른 집(다른 도메인)의 물건은 함부로 가져올 수 없어요!"라고 막는 것을, 서버가 "저 사람은 내가 허락한 사람이니
  들여보내 줘"라고 말해주는 과정이 바로 CORS였다. 보안을 위한 브라우저의 기본 원칙과 이를 해결하기 위한 서버의 역할을 함께 이해할 수 있었다.