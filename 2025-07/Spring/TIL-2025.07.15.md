# TIL - 2025.07.15 - RESTful API 설계, ResponseEntity, CORS 및 SSR 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #RESTful #API #ResponseEntity #CORS #SSR #Thymeleaf

---

## 오늘 배운 내용 🔍

- 자원(Resource) 중심의 RESTful API 설계 원칙과 6가지 제약 조건
- `@RestController`와 `@RequestBody`를 이용한 JSON 기반의 REST API 요청 처리
- HTTP 응답 상태 코드와 헤더를 정밀하게 제어하는 `ResponseEntity`의 활용
- 브라우저의 동일 출처 정책(Same-Origin Policy)과 이를 해결하기 위한 CORS(Cross-Origin Resource Sharing)
- 서버에서 동적으로 HTML을 생성하는 서버 사이드 렌더링(SSR)과 템플릿 엔진(JSP, Thymeleaf)

---

## 어려웠던 점 💣

* **RESTful의 개념**: RESTful을 단순히 `/users/1`처럼 의미 있는 URL 주소를 만드는 방법으로만 생각했다. 하지만 `Stateless(무상태성)`, `Cacheable(캐시 가능)` 등
  6가지 원칙을 지키는 아키텍처 '스타일'이라는 것을 알게 되었다. 단순한 URL 디자인 규칙이 아니라 서버와 클라이언트의 상호작용 방식에 대한 원칙에 가까웠다.

* **`ResponseEntity`의 필요성**: 객체를 그냥 반환해도 JSON으로 변환되는데, 굳이 `ResponseEntity`로 감싸서 반환하는 이유가 와닿지 않았다. 하지만 계정 생성 실패 시
  `400 Bad Request`를, 존재하지 않는 계정 조회 시 `404 Not Found`를 반환하는 것을 보며, 데이터뿐만 아니라 **요청 처리 결과의 '상태'까지 명확하게 전달**하기 위해 필요하다는 것을
  깨달았다.

* **CORS의 등장 배경**: API를 개발하던 중 갑자기 다른 도메인에서의 접속을 제어하는 CORS(Cross-Origin Resource Sharing) 개념이 등장해 흐름을 이해하기 어려웠다. 이는
  브라우저의 보안 정책인 **'동일 출처 정책(Same-Origin Policy)'** 때문에 발생하는 필연적인 문제였고, API 서버 개발 시 반드시 고려해야 할 실무적인 부분임을 알게 되었다.

* **템플릿 엔진의 종류**: 서버 사이드 렌더링(SSR)을 위해 JSP와 Thymeleaf 두 가지를 접했다. 둘 다 비슷한 역할을 하는 것 같은데 왜 두 가지나 배우는지, 각각의 장단점은 무엇인지 혼란스러웠다.
  JSP는 전통적인 방식이고, Thymeleaf는 HTML 구조를 유지하면서 서버 데이터를 입힐 수 있어 디자이너와의 협업에 유리하다는 차이점을 이해하는 과정이 필요했다.

---

## 정리 🖇️

### 1. RESTful API 설계 원칙

현대적인 웹 서비스의 기반이 되는 아키텍처 스타일인 REST(Representational State Transfer)의 핵심 원칙을 학습했다.

* **학습 목표 (Why?)**:
  '자원(Resource)'을 기반으로 URL을 설계하고, HTTP 메서드를 통해 해당 자원에 대한 '행위(Verb)'를 표현함으로써, 일관되고 예측 가능하며 확장 가능한 API를 설계하는 능력을 기르기 위함이다.

* **핵심 원리 (What?)**:
  REST는 특정 기술이 아닌 아키텍처 '스타일'이며, 다음의 원칙들을 준수한다.
    * **자원(Resource) 중심 설계**: 모든 것은 '자원'으로 표현되며, URL은 이 자원을 고유하게 식별한다. (e.g., `/users`, `/products/1`)
    * **행위(Verb)는 HTTP 메서드로 표현**: 자원에 대한 행위는 `GET`(조회), `POST`(생성), `PUT`(수정), `DELETE`(삭제)와 같은 표준 HTTP 메서드를 사용한다. URL에
      행위를 나타내는 동사(e.g., `/getUsers`)를 포함하지 않는다.
    * **자체 서술성(Self-descriptiveness)**: 요청/응답 메시지 자체에 그 내용을 어떻게 처리해야 하는지에 대한 정보(e.g., `Content-Type: application/json`)가
      포함되어야 한다.
    * **무상태성(Stateless)**: 서버는 클라이언트의 상태를 저장하지 않는다. 각 요청은 자신을 처리하는 데 필요한 모든 정보를 담고 있어야 한다.

* **문법 및 사용법 (How?)**: `@RequestBody` 애너테이션은 클라이언트가 보낸 JSON 데이터를 자바 객체로 자동 변환(역직렬화)하는 역할을 한다.
  ```java
  @RestController
  @RequestMapping("/api/v3-2/members")
  public class MemberController {
      private Map<String, Member> memberStore = new HashMap<>();

      // @RequestBody를 통해 요청 본문의 JSON 데이터가 Member 객체로 자동 매핑됨
      @PostMapping
      public String join(@RequestBody Member member) {
          // ... (생성 로직) ...
          return "새로운 멤버 생성 완료!";
      }
  }
  ```

---

### 2. `ResponseEntity`: 정밀한 응답 제어

단순히 데이터만 반환하는 것을 넘어, HTTP 응답 상태 코드와 헤더까지 세밀하게 제어하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  요청 처리 결과(성공, 실패, 클라이언트 오류, 서버 오류 등)에 따라 적절한 HTTP 상태 코드를 동적으로 반환하고, 필요에 따라 커스텀 헤더를 추가하여 클라이언트에게 더 명확하고 풍부한 정보를 전달하기
  위함이다.

* **핵심 원리 (What?)**:
  `ResponseEntity<T>`는 HTTP 응답 전체(본문, 상태 코드, 헤더)를 표현하는 객체다. 메서드의 반환 타입을 `ResponseEntity<?>`로 지정하면, 로직 분기를 통해 다양한 상태의 응답을
  생성할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @RestController
  @RequestMapping("/api/v3-3/members")
  public class MemberResponseController {
      private Map<String, Member> memberStore = new HashMap<>();

      @PostMapping
      public ResponseEntity<?> join(@RequestBody Member member) {
          if (member.getAccount() == null || member.getAccount().isBlank()) {
              // 400 Bad Request 상태 코드와 에러 메시지 반환
              return ResponseEntity.badRequest().body("계정은 필수 값입니다.");
          }
          // ... (생성 로직) ...
          // 200 OK 상태 코드와 성공 메시지 반환
          return ResponseEntity.ok("새로운 멤버가 생성되었습니다.");
      }

      @GetMapping("/{account}")
      public ResponseEntity<?> findOne(@PathVariable String account) {
          Member foundMember = findMemberByAccount(account);
          if (foundMember == null) {
              // 404 Not Found 상태 코드와 에러 메시지 반환
              return ResponseEntity.notFound().build();
          }
          // 200 OK 상태 코드와 회원 객체(JSON) 반환
          return ResponseEntity.ok(foundMember);
      }
  }
  ```

---

### 3. CORS (Cross-Origin Resource Sharing)

다른 출처(도메인, 프로토콜, 포트)의 클라이언트가 내 API 서버의 리소스에 접근할 수 있도록 허용하는 정책을 설정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  브라우저의 강력한 보안 정책인 **'동일 출처 정책(Same-Origin Policy)'**을 이해하고, 이를 극복하여 프론트엔드 서버와 백엔드 API 서버가 분리된 현대적인 웹 아키텍처를 구현하기 위함이다.

* **핵심 원리 (What?)**:
  CORS는 서버가 특정 응답 헤더(`Access-Control-Allow-Origin` 등)를 추가하여, 다른 출처의 접근을 선택적으로 허용하도록 브라우저에게 알려주는 메커니즘이다. Spring에서는
  `WebMvcConfigurer`를 구현한 설정 클래스를 통해 애플리케이션 전체에 일관된 CORS 정책을 적용할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  @Configuration
  public class CorsConfig implements WebMvcConfigurer {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/api/**") // /api/로 시작하는 모든 경로에 적용
                  .allowedOrigins("http://127.0.0.1:5500") // 허용할 클라이언트 출처
                  .allowedMethods("GET", "POST", "PUT", "DELETE") // 허용할 HTTP 메서드
                  .allowedHeaders("*") // 허용할 요청 헤더
                  .allowCredentials(true); // 쿠키 전송 허용
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 보안을 위해 `.allowedOrigins("*")` 처럼 모든 출처를 허용하는 것은 실제 운영 환경에서는 매우 위험하다. 반드시 허용할 클라이언트의 주소만 명시해야 한다.

---

### 4. 서버 사이드 렌더링 (SSR)과 템플릿 엔진

서버에서 최종 HTML을 모두 완성하여 클라이언트에게 전달하는 서버 사이드 렌더링 방식과, 이를 돕는 템플릿 엔진의 기본 개념을 학습했다.

* **학습 목표 (Why?)**:
  REST API + CSR(Client-Side Rendering) 방식과의 차이점을 이해하고, 서버에서 동적인 데이터를 HTML에 삽입하여 완성된 페이지를 만드는 원리를 파악한다.

* **핵심 원리 (What?)**:
    * **SSR**: 브라우저가 서버에 페이지를 요청하면, 서버는 데이터베이스 조회 등 필요한 로직을 수행한 뒤, **데이터가 모두 채워진 완성된 HTML**을 생성하여 응답한다.
    * **템플릿 엔진**: 미리 만들어진 HTML 템플릿 파일에 서버에서 전달된 데이터를 동적으로 결합하여 최종 HTML을 만들어주는 도구다. `@Controller`와 `Model` 객체를 사용한다.

* **문법 및 사용법 (How?)**: `@Controller`가 `Model`에 데이터를 담아 뷰 이름을 반환하는 구조.
  ```java
  @Controller
  public class SsrController {
      @GetMapping("/products")
      public String productList(Model model) {
          List<Product> products = productService.findAll();
          // "products"라는 이름으로 서버의 상품 목록 데이터를 Model에 담는다.
          model.addAttribute("products", products);
          // "product-list" 라는 이름의 뷰 파일을 찾아 렌더링하라고 지시.
          return "product-list";
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * SSR은 초기 로딩 속도가 빠르고 SEO(검색 엔진 최적화)에 유리하다는 장점이 있다.
    * 최근 웹 개발 트렌드는 초기 페이지만 SSR로 제공하고, 이후의 동적인 상호작용은 REST API와 CSR을 혼용하는 방식을 많이 사용한다.

---

## 오늘의 깨달음 💡

* REST는 `Representational State Transfer`라는 이름 그대로, 자원의 '상태'를 특정 '표현(JSON 등)'으로 클라이언트와 서버가 주고받는 방식에 대한 아키텍처 원칙임을 이해했다.

* `ResponseEntity`를 사용하면, HTTP 응답에 데이터 본문뿐만 아니라 상태 코드와 헤더까지 포함하여 더 명확하고 상세한 정보를 클라이언트에게 전달할 수 있다.

* 브라우저의 동일 출처 정책(SOP)은 기본적인 웹 보안 기능이며, CORS는 이 정책을 안전하게 우회하여 다른 출처의 리소스에 접근할 수 있도록 서버가 허용해주는 메커니즘이다.

* API 컨트롤러(`@RestController`)와 페이지 컨트롤러(`@Controller`)는 반환하는 내용의 본질이 다르다. 전자는 데이터를, 후자는 렌더링될 뷰(View)를 반환하므로 목적에 맞게 분리하여
  사용해야 한다.