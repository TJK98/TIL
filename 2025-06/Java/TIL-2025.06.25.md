# TIL - 2025.06.25 - 자바 메서드의 정의, 오버로딩 및 재사용성 개념 이해

## 카테고리 🏷️

#TIL #Java #Method #Overloading #Varargs #Refactoring #DefensiveProgramming

---

## 오늘 배운 내용 🔍

- 메서드의 기본 구조: 선언 위치, 구성 요소 (반환 타입, 이름, 매개변수)
- 반환값이 없는 경우를 나타내는 `void` 키워드
- 정해지지 않은 개수의 인자를 받는 가변 인자(Varargs, `...`)의 동작 원리
- 여러 개의 값을 반환하기 위해 배열이나 객체를 활용하는 방법
- 메서드 오버로딩(Overloading)의 개념과 성립 조건
- 헬퍼 메서드(Helper Method)를 이용한 코드 재사용 및 리팩토링
- 가드 클로즈(Guard Clauses)를 활용한 방어적 프로그래밍

---

## 어려웠던 점 💣

* **가변 인자(`...`)의 정체**: `sumAll(10, 20, 30)` 처럼 값을 나열하여 전달하는 문법이 배열과 다른 특별한 기능이라고 생각했으나, 메서드 내부에서는 `int[]` 타입의 배열로 취급되는
  점이 혼란스러웠다. 이는 개발자가 메서드를 호출할 때의 편의성을 위해, 컴파일러가 `new int[]{10, 20, 30}` 코드를 자동으로 생성해주는 '문법 설탕(Syntactic Sugar)'이라는 것을
  이해했다.

* **`static` 키워드의 필요성**: 직접 만든 메서드를 `main` 메서드에서 호출하려면 반드시 `static`을 붙여야 하는 이유가 궁금했다. `main` 메서드는 프로그램 시작 시 객체 생성 없이
  클래스에 직접 소속되어 메모리에 올라가는 '정적(static)' 메서드이므로, `main` 내부에서는 동일하게 객체 생성 없이 접근 가능한 다른 `static` 멤버들만 직접 호출할 수 있다는 원리를 이해했다.

* **다중 값 반환의 제약과 해결**: 자바 메서드가 `return`으로 오직 하나의 값만 반환할 수 있다는 제약이 처음에는 불편하게 느껴졌다. 하지만 덧셈과 뺄셈 결과를 `new int[]{sum, sub}` 와
  같이 배열에 담아 '배열 객체 하나'를 반환함으로써 이 제약을 우회할 수 있음을 알게 되었다. 이는 '하나의 값'이라는 원칙을 지키면서도, 그 값이 여러 데이터를 담고 있는 '객체'일 수 있다는 유연한 사고방식을
  가르쳐주었다.

* **메서드 재사용에 대한 관점**: 특정 인덱스의 요소를 삭제하는 `remove(int index)` 메서드를 구현할 때, 삭제 로직을 처음부터 다시 작성하는 대신 `remove(products[index])`
  와 같이 기존에 만들어 둔 `remove(String target)` 메서드를 호출하여 로직을 위임하는 방식이 인상 깊었다. 이는 코드 중복을 최소화하고 로직을 한 곳에서 관리하게 하여 유지보수성을 극대화하는
  핵심적인 설계 원칙임을 깨달았다.

---

## 정리 🖇️

### 1. 메서드(Method)의 기본 구조와 활용

특정 기능을 수행하는 코드 블록을 하나의 단위로 묶어 재사용하는 방법을 학습했다. 메서드는 클래스 내부에, 다른 메서드 외부에 정의된다.

* **학습 목표 (Why?)**:
  반복되는 코드를 줄이고, 각 기능에 의미 있는 이름을 부여하여 코드의 가독성과 유지보수성을 높이기 위함이다. 기능을 독립적인 부품처럼 만들어 프로그램의 구조를 체계적으로 설계할 수 있다.

* **핵심 원리 (What?)**:
  `[접근제한자] [static] 반환타입 메서드이름(매개변수...) { ... }`
    * **반환 타입 (Return Type)**: 메서드가 실행된 후 반환하는 값의 데이터 타입. 반환할 값이 없으면 `void`를 명시한다. `return` 키워드는 값을 반환함과 동시에 메서드의 실행을 즉시
      종료시킨다.
    * **매개변수 (Parameters)**: 메서드가 작업을 수행하는 데 필요한 외부의 값을 전달받는 통로.
    * **`static`**: 객체를 생성(`new`)하지 않고도, `클래스이름.메서드이름()` 형태로 직접 호출할 수 있는 정적 메서드를 선언한다.

* **문법 및 사용법 (How?)**:
  ```java
  public class Calculator {
      // 두 정수를 받아 덧셈 결과를 반환하는 메서드
      static int add(int n1, int n2) {
          return n1 + n2;
      }

      // 반환값이 없는 메서드
      static void printMessage(String message) {
          System.out.println(message);
      }

      // 여러 값을 배열에 담아 반환하는 메서드
      static int[] calculate(int n1, int n2) {
          return new int[]{n1 + n2, n1 - n2};
      }
  }
  ```

---

### 2. 가변 인자(Varargs)와 메서드 오버로딩

다양한 형태의 입력을 유연하게 처리하는 메서드 설계 기법을 학습했다.

* **학습 목표 (Why?)**:
  동일한 기능을 수행하지만 매개변수의 개수나 타입이 다른 경우, 일관된 메서드 이름을 제공하여 사용 편의성을 높이고, 정해지지 않은 개수의 인자를 효율적으로 처리하기 위함이다.

* **핵심 원리 (What?)**:
    * **가변 인자 (Varargs)**: `타입... 변수명` 형태로 선언하며, 메서드에 전달된 여러 개의 인자를 **배열**로 받아 처리한다. 가변 인자는 매개변수 목록의 가장 마지막에 한 번만 사용할 수
      있다.
    * **메서드 오버로딩 (Method Overloading)**: 하나의 클래스 내에서 **같은 이름의 메서드를 여러 개 정의**하는 것. 단, **매개변수의 타입, 개수, 순서 중 하나 이상이 반드시 달라야
      ** 한다.

* **문법 및 사용법 (How?)**:
  ```java
  // 가변 인자 사용 예시
  static int sumAll(int... numbers) { // numbers는 int[] 타입으로 처리됨
      int total = 0;
      for (int n : numbers) {
          total += n;
      }
      return total;
  }
  // 호출: sumAll(10, 20), sumAll(10, 20, 30, 40) 모두 가능

  // 메서드 오버로딩 예시
  static int add(int a, int b) {
      return a + b;
  }

  static int add(int a, int b, int c) { // 매개변수 개수가 다름
      return a + b + c;
  }

  static double add(double a, double b) { // 매개변수 타입이 다름
      return a + b;
  }
  ```

---

### 3. 메서드 재사용과 방어적 프로그래밍

코드의 중복을 제거하고 안정성을 높이는 프로그래밍 기법을 학습했다.

* **학습 목표 (Why?)**:
  작성된 코드를 최대한 재활용하여 생산성을 높이고, 예외적인 입력값이나 상황으로부터 프로그램이 비정상적으로 종료되는 것을 방지하여 견고한 코드를 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * **메서드 재사용**: 특정 기능을 수행하는 메서드가 이미 존재할 경우, 새로운 메서드에서 해당 기능을 다시 구현하지 않고 기존 메서드를 호출하여 로직을 위임한다.
    * **방어적 프로그래밍 (Defensive Programming)**: 메서드 실행 중 발생할 수 있는 오류 상황(e.g., 잘못된 인덱스 접근, null 값)을 미리 예측하고, `if`문 등을 통해 문제가
      발생하지 않도록 사전에 차단하는 코딩 스타일. **가드 클로즈(Guard Clauses)**가 대표적인 기법이다.

* **문법 및 사용법 (How?)**:
  ```java
  // 가정: products 배열이 클래스 멤버 변수로 존재
  // ...

  // 이름으로 상품 인덱스를 찾는 헬퍼 메서드
  static int indexOf(String targetProduct) {
      for (int i = 0; i < products.length; i++) {
          if (products[i].equals(targetProduct)) {
              return i;
          }
      }
      return -1;
  }

  // 인덱스로 상품을 삭제하는 오버로딩 메서드
  static void remove(int targetIndex) {
      // 가드 클로즈: 유효하지 않은 인덱스이면 즉시 종료
      if (targetIndex < 0 || targetIndex >= products.length) {
          System.out.println("유효하지 않은 인덱스입니다.");
          return;
      }

      // 핵심 로직을 기존 remove(String) 메서드에 위임하여 재사용
      remove(products[targetIndex]);
  }

  // 이름으로 상품을 삭제하는 메인 로직
  static void remove(String targetProduct) {
      int index = indexOf(targetProduct);
      // 가드 클로즈: 상품을 찾지 못했으면 즉시 종료
      if (index == -1) {
          System.out.println("해당 상품은 존재하지 않습니다.");
          return;
      }
      // ... 실제 삭제 알고리즘 실행 ...
  }
  ```

---

## 오늘의 깨달음 💡

* 메서드는 단순히 코드를 재사용하는 도구를 넘어, 프로그램의 복잡도를 관리하는 핵심적인 '추상화' 수단임을 깨달았다. 복잡한 로직을 적절한 이름의 메서드로 감싸는 것만으로도, 코드가 마치 잘 쓰인 한 편의 글처럼
  의도를 명확하게 드러냈다.

* 가변 인자(`...`)는 메서드를 '호출하는 쪽'의 편의를 위해 컴파일러가 '정의하는 쪽'의 코드를 대신 작성해주는 똑똑한 문법 설탕(Syntactic Sugar)이었다. 이처럼 언어의 편의 기능 뒤에는 개발자를
  돕기 위한 내부 동작 원리가 숨어있음을 알게 되었다.

* '하나의 값만 반환한다'는 자바 메서드의 제약은, 배열이나 객체라는 '컨테이너'를 활용함으로써 극복할 수 있었다. 이는 원칙을 지키면서도 유연성을 확보하는 문제 해결 방식의 좋은 예시였다.

* 좋은 코드는 중복을 제거하는 데서 시작된다는 DRY(Don't Repeat Yourself) 원칙을 메서드 재사용을 통해 실감했다. `remove(int)`가 `remove(String)`을 호출하는 것처럼,
  로직을 한 곳에 집중시키니 코드가 훨씬 더 깔끔해지고 수정에 용이해졌다.

* 방어적 프로그래밍, 특히 가드 클로즈 패턴은 코드의 안정성을 극적으로 높여주었다. 정상적인 흐름과 예외적인 흐름을 코드 초반에 명확히 분리함으로써, 핵심 로직은 더 깨끗하게 유지되고 잠재적인 버그는 사전에 차단할
  수 있었다.