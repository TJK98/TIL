# TIL - 2025.06.27 - 자바 객체 지향 설계 (역할과 책임, 캡슐화) 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #DesignPrinciples #Encapsulation #Enum #Javadoc

---

## 오늘 배운 내용 🔍

- 역할과 책임에 따른 클래스 분리 원칙 (Controller, Repository, Model)
- 클래스 간의 협력 방식: 의존 관계(Dependency)와 위임(Delegation)
- 데이터의 무결성을 지키는 캡슐화(Encapsulation)의 중요성
- 정해진 상수 데이터의 집합을 안전하게 관리하는 열거형(Enum)
- 코드의 의도를 명확히 전달하는 API 문서화 도구, Javadoc
- `import static`을 이용한 정적 멤버의 간결한 사용법

---

## 어려웠던 점 💣

* **클래스 분리의 추상성**: 모든 로직을 하나의 클래스에 작성하는 것이 처음에는 더 간단해 보였다. Controller, Repository, Model로 역할을 나누는 이유가 추상적으로 느껴졌으나, 실습을
  통해 각 클래스가 자신의 '책임'에만 집중함으로써 코드가 훨씬 명확해지고, 한 부분의 수정이 다른 부분에 미치는 영향을 최소화한다는 것을 깨달았다.

* **클래스 간의 의존과 위임 관계**: Controller가 직접 데이터를 처리하지 않고 Repository 객체에게 "회원 추가해줘"라고 일을 시키는(위임하는) 구조가 낯설었다. 이는 각 객체가 자기 전문
  분야의 일만 처리하도록 하는 효율적인 '분업' 시스템이며, 객체 지향 설계의 핵심적인 협력 방식임을 이해했다.

* **Javadoc 작성의 필요성**: 처음에는 주석을 정해진 형식에 맞춰 다는 것이 번거롭게 느껴졌다. 하지만 `@param`, `@return` 등을 통해 메서드의 기능, 매개변수, 반환값을 명확히 설명해두니,
  코드를 다시 보거나 다른 개발자가 코드를 이해할 때 마치 잘 만들어진 '사용 설명서'처럼 기능할 수 있다는 점에 공감하게 되었다.

* **인조 식별자(Artificial Identifier)의 개념**: `UUID`처럼 시스템이 생성한, 실제 데이터와 무관한 고유 ID를 사용하는 이유가 새로웠다. 이메일 주소처럼 사용자가 변경할 수 있는 값을
  기본 키(Primary Key)로 사용하면 데이터 관계가 복잡해지지만, 절대 변하지 않는 인조 식별자를 사용하면 데이터의 무결성을 훨씬 안정적으로 유지할 수 있다는 것을 배웠다.

---

## 정리 🖇️

### 1. 역할과 책임에 따른 클래스 분리 (3-Tier Architecture)

애플리케이션의 기능을 역할에 따라 크게 3개의 논리적인 계층으로 분리하여 설계하는 패턴을 학습했다.

* **학습 목표 (Why?)**:
  각 클래스가 하나의 명확한 책임만 갖도록 하여 코드의 결합도(Coupling)를 낮추고 응집도(Cohesion)를 높이기 위함이다. 이를 통해 코드의 유지보수, 테스트, 확장이 훨씬 용이해진다.

* **핵심 원리 (What?)**:
    * **Controller (Presentation Layer)**: 사용자와의 상호작용(입출력)을 담당한다. 사용자의 요청을 받아 적절한 서비스(여기서는 Repository)를 호출하고, 그 결과를
      사용자에게 보여준다.
    * **Repository (Data Access Layer)**: 데이터의 영속성(저장, 조회, 수정, 삭제 - CRUD)을 전담한다. 데이터가 배열이든, 파일이든, 데이터베이스든 상관없이 데이터 저장소와의
      통신을 책임진다.
    * **Model / DTO (Domain Layer)**: 애플리케이션의 핵심 데이터 구조를 정의하고 보관한다. 순수한 데이터 객체로서, 자체적인 로직은 거의 갖지 않는다.

* **문법 및 사용법 (How?)**:
  ```java
  // === Model: User.java ===
  // 역할: 사용자 데이터의 구조를 정의하고 보관.
  public class User {
      private String id;
      private String password;
      // 생성자, getter, toString() ...
  }

  // === Repository: UserRepository.java ===
  // 역할: User 데이터를 배열에 저장하고 관리 (CRUD).
  public class UserRepository {
      private User[] userList; // 데이터는 private으로 캡슐화

      public void addUser(User user) { /* ... */ }
      public User findByUserId(String id) { /* ... */ }
  }

  // === Controller: UserController.java ===
  // 역할: 사용자 입력을 받아 Repository에 작업을 위임(Delegate).
  public class UserController {
      private final UserRepository repository = new UserRepository(); // Repository에 의존(Dependency)

      public void join() {
          // 1. 사용자로부터 id, password 등 입력받기 (Presentation)
          // 2. 입력받은 정보로 User 객체 생성 (Domain)
          User newUser = new User(...);
          // 3. 실제 저장은 Repository에 위임 (Data Access)
          repository.addUser(newUser);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **캡슐화(Encapsulation)**: `UserRepository`에서 `userList` 배열을 `private`으로 선언하여 외부에서 직접 접근하는 것을 막고, 오직 `addUser`,
      `findByUserId`와 같은 공개된 메서드(Public Method)를 통해서만 데이터에 접근하도록 허용하는 것이 중요하다. 이는 데이터의 무결성을 지키는 객체 지향의 핵심 원칙이다.

---

### 2. 열거형 (Enum)

서로 연관된 상수들의 집합을 정의할 때 사용하는 특별한 데이터 타입을 학습했다.

* **학습 목표 (Why?)**:
  `"PENDING"`, `"SHIPPED"`와 같은 문자열이나 `1`, `2`와 같은 매직 넘버(의미를 알 수 없는 숫자) 대신, 타입이 보장되는 상수 값을 사용하여 코드의 가독성과 안정성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  `enum`은 정해진 값들만 가질 수 있도록 컴파일 시점에서 타입을 강제한다. 따라서 오타나 유효하지 않은 값이 입력될 가능성을 원천적으로 차단할 수 있다.

* **문법 및 사용법 (How?)**:
  ```java
  // 주문 상태를 나타내는 열거형 정의
  public enum OrderStatus {
      PENDING, PROCESSING, SHIPPED, CANCELLED
  }

  // 사용 예시
  public class Order {
      private OrderStatus status;

      public void setStatus(OrderStatus status) {
          this.status = status;
      }

      public void printStatus() {
          if (this.status == OrderStatus.SHIPPED) {
              System.out.println("주문이 배송 완료되었습니다.");
          }
      }
  }
  ```

---

### 3. Javadoc을 이용한 API 문서화

코드 내에 특별한 형식의 주석을 작성하여, 별도의 HTML 형식의 API 문서를 자동으로 생성하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  클래스와 메서드의 목적, 사용법, 매개변수, 반환값 등을 명확하게 문서화하여, 미래의 나 자신과 동료 개발자들이 코드를 더 쉽게 이해하고 올바르게 사용할 수 있도록 돕기 위함이다.

* **핵심 원리 (What?)**:
  `/** ... */` 형태의 주석 블록 안에 `@` 기호로 시작하는 특별한 Javadoc 태그를 사용하여 문서의 구조를 정의한다.
  | 주요 Javadoc 태그 | 설명 |
  | :--- | :--- |
  | `@param` | 메서드의 매개변수에 대한 설명. |
  | `@return` | 메서드의 반환값에 대한 설명. |
  | `@throws` | 메서드가 발생시킬 수 있는 예외(Exception)에 대한 설명. |
  | `@see` | 함께 참조하면 좋은 다른 클래스나 메서드를 링크. |
  | `@since` | 해당 기능이 추가된 버전 정보. |

* **문법 및 사용법 (How?)**:
  ```java
  /**
   * 주어진 사용자 ID를 기반으로 저장소에서 사용자를 검색합니다.
   *
   * @param userId 검색할 사용자의 고유 ID (null이 아니어야 함)
   * @return       해당 ID를 가진 User 객체를 반환합니다. 사용자를 찾지 못한 경우 null을 반환합니다.
   * @since        1.0
   */
  public User findByUserId(String userId) {
      // ... 검색 로직 ...
      return null;
  }
  ```

---

## 오늘의 깨달음 💡

* 객체 지향 프로그래밍은 단순히 클래스를 사용하는 것을 넘어, 각 클래스에 명확한 **'역할과 책임'**을 부여하고, 이들이 서로 **'협력'**하도록 관계를 설계하는 것임을 깨달았다. Controller,
  Repository, Model의 분리는 그 대표적인 예시다.

* 클래스를 잘 분리하면 **유연성**이 생긴다. 예를 들어, `UserRepository`의 데이터 저장 방식을 배열에서 데이터베이스로 변경하더라도, `UserController`의 코드는 거의 수정할 필요가
  없어진다. 이는 각 부품이 독립적으로 교체 가능한 잘 만든 기계와 같다.

* 캡슐화는 '숨기는 것'이 아니라 '보호하는 것'에 가깝다. `UserRepository`가 `userList` 배열을 `private`으로 숨기고 메서드만 공개함으로써, 데이터가 의도치 않게 변경되거나 오염되는
  것을 막아 데이터의 무결성을 지킬 수 있었다.

* Javadoc은 단순한 주석이 아니라, 미래의 나와 동료를 위한 **가장 정확하고 신뢰할 수 있는 설명서**다. 코드는 계속 변할 수 있지만, 잘 작성된 Javadoc은 그 코드의 '의도'와 '계약'을 오랫동안
  보존해준다.

* 좋은 설계는 '변화'를 예측하고 대비하는 것에서 시작된다. 역할과 책임을 분리하고, 데이터를 캡슐화하며, 의도를 문서화하는 모든 과정은 결국 미래에 발생할 코드의 변경에 더 쉽고 안전하게 대응하기 위한 준비
  작업임을 알게 되었다.