# TIL - 2025.06.30 - Java 접근 제어자와 캡슐화, 객체 지향 설계 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #Encapsulation #AccessModifier #DesignPrinciples

---

## 오늘 배운 내용 🔍

- 접근 제어자(`public`, `default`, `private`)의 종류와 접근 범위
- 데이터를 보호하고 무결성을 지키는 캡슐화(Encapsulation)의 개념과 필요성
- `private` 필드에 안전하게 접근하는 통로인 Getter와 Setter 메서드의 역할
- 역할과 책임에 따른 클래스 분리 설계 원칙 (Controller, Repository, Model)
- 클래스 간의 협력 방식: 의존 관계(Dependency)와 위임(Delegation)

---

## 어려웠던 점 💣

* `default` 접근 제어자는 별도의 키워드가 없어 처음에는 그 존재 자체를 인식하기 어려웠다. '아무것도 쓰지 않으면 `default`'이며, '같은 패키지 내에서만 접근 가능'하다는 의미의 '
  package-private'으로 이해하니 명확해졌다.

* 캡슐화의 필요성이 처음에는 잘 와닿지 않았다. 필드에 직접 접근하는 것이 더 간편해 보였지만, Setter 메서드 내부에 유효성 검증 로직(`"D", "R", "N", "P"` 외의 값은 허용하지 않는 등)을
  추가하는 예제를 보고 나서야, 데이터의 무결성을 지키고 객체가 스스로를 보호하기 위한 중요한 안전장치임을 깨달았다.

* `UserController`가 `UserRepository`를 필드로 가지고 있는 '부품' 같은 구조가 낯설었다. 하지만 Controller는 '사용자와의 소통 및 작업 지시'라는 책임을,
  Repository는 '데이터 저장 및 관리'라는 책임을 맡는 역할 분담으로 이해하니, 각자가 자신의 전문 분야에만 집중하여 코드 전체의 구조가 명확해지는 것을 보고 왜 이렇게 설계하는지 납득할 수 있었다.

* `private` 생성자의 용도가 궁금했다. 이는 클래스 외부에서 `new` 키워드로 객체를 자유롭게 생성하는 것을 막고, 오직 클래스 내부의 특정 정적 메서드(e.g., `getInstance()`)를 통해서만
  객체를 생성하도록 강제할 때 (예: 싱글턴 패턴) 사용된다는 것을 알게 되었다.

---

## 정리 🖇️

### 1. 접근 제어자 (Access Modifiers)

클래스 및 클래스의 멤버(필드, 메서드, 생성자)에 대한 외부로부터의 접근 수준을 제어하는 키워드를 학습했다.

* **학습 목표 (Why?)**:
  객체의 내부 데이터를 외부의 의도치 않은 변경으로부터 보호하고, 외부에 공개할 기능(Public API)과 내부에서만 사용할 기능을 명확히 구분하여 클래스의 안정성과 유지보수성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  접근 제어자는 접근을 허용하는 범위를 기준으로 나뉜다.
  | 접근 제어자 | 접근 가능 범위 | 설명 |
  | :--- | :--- | :--- |
  | `public` | 모든 곳 (Anywhere) | 어떤 패키지, 어떤 클래스에서든 접근 가능. 외부에 공개할 기능에 사용. |
  | `protected` | 같은 패키지 + 다른 패키지의 자식 클래스 | (오늘은 다루지 않음. 상속과 관련) |
  | `default` (package-private)| 같은 패키지 (Same Package) | **키워드를 명시하지 않음.** 같은 패키지에 속한 클래스들끼리만 접근 가능. |
  | `private` | 같은 클래스 (Same Class) | 해당 클래스 내부에서만 접근 가능. 객체의 핵심 데이터나 내부 로직을 숨길 때 사용. |

* **문법 및 사용법 (How?)**:
  ```java
  // === pac1/Service.java ===
  package pac1;
  public class Service {
      public int field1;    // 모든 곳에서 접근 가능
      int field2;           // pac1 패키지 내부에서만 접근 가능
      private int field3;   // Service 클래스 내부에서만 접근 가능
  }

  // === pac2/Main.java (다른 패키지) ===
  package pac2;
  import pac1.Service;
  public class Main {
      public static void main(String[] args) {
          Service s = new Service();
          s.field1 = 10; // public: OK
          // s.field2 = 20; // default: ERROR (다른 패키지)
          // s.field3 = 30; // private: ERROR (다른 클래스)
      }
  }
  ```

---

### 2. 캡슐화 (Encapsulation)와 Getter/Setter

객체의 중요한 데이터(필드)를 외부에서 직접 접근하지 못하도록 `private`으로 숨기고, 데이터 조회를 위한 `Getter`와 수정을 위한 `Setter` 메서드만 `public`으로 공개하는 객체 지향의 핵심
원칙을 학습했다.

* **학습 목표 (Why?)**:
  데이터의 무결성(Integrity)을 보장하기 위함이다. Setter 메서드 내부에 유효성 검증 로직을 추가함으로써, 객체가 항상 유효한 상태를 유지하도록 강제할 수 있다. 또한, 내부 구현을 숨기고 외부에는
  사용법만 공개하여 클래스의 독립성을 높인다.

* **핵심 원리 (What?)**:
    * **정보 은닉 (Information Hiding)**: `private` 키워드를 사용하여 필드를 외부로부터 숨긴다.
    * **인터페이스 제공**: `public`으로 선언된 Getter와 Setter 메서드를 통해 데이터에 대한 접근 통로를 제공한다.

* **문법 및 사용법 (How?)**:
  ```java
  public class Engine {
      private String mode;    // 변속 모드 (private으로 보호)
      private boolean isOn;   // 시동 상태 (private으로 보호)

      // Setter: mode 필드를 수정할 수 있는 유일한 통로
      public void setMode(String mode) {
          // 유효성 검증 로직: 허용된 값("D", "R", "N", "P")만 설정하도록 강제
          switch (mode) {
              case "D", "R", "N", "P":
                  this.mode = mode;
                  break;
              default:
                  System.out.println("잘못된 모드 설정입니다. 'P'로 자동 설정됩니다.");
                  this.mode = "P";
          }
      }

      // Getter: mode 필드를 조회할 수 있는 유일한 통로
      public String getMode() {
          return this.mode;
      }

      // 복잡한 내부 동작은 private 메서드로 숨김
      private void injectFuel() { /* ... */ }
      private void ignite() { /* ... */ }

      // 외부에 공개된 간단한 기능
      public void startEngine() {
          injectFuel();
          ignite();
          this.isOn = true;
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 모든 필드에 무조건적으로 Getter/Setter를 만드는 것은 좋지 않다. 외부에서 수정할 필요가 없는 필드는 Setter를 만들지 않아 **읽기 전용(Read-only)**으로 만들 수 있다.

---

### 3. 객체 지향 설계: 역할, 책임, 협력

각 클래스가 하나의 명확한 책임(역할)을 갖도록 설계하고, 이들이 서로 협력하여 전체 기능을 완성하는 방식을 학습했다.

* **학습 목표 (Why?)**:
  하나의 클래스가 너무 많은 일을 하는 것을 방지하고, 각 클래스를 독립적인 '부품'처럼 만들어 코드의 재사용성과 유지보수성을 높이기 위함이다.

* **핵심 원리 (What?)**:
    * **역할과 책임 (Role & Responsibility)**: 모든 클래스는 하나의 명확한 역할을 가져야 한다. (e.g., '데이터를 저장하는 역할', '사용자 입력을 받는 역할')
    * **의존과 위임 (Dependency & Delegation)**: 한 클래스(e.g., `Controller`)가 다른 클래스(e.g., `Repository`)의 기능을 필요로 할 때, 그 클래스를 '
      부품'으로 사용(의존)하고, 관련된 작업을 그에게 맡긴다(위임).

* **문법 및 사용법 (How?)**:
  ```java
  // UserController는 사용자 입력을 받고, 실제 데이터 처리는 UserRepository에 '위임'한다.
  // 이를 위해 UserController는 UserRepository에 '의존'한다.
  public class UserController {
      // 부품 객체를 필드로 가짐 (의존 관계)
      private final UserRepository repository = new UserRepository();

      public void processRegistration() {
          // 1. Controller는 사용자 입력을 받는 책임에 집중
          // ... Scanner로 이메일, 비밀번호 등 입력받음 ...

          // 2. 입력받은 정보로 데이터 객체(Model) 생성
          User newUser = new User(...);

          // 3. 실제 데이터 저장 작업은 전문가인 Repository에 '위임'
          repository.save(newUser);
      }
  }
  ```

---

## 오늘의 깨달음 💡

* 캡슐화는 단순히 코드를 숨기는 것이 아니라, 객체가 스스로의 상태를 책임지고 **'보호'**하는 것이다. Setter에 유효성 검증 로직을 추가하는 순간, 객체는 외부의 잘못된 데이터로부터 스스로를 지킬 수 있는
  능동적인 존재가 되었다.

* 좋은 객체 지향 설계는 **'위임'**을 잘하는 것이다. `UserController`가 데이터 저장 로직까지 모두 떠안으려 하지 않고, 데이터 전문가인 `UserRepository`에게 일을 맡기는 것처럼, 각
  객체가 자신의 전문 분야에만 집중하게 만드는 것이 효율적인 분업이자 좋은 설계의 핵심임을 깨달았다.

* `private`은 필드를 보호하는 용도뿐만 아니라, 복잡한 public 메서드의 내부 로직을 잘게 쪼갠 '도우미(helper)' 메서드를 숨기는 데도 유용했다. 이를 통해 외부에 공개되는 인터페이스는 단순하게
  유지하면서, 내부 구현은 체계적으로 정리할 수 있었다.

* 접근 제어자는 클래스를 설계할 때 가장 먼저 고민해야 할 부분이다. "이 데이터는 누가 수정할 수 있는가?", "이 기능은 누가 호출할 수 있는가?"를 미리 정하는 것이, 다른 개발자와의 '약속'을 정의하고
  안정적인 소프트웨어를 만드는 첫걸음이다.