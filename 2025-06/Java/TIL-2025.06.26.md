# TIL - 2025.06.26 - 자바 객체 지향 프로그래밍(OOP) 기초 및 패키지 개념 이해

## 카테고리 🏷️

#TIL #Java #OOP #Class #Object #Constructor #this #Package #import

---

## 오늘 배운 내용 🔍

- 객체 지향 프로그래밍(OOP)의 핵심 요소: 클래스(Class)와 객체(Object)
- 클래스의 3대 구성 요소: 필드(Field), 생성자(Constructor), 메서드(Method)
- 객체 생성 시 필드를 초기화하는 생성자의 역할과 `this` 키워드의 두 가지 용법(`this.` vs. `this()`)
- 참조 타입인 `String` 객체의 내용 비교(`equals`)와 주소 비교(`==`), 그리고 String Constant Pool
- 코드의 구조화와 이름 충돌 방지를 위한 패키지(Package)와 임포트(Import)

---

## 어려웠던 점 💣

* **`static`이 없는 세상으로의 전환**: `main` 메서드 안에서 모든 것을 해결할 때와 달리, 클래스의 일반 메서드에는 `static`이 없어 `main`에서 직접 호출할 수 없다는 점이 혼란스러웠다.
  `static` 멤버는 '클래스' 소속으로 프로그램 시작 시 메모리에 로드되고, `static`이 없는 멤버는 '객체' 소속으로 `new`를 통해 객체를 생성해야만 사용할 수 있다는 근본적인 차이를 받아들이는 데
  시간이 걸렸다.

* **필드와 지역 변수의 미묘한 차이**: 클래스 바로 아래에 선언된 변수(필드)와 메서드 안에 선언된 변수(지역 변수)가 시각적으로 비슷해 보여 혼동했다. 필드는 객체가 살아있는 동안 계속 유지되는 '객체의
  속성'인 반면, 지역 변수는 메서드가 실행되는 동안에만 잠시 사용되고 사라지는 '임시 작업 공간'이라는 생명 주기의 차이를 명확히 구분해야 했다.

* **기본 생성자가 사라지는 현상**: 매개변수가 있는 생성자를 직접 정의하자, `new MyClass();`와 같이 매개변수 없는 기본 생성자 호출이 컴파일 에러를 일으켜 당황했다. JVM이 제공하는 기본
  생성자는 '개발자가 어떤 생성자도 만들지 않았을 때'만 제공되는 편의 기능이며, 생성자를 하나라도 직접 만드는 순간 그 책임은 온전히 개발자에게 넘어온다는 것을 깨달았다.

* **NullPointerException의 원인**: `Vehicle` 객체를 생성하고 그 부품인 `Owner` 필드를 초기화하지 않은 상태에서 `vehicle.owner.name`에 접근하자
  `NullPointerException`이 발생했다. `owner` 필드가 `null` 상태, 즉 아무 객체도 가리키지 않는 '허공'이었는데, 그 허공에 대고 `.name`을 요청한 셈이었다. 객체 타입의 필드는
  선언뿐만 아니라, 반드시 `new`를 통해 실제 객체를 생성하고 연결해줘야 함을 뼈저리게 느꼈다.

* **문자열의 `==` 비교가 예측 불가능했던 이유**: `String s1 = "kim";`과 `String s2 = "kim";`은 `==` 비교 시 `true`가 나오지만, `Scanner`로 입력받은
  문자열이나 `new String("kim")`과 비교하면 `false`가 나와 혼란스러웠다. 이는 자바가 메모리 효율을 위해 리터럴로 생성된 문자열을 **'String Constant Pool'**이라는 특별한
  공간에서 재활용하기 때문이었다. 반면, `new` 키워드나 메서드 호출은 항상 새로운 객체를 힙에 생성하므로 주소값이 달라진다. 이를 통해 문자열의 '내용'이 같은지 비교할 때는 출처와 상관없이 항상
  `.equals()`를 사용해야 한다는 규칙을 확실히 깨달았다.

---

## 정리 🖇️

### 1. 클래스(Class)와 객체(Object)

객체 지향 프로그래밍의 가장 핵심적인 개념으로, '붕어빵 틀'과 '붕어빵'에 비유할 수 있다.

* **학습 목표 (Why?)**:
  현실 세계의 사물이나 개념을 속성(데이터)과 기능(행동)을 가진 독립적인 단위(객체)로 모델링하여, 코드의 재사용성을 높이고 복잡한 프로그램을 더 쉽게 이해하고 관리하기 위함이다.

* **핵심 원리 (What?)**:

  | 구분 | 클래스 (Class) | 객체 (Object / Instance) |
      | :--- | :--- | :--- |
  | **개념** | **설계도, 템플릿**. 객체가 가져야 할 필드와 메서드를 정의한다. | **설계도로 만들어낸 실체**. 클래스에 정의된 속성과 기능을 실제로 가지며, 메모리에 할당된다. |
  | **특징** | 클래스 하나로 여러 개의 객체를 만들 수 있다. | 각 객체는 고유한 상태(필드 값)를 가질 수 있다. |

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 클래스 정의 (설계도 만들기)
  public class User {
      String name; // 필드
      int age;     // 필드

      void introduce() { // 메서드
          System.out.println("이름: " + name + ", 나이: " + age);
      }
  }

  // 2. 객체 생성 (실체 만들기) 및 사용
  public class Main {
      public static void main(String[] args) {
          User user1 = new User(); // new 키워드로 객체 생성 (인스턴스화)
          user1.name = "Alice";
          user1.age = 30;
          user1.introduce();

          User user2 = new User();
          user2.name = "Bob";
          user2.age = 25;
          user2.introduce();
      }
  }
  ```

---

### 2. 클래스의 구성 요소: 필드, 생성자, 메서드

클래스는 객체의 데이터와 동작을 정의하는 세 가지 주요 요소로 구성된다.

* **학습 목표 (Why?)**:
  객체의 상태를 저장하고(`필드`), 객체가 생성될 때 초기 상태를 설정하며(`생성자`), 객체가 수행할 수 있는 동작을 정의하는(`메서드`) 방법을 이해하기 위함이다.

* **핵심 원리 (What?)**:
    * **필드 (Field)**: 객체의 **데이터(속성)**를 저장하는 변수. 객체의 상태를 나타낸다.
    * **생성자 (Constructor)**: `new` 키워드로 객체가 생성될 때 **단 한 번 호출**되어 필드를 초기화하는 특수한 메서드. 클래스 이름과 동일하며 반환 타입이 없다.
    * **메서드 (Method)**: 객체의 **동작(기능)**을 정의하는 코드 블록. 객체의 필드 값을 변경하거나 특정 연산을 수행한다.

* **문법 및 사용법 (How?)**:
  ```java
  public class Vehicle {
      // 1. 필드 (Fields)
      String company;
      String model;
      int currentSpeed;

      // 2. 생성자 (Constructor)
      public Vehicle(String company, String model) {
          // this. : 필드와 매개변수 이름이 같을 때, 필드를 명시적으로 가리킴
          this.company = company;
          this.model = model;
          this.currentSpeed = 0; // 생성 시 초기 속도 설정
      }

      // 3. 메서드 (Methods)
      void accelerate(int speed) {
          this.currentSpeed += speed;
      }

      void showStatus() {
          System.out.printf("%s %s의 현재 속도: %dkm/h\n", company, model, currentSpeed);
      }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`this`의 두 가지 용법**:
        1. `this.필드명`: 객체 자기 자신의 필드를 가리키는 참조.
        2. `this()`: 생성자 내부에서 같은 클래스의 다른 생성자를 호출. 반드시 생성자의 첫 줄에 위치해야 한다.
    * **`NullPointerException`**: 객체 타입의 필드(부품 객체)는 `new`를 통해 실제 객체를 생성하여 할당해주지 않으면 기본값인 `null`을 가진다. `null`인 참조 변수에 대고
      `. `을 찍어 메서드나 필드를 호출하려 하면 이 예외가 발생한다.

---

### 3. 패키지(Package)와 임포트(Import)

클래스들을 체계적으로 관리하고 이름 충돌을 방지하기 위한 자바의 폴더 시스템을 학습했다.

* **학습 목표 (Why?)**:
  프로젝트 규모가 커졌을 때 수많은 클래스 파일을 기능별, 역할별로 구조화하고, 다른 사람이 만든 클래스나 자바 표준 라이브러리의 클래스와 이름이 겹치더라도 문제없이 사용하기 위함이다.

* **핵심 원리 (What?)**:
    * **패키지 (Package)**: 클래스들을 모아두는 폴더. 클래스의 고유한 소속 주소(Full Qualified Name)가 된다. (e.g., `java.util.Scanner`)
    * **임포트 (Import)**: 다른 패키지에 있는 클래스를 현재 파일에서 짧은 이름으로 사용하기 위해 '바로가기'를 만드는 기능.

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 패키지 선언 (파일 최상단)
  package com.mycompany.app.domain;

  // 2. 다른 패키지의 클래스 임포트
  import java.util.Scanner; // java.util 패키지의 Scanner 클래스 하나만 임포트
  import com.mycompany.app.service.*; // service 패키지의 모든 클래스 임포트

  public class UserInputHandler {
      private Scanner scanner; // 'Scanner' 라는 짧은 이름으로 사용 가능

      public UserInputHandler() {
          // import가 없다면 new java.util.Scanner(System.in) 이라고 써야 함
          this.scanner = new Scanner(System.in);
      }
  }
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * **패키지 명명 규칙**: 전 세계적으로 중복되지 않도록, 보통 회사의 **도메인을 거꾸로 사용**한다. (e.g., `com.google.project`) 이는 단순한 폴더 구조를 넘어, 코드의 고유
      식별자 역할을 한다.
    * **`import ...*`**: 와일드카드(`*`) 임포트는 해당 패키지 바로 아래의 클래스들만 가져오며, 그 하위 패키지까지 재귀적으로 가져오지는 않는다.
    * **`import static`**: 클래스 이름을 생략하고 `static` 멤버(변수, 메서드)를 직접 사용할 수 있게 해준다. (e.g., `PI`, `pow` 대신 `Math.PI`,
      `Math.pow`)

---

## 오늘의 깨달음 💡

* **객체 지향은 '부품'을 조립하여 '완성품'을 만드는 과정과 같았다.** `Vehicle`이 `Owner`를 필드로 가지는 것을 보며, 복잡한 객체는 더 작은 객체들의 조합으로 이루어진다는 'HAS-A' 관계를
  이해했다. 이는 현실 세계의 사물을 모델링하는 객체 지향의 강력함을 보여주는 부분이었다.

* **`static`의 유무는 '소속'의 차이다.** `static` 멤버는 클래스 전체가 공유하는 '공용 시설'이고, `static`이 없는 멤버는 각 객체가 개별적으로 소유하는 '개인 물품'과 같았다.
  `main`이라는 공용 공간에서는 다른 공용 시설에만 바로 접근할 수 있었던 것이다.

* **`this.`는 '내 물건'을, `this()`는 '다른 나에게 부탁'하는 것을 의미했다.** `this.`은 '이 객체의 필드'를 명확히 가리키는 지시 대명사였고, `this()`는 생성자 코드의 중복을
  피하기 위해 '이 클래스의 다른 생성자'에게 초기화 작업을 위임하는 특별한 호출이었다.

* **문자열 비교는 '주민등록증'과 '이름'의 차이였다.** `==`는 두 사람이 완전히 동일 인물인지(주민등록번호, 즉 주소 비교) 확인하는 것이고, `.equals()`는 두 사람의 이름이 같은지(내용 비교)
  확인하는 것과 같았다. 동명이인이 있을 수 있듯, 내용이 같아도 실체는 다른 객체일 수 있으므로 항상 `.equals()`를 사용하는 것이 안전하다.

* **패키지는 내 코드의 '주민등록번호'와 같았다.** 단순한 폴더가 아니라, 전 세계의 수많은 코드 속에서 내 클래스의 유일무이한 신분을 보장해주는 중요한 식별자였다. 도메인을 거꾸로 쓰는 이유가 바로 이 '신분
  보장' 때문이었다.

* `import`는 '바로가기' 그 이상도 이하도 아니었다. `import`를 한다고 해서 파일이 실제로 복사되거나 성능이 달라지는 것이 아니었다. 단지 컴파일러에게 "이 클래스 이름은 사실 이 긴 주소를 의미하는
  거야"라고 알려주는, 개발자의 타이핑 수고를 덜어주는 편의 기능일 뿐이었다.