# TIL - 2025.06.23 - 자바의 기본 자료형, 형 변환 및 메모리 구조 개념 이해

## 카테고리 🏷️

#TIL #Java #DataType #TypeCasting #JVM #Stack #Heap #Array

---

## 오늘 배운 내용 🔍

- 자바의 정적 타이핑(Static Typing) 특성과 기본 자료형(Primitive Types)
- `long`과 `float` 리터럴에 접미사(`L`, `F`)가 필요한 이유
- 지역 변수 타입 추론(`var`) 키워드의 동작 원리와 오해
- 암묵적 형 변환(Promotion)과 명시적 형 변환(Casting)의 차이 및 데이터 손실 문제
- `int`보다 작은 타입의 연산 결과가 `int`가 되는 이유
- `Scanner`를 이용한 표준 입력과 `System.out`을 이용한 표준 출력
- 배열의 선언, 생성, 초기화 및 메모리(스택/힙)에서의 동작 방식

---

## 어려웠던 점 💣

* **`long`과 `float` 타입 값 뒤에 붙는 접미사(`L`, `F`)의 정체**: `long num = 10000000000L;` 처럼 `L`을 붙이는 것이 단순 문법 규칙인 줄 알았으나, 이는 자바
  컴파일러가 숫자 리터럴을 기본적으로 `int`로 인식하기 때문이었다. `int`의 범위를 초과하는 숫자는 컴파일러에게 "이 숫자는 `long` 타입의 값이다"라고 `L`을 붙여 명시적으로 알려줘야 한다는 근본적인
  원리를 이해해야 했다. `float`에 `F`를 붙이는 것도 마찬가지로, 기본 타입인 `double`이 아님을 알려주는 것이었다.

* **`var` 키워드에 대한 오해**: `var x = 10;` 코드를 보고 JavaScript처럼 동적 타이핑이 되는 것으로 착각했다. 하지만 자바의 `var`는 컴파일 시점에 타입을 단 한 번 추론하여
  결정하는 **'타입 추론'** 기능일 뿐, 자바의 정적 타이핑 근간을 바꾸는 것이 아니었다. `var x = 10;`은 컴파일러에 의해 `int x = 10;`으로 완전히 치환되며, 이후 다른 타입의 값을 할당할
  수 없다는 점을 명확히 구분해야 했다.

* **명시적 형 변환 시 데이터 손실**: `int` 타입의 값 `1000`을 `byte`로 강제 형 변환했을 때 `-24`라는 예상 밖의 값이 나왔다. 이는 큰 타입의 비트 정보가 작은 타입의 공간에 억지로
  담기면서 앞부분 데이터가 잘려나가고, 남은 비트 패턴이 전혀 다른 값(심지어 음수)으로 해석될 수 있다는 것을 보여주었다. 데이터 손실이 단순한 소수점 버림이 아닐 수 있다는 점에서 명시적 형 변환의 위험성을
  체감했다.

* **`byte + byte`의 결과가 `int`인 이유**: `byte` 타입 변수 두 개를 더한 결과를 다시 `byte` 변수에 담으려 할 때 발생하는 컴파일 에러가 의아했다. 이는 JVM이 연산 효율을 위해
  `int`보다 작은 타입(`byte`, `short`, `char`)들은 모두 `int`로 변환하여 연산을 수행하기 때문이었다. 언어의 내부 동작 규칙을 모르면 이해하기 힘든 부분이었다.

* **배열 변수를 출력했을 때 주소값이 나오는 현상**: `System.out.println(myArray)`를 실행했을 때 배열의 내용이 아닌 `[I@...` 와 같은 문자열이 출력되어 당황했다. 이는 배열
  변수가 실제 데이터 덩어리가 아닌, 힙(Heap) 메모리에 생성된 배열 객체의 '주소(참조)'를 저장하고 있기 때문이었다. 기본 타입과 참조 타입의 근본적인 차이를 시각적으로 확인한 경험이었다.

---

## 정리 🖇️

### 1. 자바의 자료형: 기본 타입과 참조 타입

자바는 변수에 저장될 데이터의 종류와 크기를 명확히 지정하는 **정적 타이핑(Statically Typed)** 언어다. 데이터 타입은 크게 기본 타입과 참조 타입으로 나뉜다.

* **학습 목표 (Why?)**:
  데이터의 종류에 맞는 적절한 메모리 공간을 할당하고, 컴파일 시점에 타입 오류를 미리 발견하여 안정적인 프로그램을 만들기 위함이다.

* **핵심 원리 (What?)**:
    * **기본 자료형 (Primitive Types)**: 변수 안에 **실제 값**을 직접 저장한다. 스택(Stack) 메모리에 생성된다.

      | 구분 | 타입 | 크기 | 설명 및 예시 (접미사 주의) |
              | :--- | :--- | :--- | :--- |
      | **정수형** | `byte`, `short`, **`int`**, `long` | 1, 2, **4**, 8 bytes | `int`가 정수 연산의 기본. `long` 타입 리터럴에는 `L`을 붙여야 함. `long bigNum = 3000000000L;`|
      | **실수형** | `float`, **`double`** | 4, **8** bytes | `double`이 실수 연산의 기본. `float` 타입 리터럴에는 `F`를 붙여야 함. `float pi = 3.14F;` |
      | **논리형** | `boolean` | 1 byte | `true` 또는 `false` 값을 가짐. |
      | **문자형** | `char` | 2 bytes | 단 하나의 문자를 저장 (유니코드). 작은따옴표(`'`) 사용. `char grade = 'A';` |
    * **참조 자료형 (Reference Types)**: 변수 안에는 객체의 **메모리 주소(참조)**를 저장하고, 실제 데이터는 힙(Heap) 메모리에 생성된다. `String`, `Array`,
      `Scanner` 등 클래스로 만들어진 모든 것이 해당된다.

* **문법 및 사용법 (How?)**:
    * **`var` (지역 변수 타입 추론)**: Java 10부터 도입. 지역 변수에 한해, 컴파일러가 대입되는 값을 보고 타입을 자동으로 추론해준다.
  ```java
  var userId = 1001; // 컴파일러가 int로 추론
  var message = "Success"; // 컴파일러가 String으로 추론
  // userId = "hello"; // 에러! 이미 int로 타입이 고정되었기 때문에 재할당 불가.
  ```
    * **텍스트 블록**: Java 15부터 도입. 여러 줄의 문자열을 가독성 좋게 작성할 수 있다.
  ```java
  String html = """
      <div>
          <h1>Welcome</h1>
      </div>
      """;
  ```

---

### 2. 형 변환 (Type Casting)

한 데이터 타입을 다른 데이터 타입으로 변환하는 규칙을 학습했다.

* **학습 목표 (Why?)**:
  타입이 다른 데이터 간의 연산을 가능하게 하고, 데이터의 표현 형식을 필요에 맞게 바꾸기 위함이다.

* **핵심 원리 (What?)**:

  | 구분 | 암묵적(자동) 형 변환 | 명시적(강제) 형 변환 |
      | :--- | :--- | :--- |
  | **개념** | **작은 타입 → 큰 타입**. 데이터 손실이 없어 자동으로 변환 (Promotion). | **큰 타입 → 작은 타입**. 데이터 손실 위험이 있어 `(타입)`으로 강제 (Casting). |
  | **방향** | `byte` → `short` → `int` → `long` → `float` → `double` | `double` → `float` → `long` → `int` → `short` → `byte` |
  | **예시** | `int num = 10; double dNum = num;` // 10.0으로 자동 변환 | `double dNum = 9.9; int num = (int)dNum;` // 9 (소수점 손실) |

* **주의사항 및 실무 팁 (Watch out for)**:
    * **연산 시 형 변환 규칙**:
        1. **더 큰 타입으로 자동 변환**: `int + double` 연산 시, `int`가 `double`로 변환된 후 계산되며 결과는 `double`이다.
        2. **`int`보다 작은 타입은 `int`로**: `byte`, `short`, `char` 간의 연산은 모두 `int`로 자동 변환되어 수행된다.
         ```java
         byte b1 = 10; byte b2 = 20;
         // byte b3 = b1 + b2; // 컴파일 에러! (int 결과를 byte에 담으려 함)
         int result = b1 + b2; // 정상
         ```
    * 명시적 형 변환은 값의 범위를 초과할 경우 데이터가 완전히 왜곡될 수 있으므로, 변환될 값의 범위를 명확히 알고 있을 때만 신중하게 사용해야 한다.

---

### 3. 배열(Array)과 메모리 구조 (Stack & Heap)

동일한 타입의 데이터를 묶어서 관리하는 배열의 동작 방식과, 자바의 핵심 메모리 영역인 스택과 힙의 역할을 학습했다.

* **학습 목표 (Why?)**:
  자바에서 데이터가 어떻게 저장되고 관리되는지 근본적인 원리를 이해하여, 기본 타입과 참조 타입의 동작 차이를 명확히 구분하고 메모리를 효율적으로 사용하는 코드를 작성하기 위함이다.

* **핵심 원리 (What?)**:

  | 메모리 영역 | 역할 및 저장 데이터 | 관리 방식 |
      | :--- | :--- | :--- |
  | **스택 (Stack)** | **빠른 임시 저장소.** 메서드 호출 정보, **기본 타입의 값**, **참조 타입의 주소 값** 저장. | **자동 관리.** 메서드가 호출될 때 생성(push), 종료될 때 소멸(pop). |
  | **힙 (Heap)** | **공동 데이터 저장소.** `new` 키워드로 생성된 모든 객체(배열, 클래스 인스턴스 등)의 **실제 데이터** 저장. | **가비지 컬렉터(GC)가 관리.** 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거. |

* **문법 및 사용법 (How?)**:
  ```java
  // 1. int[] scores; -> 스택에 scores라는 참조 변수 공간만 생성됨
  // 2. new int[3]; -> 힙에 int 3개를 담을 배열 객체 생성 후, 그 주소를 반환
  // 3. = -> 힙에 생성된 배열 객체의 주소값이 스택의 scores 변수에 저장됨
  int[] scores = new int[3]; // scores는 [0, 0, 0] 배열 객체의 주소를 가리킴

  // 스택에 생성되는 기본 타입 변수
  int age = 30;

  System.out.println(age); // 30 (스택에 저장된 실제 값이 출력됨)
  System.out.println(scores); // [I@주소값 (스택에 저장된 주소값이 출력됨)
  System.out.println(Arrays.toString(scores)); // [0, 0, 0] (주소를 따라가 힙의 실제 내용을 출력)
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **배열의 특징**: ① 동일한 타입만 저장 가능, ② 생성 시 크기 고정.
    * **배열 순회**: 인덱스가 필요하면 일반 `for`문, 값만 필요하면 향상된 `for-each`문을 사용하는 것이 좋다.
    * **배열의 기본값**: `new`로 생성된 배열은 값을 할당하지 않아도 타입별 기본값(정수 `0`, 실수 `0.0`, `boolean` `false`, 참조형 `null`)으로 자동 초기화된다.

---

### 4. 표준 입출력 (Standard I/O)

사용자로부터 데이터를 입력받고, 콘솔에 결과를 출력하는 기본적인 방법을 학습했다.

* **학습 목표 (Why?)**:
  프로그램이 외부(사용자, 파일 등)와 데이터를 주고받는 가장 기본적인 통로를 이해하고, 간단한 콘솔 기반 애플리케이션을 만들기 위함이다.

* **핵심 원리 (What?)**:

  | 구분 | 클래스/객체 | 설명 |
      | :--- | :--- | :--- |
  | **표준 출력**| `System.out` | `print()`, `println()`, `printf()` 메서드를 통해 콘솔에 텍스트를 출력. |
  | **표준 입력**| `java.util.Scanner` | `System.in`(키보드 입력)으로부터 데이터를 읽어오는 클래스. |

* **문법 및 사용법 (How?)**:
  ```java
  import java.util.Scanner; // Scanner 클래스 import
  import java.util.Arrays; // Arrays 클래스 import (배열 출력용)

  public class IoExample {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);

          System.out.print("이름을 입력하세요: ");
          String name = scanner.nextLine(); // 한 줄을 문자열로 읽어옴

          System.out.print("나이를 입력하세요: ");
          int age = Integer.parseInt(scanner.nextLine()); // 문자열로 읽은 후 정수로 변환

          // printf를 이용한 서식 지정 출력
          System.out.printf("안녕하세요, %s님 (%d세)\n", name, age);

          scanner.close(); // 자원 반납
      }
  }
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * `scanner.nextInt()` 사용 후 `scanner.nextLine()`을 호출하면, `nextInt()`가 남긴 개행 문자(`\n`) 때문에 `nextLine()`이 입력을 건너뛰는 문제가
      발생할 수 있다. 이를 방지하기 위해 **모든 입력을 `nextLine()`으로 받고, 필요시 `Integer.parseInt()`, `Double.parseDouble()` 등으로 변환**하는 패턴을
      사용하는 것이 더 안전하고 예측 가능하다.

---

## 오늘의 깨달음 💡

* 자바가 '정적 타이핑' 언어라는 말의 의미를 체감했다. 변수를 선언할 때 타입을 명시하는 것이 처음에는 번거롭게 느껴졌지만, 이는 컴파일 단계에서부터 타입 불일치 에러를 잡아주는 **'안전장치'** 역할을 한다.
  실수를 미리 방지하여 런타임에 발생할 수 있는 예측 불가능한 오류를 크게 줄여준다.

* 컴파일러의 **'기본(Default) 규칙'**을 아는 것이 중요하다. 정수는 `int`로, 실수는 `double`로 인식하는 기본 규칙 때문에 `long`과 `float`에 접미사가 필요했다. 마찬가지로,
  `byte`끼리의 연산 결과가 `int`가 되는 것도 JVM 내부의 연산 기본 단위가 `int`이기 때문이다. 언어의 생략된 규칙이나 기본 동작을 이해해야 불필요한 에러를 피할 수 있다.

* `var`는 자바의 철학을 해치지 않는 선에서 개발자에게 편의성을 제공하는 **'현명한 타협점'**처럼 느껴졌다. 타입 안정성은 그대로 유지하면서, 반복적인 타입 선언을 줄여 코드의 간결함과 가독성을 높여준다.

* **변수의 생명주기(Scope)**는 단순히 문법 규칙이 아니라, **효율적인 메모리 관리**와 **코드의 안정성**을 위한 핵심적인 장치다. 변수가 필요한 곳에서만 살아있다가 사라짐으로써, 메모리 낭비를 막고
  다른 영역에서 같은 이름의 변수를 써도 충돌이 나지 않게 보호해준다.

* **형 변환은 개발자의 의도를 명확히 하는 행위다.** 암묵적 형 변환은 "데이터 손실이 없으니 안전하게 변환해줘"라는 의미이고, 명시적 형 변환은 "데이터가 손실될 수 있음을 인지하고 있으며, 그럼에도 불구하고
  변환을 강행하겠다"는 개발자의 명확한 의사 표시다.

* `System.out.println(array)`를 통해 **참조 변수의 실체**를 마주했다. 변수가 값을 직접 갖는 기본형과 달리, 주소를 통해 객체를 가리키는 참조형의 개념을 시각적으로 깨닫게 된 중요한
  경험이었다. `null`이라는 기본값 역시 '아무것도 가리키고 있지 않음'을 의미하는, 참조형의 본질을 보여주는 값이었다.

* **스택과 힙의 역할 분담을 통해 자바의 메모리 관리가 명확히 이해됐다.** 왜 기본 타입은 메서드가 끝나면 바로 사라지는데, `new`로 만든 객체는 그렇지 않은지 의문이었다. 값 자체를 저장하는 **'임시
  작업 공간'인 스택**과, 객체를 보관하는 **'공동 창고'인 힙**으로 역할이 나뉘어 있다는 것을 알고 나니 모든 것이 명확해졌다. `new`는 창고에 물건을 넣는 행위이고, 참조 변수는 그 물건을 찾기
  위한 '보관증'과 같았다.