# TIL - 2025.06.24 - 자바 배열의 동적 관리와 2차원 배열 구조 개념 이해

## 카테고리 🏷️

#TIL #Java #Array #DataStructure #DeepCopy #ShallowCopy #Algorithm #2DArray

---

## 오늘 배운 내용 🔍

- 배열의 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점
- `for`문과 `Arrays.copyOf`를 이용한 배열의 깊은 복사 방법
- 배열의 '크기 불변' 특성으로 인해 발생하는 데이터 추가(`push`) 및 삭제(`pop`) 알고리즘
- 배열의 특정 인덱스에 데이터를 삽입하고 삭제하는 알고리즘
- '배열의 배열' 구조인 2차원 배열의 선언, 초기화 및 순회 방법
- 문자열 비교 시 `==`가 아닌 `.equals()`를 사용해야 하는 이유

---

## 어려웠던 점 💣

* **얕은 복사의 함정**: `String[] copy = original;` 코드가 배열의 모든 내용을 복사하는 것이 아니라, 힙(Heap) 메모리에 있는 동일한 배열 객체를 가리키는 **'주소값'만 복사**
  한다는 점을 이해하기 어려웠다. 결국 두 변수가 하나의 실체를 공유하게 되어, 사본을 수정하면 원본까지 변경되는 현상을 통해 참조 타입의 동작 방식을 다시 한번 깨달았다.

* **배열 추가/삭제의 본질**: 배열에 데이터를 추가하거나 삭제하기 위해 매번 ①더 크거나 작은 새 배열을 만들고, ②기존 데이터를 일일이 복사한 뒤, ③원본 변수가 새 배열을 가리키도록 '교체'하는 과정이
  비효율적으로 느껴졌다. 이는 자바 배열의 **'크기 불변(fixed-size)'**이라는 본질적 특성 때문이며, 이러한 제약이 성능과 메모리 예측 가능성을 보장하는 트레이드오프 관계임을 이해했다.

* **중간 삽입 알고리즘의 '역방향' 반복**: 배열 중간에 데이터를 삽입하기 위해 기존 요소들을 뒤로 한 칸씩 밀 때, `for`문을 순방향(`i++`)으로 실행하면 데이터가 덮어씌워지는 문제가 발생했다. 이
  문제를 해결하려면 반드시 배열의 **끝에서부터 역방향(`i--`)으로 반복**해야 한다는 점이 알고리즘의 핵심이었고, 반복문의 방향성이 로직의 성패를 가른다는 것을 알게 되었다.

* **2차원 배열과 `Arrays.toString()`**: 2차원 배열에 `Arrays.toString()`을 사용했을 때, 예상과 달리 내부 배열들의 주소값이 출력되어 당황했다. 이를 통해 2차원 배열의
  실체는 '1차원 배열들의 주소값을 요소로 갖는 배열'이라는 것을 명확히 이해했다. 중첩된 내용까지 모두 보려면 `Arrays.deepToString()`이라는 전용 메서드를 사용해야 했다.

---

## 정리 🖇️

### 1. 배열 복사: 얕은 복사(Shallow Copy) vs. 깊은 복사(Deep Copy)

배열은 참조 타입이므로, 변수 간의 단순 대입(`=`)은 주소값만 복사하는 '얕은 복사'가 된다. 실제 데이터까지 모두 복사하려면 '깊은 복사'가 필요하다.

* **학습 목표 (Why?)**:
  원본 데이터를 훼손하지 않고 배열의 사본을 안전하게 조작하기 위해, 두 복사 방식의 차이점을 명확히 이해하고 상황에 맞는 복사 방법을 사용하기 위함이다.

* **핵심 원리 (What?)**:

  | 구분 | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) |
      | :--- | :--- | :--- |
  | **개념** | 객체의 **주소값**만 복사. 원본과 사본이 **동일한 객체**를 공유. | 객체의 **실제 값**을 새로운 메모리 공간에 복사. 원본과 사본이 **서로 다른 독립적인 객체**. |
  | **코드** | `String[] copy = original;` | `Arrays.copyOf(original, length);` 또는 `for`문으로 직접 복사. |
  | **결과** | 사본을 변경하면 **원본도 함께 변경됨**. | 사본을 변경해도 **원본은 영향을 받지 않음**. |

* **문법 및 사용법 (How?)**:
  ```java
  // 얕은 복사: 주소값만 복사됨
  String[] foods = {"치킨", "피자"};
  String[] favoriteFoods = foods;
  favoriteFoods[0] = "족발";
  System.out.println(Arrays.toString(foods)); // [족발, 피자] (원본이 변경됨!)

  // 깊은 복사: Arrays.copyOf() 사용 (권장)
  String[] products = {"Laptop", "Mouse"};
  String[] productsCopy = Arrays.copyOf(products, products.length);
  productsCopy[0] = "Monitor";
  System.out.println(Arrays.toString(products)); // [Laptop, Mouse] (원본 유지!)
  ```

---

### 2. 배열의 동적 관리 알고리즘

배열의 '크기 불변' 특성 때문에, 데이터를 추가하거나 삭제하려면 새로운 배열을 만들어 기존 데이터를 옮기는 과정이 필요하다.

* **학습 목표 (Why?)**:
  크기가 고정된 배열을 동적으로 관리하는 기본적인 알고리즘을 이해하고, `ArrayList`와 같은 동적 배열 클래스의 내부 동작 원리를 추론해보기 위함이다.

* **핵심 원리 (What?)**:
  배열의 추가/삭제는 기존 배열 객체를 '수정'하는 것이 아니라, 조건에 맞게 새로 만든 배열로 참조를 '교체'하는 작업이다.

* **문법 및 사용법 (How?)**:
    * **데이터 추가 (`push` 로직)**
        1. 기존 배열보다 크기가 1 더 큰 새 배열(`temp`)을 만든다.
        2. `Arrays.copyOf()` 등을 이용해 기존 데이터를 `temp`로 복사한다.
        3. `temp` 배열의 마지막 인덱스에 새 데이터를 추가한다.
        4. 원본 배열 변수가 `temp` 배열을 가리키도록 주소값을 교체한다. (`numbers = temp;`)

    * **데이터 삭제 (`pop` 로직)**
        1. 기존 배열보다 크기가 1 더 작은 새 배열(`temp`)을 만든다.
        2. `Arrays.copyOf()` 등을 이용해 마지막 요소를 제외한 나머지 데이터만 `temp`로 복사한다.
        3. 원본 배열 변수가 `temp` 배열을 가리키도록 주소값을 교체한다.

    * **특정 인덱스 데이터 삭제**
        1. 삭제할 인덱스(`delIdx`) 뒤의 모든 요소를 `for`문을 이용해 한 칸씩 앞으로 당긴다. (`arr[i] = arr[i+1];`)
        2. 위의 `pop` 로직을 수행하여, 크기가 1 작은 배열로 복사하여 마지막 중복 데이터를 제거한다.

    * **특정 인덱스 데이터 삽입**
        1. 기존 배열보다 크기가 1 더 큰 새 배열(`temp`)을 만든다.
        2. **역방향 `for`문**을 이용해 삽입할 인덱스(`insertIdx`)부터 끝까지의 요소들을 뒤로 한 칸씩 민다. (`temp[i] = arr[i-1];`)
        3. `temp`의 `insertIdx` 자리에 새 데이터를 삽입한다.
        4. `0`부터 `insertIdx - 1`까지의 앞부분 데이터를 `temp`에 복사한다.
        5. 원본 배열 변수가 `temp` 배열을 가리키도록 주소값을 교체한다.

---

### 3. 배열 탐색과 문자열 비교

배열에서 원하는 데이터를 찾고, 참조 타입인 문자열을 올바르게 비교하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  배열에 특정 데이터가 존재하는지 확인하거나, 그 위치(인덱스)를 찾아내는 기본적인 탐색 로직을 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **선형 탐색 (Linear Search)**: 배열의 첫 요소부터 끝까지 순차적으로 비교하여 값을 찾는다.
    * **문자열 비교**:

      | 비교 방식 | `==` | `.equals()` |
              | :--- | :--- | :--- |
      | **비교 대상**| **주소값 (참조)** | **내용 (문자열 값)** |
      | **사용 목적**| 두 변수가 동일한 객체를 가리키는지 확인 | 두 객체의 문자열 내용이 같은지 확인 |

* **문법 및 사용법 (How?)**:
  ```java
  String[] members = {"Alice", "Bob", "Charlie"};
  String target = "Bob";
  int index = -1; // '찾지 못함'을 의미하는 초기값

  for (int i = 0; i < members.length; i++) {
    // 주소 비교(==)가 아닌 내용 비교(.equals())를 사용해야 함!
    if (members[i].equals(target)) {
      index = i;
      break;
    }
  }
  System.out.println(target + "의 인덱스: " + index); // 1
  ```

---

### 4. 2차원 배열 (Multidimensional Array)

'배열의 배열' 형태로, 행과 열을 가지는 격자 구조의 데이터를 다루는 방법을 학습했다.

* **학습 목표 (Why?)**:
  표, 게임 맵, 행렬 등 2차원 구조의 데이터를 효율적으로 표현하고 처리하기 위함이다.

* **핵심 원리 (What?)**:
  2차원 배열 변수는 **1차원 배열들의 주소값을 요소로 갖는 배열**을 참조한다.

* **문법 및 사용법 (How?)**:
  ```java
  // 2차원 배열 선언 및 초기화
  int[][] matrix = {
      {10, 20, 30},
      {40, 50, 60}
  };

  // 값 접근: matrix[행][열]
  System.out.println(matrix[1][2]); // 60

  // 2차원 배열 순회 (중첩 for-each문)
  for (int[] row : matrix) { // 각 행(1차원 배열)을 순회
    for (int cell : row) { // 각 행의 요소(셀)를 순회
      System.out.print(cell + " ");
    }
    System.out.println();
  }

  // 2차원 배열 내용 출력 (Arrays.deepToString() 사용)
  System.out.println(Arrays.deepToString(matrix)); // [[10, 20, 30], [40, 50, 60]]
  ```

---

## 오늘의 깨달음 💡

* 배열 변수에 `=` 연산자를 사용하는 것은 복사기를 쓰는 행위가 아니라, 같은 대상을 가리키는 '포스트잇'을 하나 더 붙이는 행위와 같았다. 객체의 독립적인 사본을 원한다면, 반드시 새로운 공간을 만드는 '깊은
  복사'를 해야 한다는 것을 명확히 이해했다.

* 자바 배열의 '크기 불변'이라는 제약은 불편함이 아니라, 메모리 구조를 단순화하고 데이터 접근 속도를 높이기 위한 **의도된 설계**임을 깨달았다. 데이터의 추가/삭제가 빈번하다면 배열 대신 `ArrayList`
  와 같은 동적 자료구조를 사용하는 것이 더 현명한 선택이다.

* 배열 중간에 데이터를 삽입하거나 삭제하는 알고리즘은 퍼즐을 맞추는 것과 같았다. 데이터를 덮어쓰지 않기 위해 **어느 방향으로 루프를 돌려야 하는지**, 그리고 **어떤 순서로 데이터를 이동시켜야 하는지**를
  고민하는 과정 자체가 알고리즘적 사고의 좋은 훈련이 되었다.

* `String`과 같은 참조 타입을 비교할 때 `==` 연산자가 얼마나 위험할 수 있는지 다시 한번 깨달았다. '겉모습(내용)'이 같아도 '실체(주소)'는 다를 수 있으므로, 항상 `.equals()`로 내용을
  비교하는 습관을 들여야 한다.

* 2차원 배열은 특별한 문법이 아니라, '배열을 담는 배열'이라는 단순한 개념의 확장일 뿐이었다. `matrix[i]`가 또 다른 1차원 배열이라는 사실을 인지하자, 중첩 `for`문을 이용한 순회나
  `Arrays.deepToString()`의 필요성이 자연스럽게 이해되었다.