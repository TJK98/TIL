# TIL - 2025.06.17 - 클로저 상태 관리, 폼 유효성 검사 및 게임 로직 구현 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Closure #StateManagement #Validation #DOM

---

## 오늘 배운 내용 🔍

- 클로저(Closure)를 활용한 객체 상태 캡슐화 및 관리 방법
- 사용자 입력에 대한 실시간/제출 시 폼 유효성 검사(Validation) 로직
- 입력 이벤트 최적화를 위한 디바운스(Debounce) 기법의 적용
- 숫자 추리 게임 구현을 통한 종합적인 상태 관리, DOM 조작 및 UI 흐름 설계
- 상태에 따른 UI 동적 업데이트 및 버튼 활성화/비활성화 제어

---

## 어려웠던 점 💣

* 폼 제출 이벤트 핸들러에서 `e.preventDefault()`의 호출 위치가 중요했다. 유효성 검사 로직 뒤에 `preventDefault()`를 두면, 검사가 실패하더라도 이미 폼이 제출(새로고침)된 후일 수
  있다는 점을 깨달았다. 따라서 **핸들러의 가장 첫 줄에서 기본 동작을 먼저 막는 것**이 안정적인 패턴임을 알게 되었다.

* `input.value`로 받아온 사용자 입력값은 항상 **문자열** 타입이라는 점을 간과하여 숫자 비교 시 오류를 겪었다. `Number()` 함수를 통해 명시적으로 숫자 타입으로 변환해야 하고, 소수점 입력
  등을 방지하기 위해 `Number.isInteger()`로 정수 여부까지 검증하는 과정의 필요성을 이해했다.

* 게임의 피드백 메시지(e.g., "UP", "DOWN")를 업데이트하는 DOM 조작 코드의 위치에 따라 UI가 어색하게 보이는 문제가 있었다. 사용자의 행동에 대한 피드백은 즉각적으로 이루어져야 하므로, 상태를
  변경하는 로직 바로 다음에 UI를 업데이트하는 코드를 배치하는 등 **DOM 조작의 실행 시점**을 신중하게 설계해야 함을 깨달았다.

* 여러 상태(e.g., 'UP', 'DOWN', '정답')에 따라 피드백 텍스트의 클래스를 변경할 때, `classList.add()`만 사용하면 이전 상태의 클래스가 남아 스타일이 꼬이는 문제가 발생했다. 이
  경우 `element.className = 'feedback-text up';`과 같이 클래스 전체를 새로 할당하는 방식이 더 예측 가능하고 안정적일 수 있음을 알게 되었다.

---

## 정리 🖇️

### 1. 클로저를 이용한 상태 관리

외부에서 직접 접근할 수 없는 비공개(private) 상태를 만들고, 오직 정의된 메서드를 통해서만 상태를 제어하는 캡슐화 패턴을 학습했다.

* **학습 목표 (Why?)**:
  전역 변수의 오남용을 막고, 객체의 상태(e.g., 체력, 점수)가 의도치 않게 변경되는 것을 방지하기 위함이다. 이를 통해 더 안정적이고 예측 가능한 컴포넌트(모듈)를 만들 수 있다.

* **핵심 원리 (What?)**:
  `createHero`와 같은 팩토리 함수(객체를 생성하여 반환하는 함수)를 통해 클로저를 생성한다. 함수 내부에 선언된 `health`와 같은 변수는 외부에서 직접 접근할 수 없으며, 반환된 객체의 메서드(
  `takeDamage`, `heal` 등)를 통해서만 제어할 수 있다.

* **문법 및 사용법 (How?)**:
  ```javascript
  function createHero(name, maxHealth = 100) {
    // 비공개 상태 변수 (클로저에 의해 보호됨)
    let health = maxHealth;

    // 상태를 제어하는 메서드를 포함한 객체 반환
    return {
      takeDamage(damage) {
        health = Math.max(0, health - damage);
        console.log(`${name}의 체력: ${health}`);
      },
      heal(amount) {
        health = Math.min(maxHealth, health + amount);
        console.log(`${name}의 체력: ${health}`);
      },
      getStatus() {
        return { name, health, maxHealth };
      },
    };
  }

  const hero1 = createHero('전사');
  hero1.takeDamage(20); // 전사의 체력: 80
  // hero1.health = 500; // 외부에서 직접 수정 불가능
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 이 패턴은 JavaScript의 클래스(Class)가 도입되기 이전에 모듈 패턴으로 널리 사용되었으며, 현재도 함수형 프로그래밍이나 React의 Hooks 등에서 핵심적인 원리로 활용된다.

---

### 2. 폼 유효성 검사 (Form Validation)

사용자가 입력한 데이터가 정해진 규칙(e.g., 이메일 형식, 비밀번호 길이)에 맞는지 검증하는 로직을 학습했다.

* **학습 목표 (Why?)**:
  잘못된 데이터가 서버로 전송되는 것을 막고, 사용자에게 즉각적인 피드백을 제공하여 더 나은 사용자 경험(UX)을 만들기 위함이다.

* **핵심 원리 (What?)**:
  다양한 이벤트 시점에서 검사를 수행하여 사용자에게 단계적인 피드백을 제공한다.
  | 검사 시점 | 이벤트 | 목적 |
  | :--- | :--- | :--- |
  | **실시간 검사** | `input` (+ 디바운스) | 사용자가 입력하는 동안 실시간으로 형식 오류 등을 알려줌. |
  | **포커스 아웃 검사**| `blur` | 사용자가 입력 필드를 떠날 때 최종적인 유효성을 검사. |
  | **제출 시 검사** | `submit` | 폼을 제출하기 직전, 모든 필드에 대한 최종 검증을 수행. |

* **문법 및 사용법 (How?)**:
  ```javascript
  const $form = document.querySelector('#signup-form');
  const $emailInput = document.querySelector('#email');

  $form.addEventListener('submit', e => {
    // 1. 기본 폼 제출(새로고침) 동작을 가장 먼저 막는다.
    e.preventDefault();

    // 2. 유효성 검사 로직
    if (!$emailInput.value.includes('@')) {
      alert('올바른 이메일 형식이 아닙니다.');
      $emailInput.focus();
      return; // 제출 로직 중단
    }

    // 3. 모든 검사를 통과하면 서버로 데이터 전송
    console.log('폼 제출 성공!');
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 사용자 입력 피드백을 위해 `.valid`, `.invalid`와 같은 CSS 클래스를 동적으로 추가/제거하여 시각적인 안내(테두리 색상 변경 등)를 제공하는 것이 좋다.

---

### 3. 종합 실습: 숫자 추리 게임 구현 흐름

이벤트, DOM 조작, 상태 관리 등 배운 개념을 종합하여 인터랙티브한 미니 게임을 만드는 전체 흐름을 학습했다.

* **학습 목표 (Why?)**:
  개별적인 JavaScript 문법 지식을 조합하여, 명확한 시작과 끝이 있는 하나의 완성된 애플리케이션 로직을 설계하고 구현하는 능력을 기르기 위함이다.

* **핵심 원리 (What?)**:
  게임의 핵심은 **상태(State)**와 **UI**를 분리하여 생각하는 것이다. 상태(정답, 남은 기회, 최소/최대값 등)를 먼저 정의하고, 사용자의 입력에 따라 상태를 변경한 뒤, 변경된 상태를 화면(UI)에
  반영하는 흐름으로 코드를 구성한다.
    1. **초기화**: 게임에 필요한 상태 변수들을 초기화하고, 난수를 생성한다.
    2. **이벤트 리스너 등록**: 사용자의 추측 값을 제출받을 `submit` 이벤트를 등록한다.
    3. **입력값 검증**: 입력값이 유효한 숫자인지, 정해진 범위 내에 있는지 확인한다.
    4. **상태 변경**: 입력값과 정답을 비교하여 남은 기회, 최소/최대값 등 상태를 업데이트한다.
    5. **UI 업데이트**: 변경된 상태를 화면에 반영한다. (e.g., "UP"/"DOWN" 메시지 출력, 남은 기회 표시, 추측 기록 로그 추가)
    6. **종료 조건 확인**: 정답을 맞추거나 기회를 모두 소진하면 게임을 종료하고, 입력창을 비활성화하며 결과 모달을 띄운다.
    7. **재시작**: 모든 상태와 UI를 초기 상태로 되돌린다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 주요 로직 (submit 이벤트 핸들러 내부)
  function handleGuessSubmit(e) {
    e.preventDefault();
    const guess = Number($guessInput.value);

    // ... 입력값 검증 로직 ...

    // 상태 변경 (기회 차감)
    remainingGuesses--;

    // 정답/오답 판별 및 상태 추가 변경
    if (guess === secretAnswer) {
      // ... 정답 처리 ...
    } else if (guess < secretAnswer) {
      min = guess + 1;
      // ... UP 처리 ...
    } else {
      max = guess - 1;
      // ... DOWN 처리 ...
    }

    // UI 업데이트
    updateGuessHistory(guess, feedback);
    updateUI();
  }
  ```

---

## 오늘의 깨달음 💡

* 클로저는 단순한 문법적 특징을 넘어, 객체의 내부 상태를 외부로부터 안전하게 보호하고, 오직 허용된 인터페이스(메서드)를 통해서만 상태를 변경하도록 강제하는 **캡슐화(Encapsulation)**를
  JavaScript에서 구현하는 강력한 패턴임을 깨달았다.

* '상태를 먼저 정의하고, 그에 따라 UI를 업데이트한다'는 개발 흐름은 매우 중요하다. 사용자의 모든 인터랙션은 결국 상태의 변화를 유발하고, UI는 그 상태를 시각적으로 반영하는 결과물일 뿐이라는 것을 숫자
  추리 게임을 만들면서 체감했다.

* 사용자 경험(UX)은 사소한 디테일에서 결정된다. 폼 유효성 검사에서 `input` 이벤트에 디바운스를 적용하여 실시간 피드백을 주거나, 게임 종료 시 입력창을 비활성화하여 추가 입력을 막는 등의 처리가
  프로그램의 완성도를 크게 높인다는 것을 알게 되었다.

* 하나의 기능을 완성하기 위해서는 이전에 배운 모든 개념(변수, 조건문, 반복문, 함수, DOM, 이벤트)이 유기적으로 결합되어야 한다. 이제는 개별 문법을 아는 것을 넘어, 이것들을 어떻게 '조립'하여 문제를
  해결할 것인가를 고민해야 하는 단계에 이르렀음을 느꼈다.