# TIL - 2025.06.09 - JavaScript 구조 분해 할당, 단축 평가 및 배열 고차 함수 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #ES6 #Destructuring #ShortCircuit #ArrayMethods #Set #reduce

---

## 오늘 배운 내용 🔍

- 배열과 객체의 구조 분해 할당(Destructuring Assignment) 문법
- 배열과 객체의 복사 및 병합을 위한 전개 연산자(Spread Operator)
- `&&`와 `||`를 이용한 조건부 렌더링 및 기본값 할당 (단축 평가)
- 다양한 배열 고차 함수 활용: `forEach`, `map`, `filter`, `find`, `some`, `every`
- `Set` 자료구조를 이용한 배열의 중복 요소 제거
- 배열을 하나의 값으로 축약하는 `reduce` 메서드의 활용
- `sort` 메서드를 이용한 배열의 정렬과 비교 함수의 원리

---

## 어려웠던 점 💣

* `&&`와 `||` 연산자를 이용한 단축 평가가 처음에는 `if`문과 어떻게 다른지 명확하게 와닿지 않았다. 하지만 `||`는 '값이 없으면 기본값을 할당'하는 용도로, `&&`는 '조건이 참일 때만 특정 함수를
  실행'하는 용도로 사용된다는 패턴을 접하고 나서야 그 간결함과 유용성을 이해할 수 있었다.

* `find()`와 `filter()`의 차이를 명확히 구분하기 어려웠다. `filter()`는 조건에 맞는 **모든** 요소를 찾아 새로운 배열로 반환하는 반면, `find()`는 조건에 맞는 **첫 번째**
  요소를 찾으면 즉시 순회를 중단하고 해당 요소 하나만 반환한다는 성능 및 결과의 차이점을 인지하는 것이 중요했다.

* `reduce()`를 사용하여 객체를 누적 집계할 때, `acc[city]`처럼 대괄호 표기법을 사용해야 하는 이유를 이해하는 데 시간이 걸렸다. `city`라는 변수에 담긴 문자열 값('Seoul', '
  Busan' 등)을 객체의 키로 동적으로 사용해야 하므로, 정적인 점 표기법(`acc.city`)으로는 원하는 결과를 얻을 수 없다는 것을 깨달았다.

---

## 정리 🖇️

### 1. 구조 분해 할당 (Destructuring Assignment)

배열이나 객체의 속성을 쉽게 추출하여 개별 변수에 담을 수 있는 ES6 문법을 학습했다.

* **학습 목표 (Why?)**:
  `user.name`, `user.age`처럼 반복적으로 객체 이름을 명시하지 않고, 필요한 값들을 직접 변수로 선언하여 코드의 가독성을 높이고 간결하게 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * **배열 구조 분해**: 대괄호(`[]`)를 사용하며, **배열의 순서(index)**에 따라 변수에 값이 할당된다.
    * **객체 구조 분해**: 중괄호(`{}`)를 사용하며, 순서와 상관없이 **프로퍼티 키(key) 이름**을 기준으로 변수에 값이 할당된다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 배열 구조 분해 (순서 기반)
  const scores = [90, 85, 70];
  const [math, english, history] = scores;
  console.log(math); // 90

  // 객체 구조 분해 (키 기반)
  const user = { name: 'Alice', age: 30, city: 'Seoul' };
  const { name, age } = user;
  console.log(name); // 'Alice'

  // 새로운 변수 이름으로 할당
  const { name: userName, city: userCity } = user;
  console.log(userName); // 'Alice'
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **전개 연산자(`...`)와 함께 사용**: 나머지 요소들을 새로운 배열이나 객체로 모을 수 있다.
      ```javascript
      const [first, ...rest] = [1, 2, 3, 4]; // first: 1, rest: [2, 3, 4]
      const { id, ...userInfo } = { id: 1, name: 'Bob', age: 25 };
      // id: 1, userInfo: { name: 'Bob', age: 25 }
      ```

---

### 2. 단축 평가 (Short-circuit Evaluation)

논리 연산자(`&&`, `||`)의 동작 원리를 이용하여 `if`문을 간결하게 대체하는 코딩 기법을 학습했다.

* **학습 목표 (Why?)**:
  변수에 기본값을 할당하거나, 특정 조건이 참일 때만 함수를 실행하는 등의 간단한 조건부 로직을 더 선언적이고 간결하게 표현하기 위함이다.

* **핵심 원리 (What?)**:
    * `A || B`: `A`가 `truthy`이면 `A`를 반환하고 평가를 종료. `A`가 `falsy`이면 `B`를 반환. (주로 **기본값 설정**에 사용)
    * `A && B`: `A`가 `falsy`이면 `A`를 반환하고 평가를 종료. `A`가 `truthy`이면 `B`를 반환. (주로 **조건부 실행**에 사용)

* **문법 및 사용법 (How?)**:
  ```javascript
  // || : 기본값 할당
  const currentUser = null;
  const welcomeMessage = `Hello, ${currentUser || 'Guest'}`; // "Hello, Guest"

  // && : 조건부 함수 실행
  const isLoggedIn = true;
  isLoggedIn && console.log('Welcome to the dashboard!'); // 실행됨
  ```

---

### 3. 주요 배열 고차 함수

반복문을 직접 작성하지 않고, 배열을 순회하며 다양한 작업을 수행하는 선언적인 메서드들을 학습했다.

* **학습 목표 (Why?)**:
  `for` 루프와 임시 변수 사용을 줄여 코드를 더 간결하고 가독성 있게 만들고, 데이터 변환, 필터링, 검증 등의 작업을 함수형 프로그래밍 스타일로 처리하기 위ham.

* **핵심 원리 (What?)**:

  | 메서드 | 설명 | 반환 값 |
      | :--- | :--- | :--- |
  | `forEach(cb)` | 각 요소에 대해 콜백 함수를 실행한다. | `undefined` |
  | `map(cb)` | 각 요소에 콜백 함수를 적용한 **결과를 모아 새로운 배열**을 반환한다. | 새로운 배열 |
  | `filter(cb)` | 콜백 함수가 `true`를 반환하는 **요소만 모아 새로운 배열**을 반환한다. | 새로운 배열 |
  | `find(cb)` | 콜백 함수가 `true`를 반환하는 **첫 번째 요소 하나**를 반환한다. | 요소 또는 `undefined`|
  | `some(cb)` | 요소 중 **하나라도** 콜백 조건을 만족하면 `true`를 반환한다. | `boolean` |
  | `every(cb)` | **모든 요소**가 콜백 조건을 만족하면 `true`를 반환한다. | `boolean` |

* **문법 및 사용법 (How?)**:
  ```javascript
  const users = [
    { id: 1, name: 'Alice', age: 30, isAdmin: false },
    { id: 2, name: 'Bob', age: 25, isAdmin: true },
    { id: 3, name: 'Charlie', age: 35, isAdmin: false },
  ];

  // map: 이름만 추출하여 새 배열 생성 -> ['Alice', 'Bob', 'Charlie']
  const names = users.map(user => user.name);

  // filter: 30세 이상인 사용자만 필터링 -> [{id:1, ...}, {id:3, ...}]
  const adults = users.filter(user => user.age >= 30);

  // find: 관리자 역할을 가진 첫 번째 사용자 찾기 -> {id:2, ...}
  const admin = users.find(user => user.isAdmin);
  ```

---

### 4. `Set`, `reduce`, `sort` 활용

배열 데이터를 집계하고, 중복을 제거하며, 정렬하는 고급 기법들을 학습했다.

* **학습 목표 (Why?)**:
  단순 순회를 넘어, 배열 데이터를 요약(집계), 정제(중복 제거), 정돈(정렬)하는 실용적인 데이터 처리 능력을 기르기 위함이다.

* **핵심 원리 (What?)**:
    * **`new Set(array)`**: 중복을 허용하지 않는 `Set` 자료구조의 특성을 이용하여 배열의 중복 요소를 제거한다.
    * **`reduce(callback, initialValue)`**: 배열의 각 요소를 순회하며 누적값(`accumulator`)을 업데이트하여 최종적으로 하나의 결과값을 반환한다.
    * **`sort(compareFunction)`**: 배열의 요소를 정렬한다. 비교 함수(`compareFunction`)를 제공하여 정렬 기준을 직접 정의할 수 있다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // Set을 이용한 중복 제거
  const numbers = [1, 2, 2, 3, 4, 4, 5];
  const uniqueNumbers = [...new Set(numbers)]; // [1, 2, 3, 4, 5]

  // reduce를 이용한 총합 계산
  const total = numbers.reduce((acc, current) => acc + current, 0); // 21

  // reduce를 이용한 객체 누적 집계
  const traders = [ /* ... traders data ... */ ];
  const cityTradeCounts = traders.reduce((acc, { trader }) => {
    const city = trader.city;
    acc[city] = (acc[city] || 0) + 1; // city 변수를 동적 키로 사용
    return acc;
  }, {}); // 초기값으로 빈 객체 제공

  // sort를 이용한 숫자 오름차순 정렬
  const points = [40, 100, 1, 5, 25, 10];
  points.sort((a, b) => a - b); // [1, 5, 10, 25, 40, 100]
  ```
* **주의사항 및 실무 팁 (Watch out for)**:
    * `sort()` 메서드는 **원본 배열을 직접 변경**하므로 주의해야 한다. 원본을 유지하고 싶다면 `[...array].sort()`와 같이 배열을 복사한 후 정렬해야 한다.
    * 숫자를 정렬할 때 비교 함수 없이 `sort()`만 사용하면, 숫자를 문자열로 취급하여 `[1, 10, 100, 25, 40, 5]` 와 같이 의도치 않은 순서로 정렬될 수 있다.

---

## 오늘의 깨달음 💡

* 구조 분해 할당과 배열 고차 함수를 연계하여 사용하면, 여러 줄에 걸쳐 작성해야 했던 데이터 처리 로직을 매우 간결하고 선언적인 한두 줄의 코드로 표현할 수 있음을 깨달았다. 이는 코드의 가독성을 극적으로
  향상시킨다.
  ```javascript
  // 예시: 30세 이상 사용자의 이름만 추출
  const adultNames = users.filter(({ age }) => age >= 30).map(({ name }) => name);
  ```
* `find()`와 `filter()`는 목적에 따라 명확히 구분해서 사용해야 한다. 단 하나의 결과만 필요하고 그 이후의 탐색이 불필요한 경우 `find()`를 사용하는 것이 성능상 이점이 있다.

* `reduce()`는 단순한 합산 도구를 넘어, 배열을 객체나 다른 복잡한 자료구조로 '변환'하고 '집계'하는 강력한 추상화 도구임을 이해했다. 초기값을 무엇으로 설정하느냐에 따라 결과물의 형태가 완전히
  달라진다는 점이 매우 인상 깊었다.

* JavaScript의 많은 내장 함수와 최신 문법들은 결국 '어떻게' 할 것인가(How)에 대한 고민을 줄여주고, '무엇을' 할 것인가(What)에만 집중할 수 있도록 돕는다. `for`문을 쓰는 대신 `map`
  을 쓰는 것이 대표적인 예다.