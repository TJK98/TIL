# TIL - 2025.06.18 - JavaScript 함수 실행 방식(IIFE), 비동기 및 XMLHttpRequest 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Asynchronous #IIFE #XHR #Callback #EventLoop

---

## 오늘 배운 내용 🔍

- 함수 선언식과 즉시 실행 함수 표현식(IIFE)의 실행 시점 및 스코프 차이
- JavaScript의 싱글 스레드 환경과 이벤트 루프를 통한 비동기 처리 모델
- 비동기 작업의 결과를 처리하기 위한 콜백(Callback) 함수의 역할과 콜백 지옥(Callback Hell)
- 브라우저에서 서버와 통신하는 전통적인 방식인 `XMLHttpRequest`(XHR)의 사용법
- 사용자 입력에 따라 동적으로 API를 요청하고, 응답 결과를 DOM에 렌더링하는 흐름

---

## 어려웠던 점 💣

* 함수를 소괄호로 감싸고 바로 뒤에 `()`를 붙여 실행하는 IIFE의 문법이 매우 낯설었다. "왜 이렇게까지 하면서 즉시 실행해야 하는가?"라는 근본적인 목적을 이해하는 데 시간이 걸렸다.

* JavaScript가 싱글 스레드(한 번에 하나의 작업만 처리)이면서 어떻게 비동기 작업(e.g., `setTimeout`)이 가능한지 그 구조가 추상적으로 느껴졌다. 콜 스택, 태스크 큐, 이벤트 루프가
  협력하여 비동기 작업을 처리한다는 모델을 이해해야 했다.

* `XMLHttpRequest` 객체의 사용법이 직관적이지 않았다. `open()`, `send()` 메서드와 `onload`, `status`, `responseText` 같은 속성들을 처음에는 단순히 암기해야
  하는 것처럼 느껴져 흐름을 파악하기 어려웠다.

* 비동기 요청을 연달아 처리할 때 콜백 함수가 계속 중첩되는 '콜백 지옥'의 구조를 직접 작성해보니, 코드의 가독성이 급격히 떨어지고 에러 처리가 복잡해지는 문제를 실감했다. 왜 `Promise`나
  `async/await` 같은 현대적인 비동기 처리 방식이 필요한지 절실히 느끼게 되었다.

---

## 정리 🖇️

### 1. 함수 실행 방식: 함수 선언문 vs. IIFE

JavaScript에서 함수를 정의하고 실행하는 두 가지 다른 방식의 목적과 특징을 학습했다.

* **학습 목표 (Why?)**:
  함수의 재사용성 필요 여부와 전역 스코프 오염 방지 목적에 따라, 가장 적절한 함수 실행 방식을 선택하기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 함수 선언식 (Function Declaration) | 즉시 실행 함수 표현식 (IIFE) |
  | :--- | :--- | :--- |
  | **실행 시점** | 필요할 때 명시적으로 **호출** | **정의하는 즉시** 단 한 번 실행 |
  | **재사용성** | ✅ 가능 (여러 번 호출 가능) | ❌ 불가능 (일회성 실행) |
  | **스코프** | 함수 이름이 전역 또는 상위 스코프에 등록됨 | 독립적인 스코프를 생성하여 **내부 변수가 외부로 노출되지 않음** |
  | **전역 오염** | 이름을 잘못 지으면 전역 변수와 충돌 가능 | ✅ 전역 스코프를 오염시키지 않음 |
  | **호이스팅** | ✅ 됨 (선언 전에 호출 가능) | ❌ 안 됨 |
  | **주요 용도**| 재사용이 필요한 일반적인 기능 정의 | 애플리케이션 **초기화**, 라이브러리 스코프 캡슐화 |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 함수 선언식: 필요할 때마다 재사용
  function greet(name) {
    return `Hello, ${name}!`;
  }
  greet("Alice"); // 호출

  // IIFE: 정의와 동시에 딱 한 번만 실행됨 (재호출 불가)
  (function() {
    const initialConfig = { theme: 'dark', version: '1.0' };
    console.log('애플리케이션 초기 설정이 완료되었습니다.');
    // 이 initialConfig 변수는 IIFE 외부에서 접근할 수 없다.
  })();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * IIFE를 소괄호로 감싸는 이유는 JavaScript 파서에게 이것이 '함수 선언문'이 아닌 '함수 표현식'임을 알려주기 위함이다. 표현식으로 인식되어야만 바로 뒤에 `()`를 붙여 즉시 호출할 수 있다.
    * `let`, `const`로 블록 스코프 관리가 쉬워진 현대 JavaScript에서는 IIFE의 스코프 보호 역할이 과거보다 줄었지만, 여전히 초기화 로직을 캡슐화하는 용도로 유용하게 사용된다.

---

### 2. JavaScript 비동기(Asynchronous) 프로그래밍

시간이 걸리는 작업을 기다리지 않고 다음 코드를 실행하는 JavaScript의 비동기 처리 모델을 학습했다.

* **학습 목표 (Why?)**:
  서버로부터 데이터를 가져오거나, 큰 파일을 처리하는 등 시간이 오래 걸리는 작업이 UI 렌더링을 막아 화면이 멈추는(Blocking) 현상을 방지하고, 부드러운 사용자 경험을 제공하기 위함이다.

* **핵심 원리 (What?)**:
  JavaScript는 **싱글 스레드** 기반이지만, **이벤트 루프(Event Loop)** 모델을 통해 비동기 작업을 처리한다.
    1. 비동기 함수(e.g., `setTimeout`, `XHR`)가 호출되면, Web API(브라우저)가 해당 작업을 넘겨받아 처리한다.
    2. JavaScript 엔진은 기다리지 않고 바로 다음 코드를 실행한다.
    3. Web API에서 작업이 완료되면, 콜백 함수가 **태스크 큐(Task Queue)**에 등록된다.
    4. **이벤트 루프**는 **콜 스택(Call Stack)**이 비어있을 때마다 태스크 큐에서 가장 오래된 작업을 꺼내와 콜 스택으로 옮겨 실행시킨다.

* **문법 및 사용법 (How?)**:
    * **콜백 함수**: 비동기 작업이 완료된 '후에' 실행될 함수를 미리 전달하는 방식.
  ```javascript
  console.log('작업 시작');

  // 1초 뒤에 실행될 작업을 예약하고, 바로 다음 코드로 넘어감
  setTimeout(() => {
    console.log('1초 경과. 비동기 작업 완료!');
  }, 1000);

  console.log('작업 시작과 완료 사이에 다른 동기 코드 실행');

  /* 출력 순서:
     작업 시작
     작업 시작과 완료 사이에 다른 동기 코드 실행
     (1초 후)
     1초 경과. 비동기 작업 완료!
  */
  ```
    * **콜백 지옥 (Callback Hell)**: 비동기 작업을 순차적으로 처리하기 위해 콜백 함수 안에 또 다른 콜백 함수를 중첩하는 구조. 코드의 가독성과 유지보수성을 크게 해친다.
  ```javascript
  step1(result1 => {
    step2(result1, result2 => {
      step3(result2, result3 => {
        // ...
      });
    });
  });
  ```

---

### 3. XMLHttpRequest (XHR)를 이용한 비동기 통신

서버와 데이터를 주고받기 위한 전통적인 브라우저 API를 학습했다.

* **학습 목표 (Why?)**:
  페이지 전체를 새로고침하지 않고도 서버로부터 데이터를 가져와(AJAX) 화면의 일부만 동적으로 업데이트하는 기능을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  `XMLHttpRequest` 객체를 생성하고, `open()`으로 요청을 준비한 뒤, `send()`로 전송한다. 서버로부터 응답이 오면 `onload` 이벤트 핸들러가 실행된다.
  | 주요 속성/메서드 | 설명 |
  | :--- | :--- |
  | `new XMLHttpRequest()`| XHR 객체 생성. |
  | `xhr.open(method, url)` | HTTP 요청 메서드(`GET`, `POST` 등)와 URL을 설정하여 요청을 초기화. |
  | `xhr.send()` | 서버로 요청을 전송. |
  | `xhr.onload` | 요청이 성공적으로 완료되었을 때 실행될 콜백 함수를 등록. |
  | `xhr.status` | HTTP 상태 코드 (e.g., `200`: 성공, `404`: 찾을 수 없음). |
  | `xhr.responseText`| 서버로부터 받은 응답 데이터를 텍스트 형태로 반환. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 1. XHR 객체 생성
  const xhr = new XMLHttpRequest();

  // 2. 요청 초기화
  xhr.open('GET', 'https://api.example.com/users/1');

  // 3. 요청 전송
  xhr.send();

  // 4. 응답 처리
  xhr.onload = () => {
    if (xhr.status === 200) {
      const user = JSON.parse(xhr.responseText); // JSON 문자열을 객체로 변환
      console.log(user.name);
    } else {
      console.error('Error:', xhr.status, xhr.statusText);
    }
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * XHR은 오래된 기술이며, 문법이 다소 복잡하고 콜백 기반이라 콜백 지옥을 유발하기 쉽다.
    * 현대 JavaScript에서는 `Promise` 기반의 `fetch` API나 `axios` 라이브러리를 사용하는 것이 훨씬 더 간결하고 효율적이다. XHR은 레거시 코드를 이해하거나 특정 기능(e.g.,
      업로드 진행률 추적)이 필요할 때 사용된다.

---

## 오늘의 깨달음 💡

* 함수 선언식은 '재사용 가능한 부품'을 만드는 것이고, IIFE는 '단 한 번만 실행되는 설치 프로그램'을 만드는 것과 같다는 차이를 명확히 이해했다. 특히 IIFE는 초기화 로직을 캡슐화하여 전역 스코프를
  깔끔하게 유지하는 중요한 목적이 있었다.

* "JavaScript는 싱글 스레드인데 어떻게 비동기가 가능한가?"라는 오랜 의문이 이벤트 루프 모델을 통해 해소되었다. 실제 시간이 걸리는 작업은 브라우저(Web API)가 대신 처리해주고,
  JavaScript는 그 결과(콜백)를 받아 실행만 하는 효율적인 '분업' 시스템이었던 것이다.

* 콜백 지옥을 직접 경험해보니, 왜 `Promise`와 `async/await`가 등장했는지 그 필요성을 절실히 느낄 수 있었다. 이는 단순히 코드를 예쁘게 만드는 것을 넘어, 비동기 로직의 흐름을 인간이 이해하기
  쉬운 순차적인 형태로 만들어주는 중요한 발전이다.

* 결국, 웹 애플리케이션의 동적인 기능은 '이벤트 발생 → 비동기 요청 → 응답 데이터 처리 → DOM 렌더링'이라는 일련의 흐름으로 이루어진다는 큰 그림을 보게 되었다. 이 과정에서 비동기 처리는 필수적인
  요소임을 깨달았다.