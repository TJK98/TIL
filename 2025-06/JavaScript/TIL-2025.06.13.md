# TIL - 2025.06.13 - JavaScript 고급 UI 인터랙션(드롭다운, 탭, 모달, 드래그 앤 드롭) 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #DOM #UI #Event #Dropdown #Modal #DragAndDrop

---

## 오늘 배운 내용 🔍

- `position`을 이용한 드롭다운 메뉴 위치 지정 및 외부 클릭 감지 로직
- `active` 클래스를 이용한 탭 인터페이스 상태 관리 방법
- 모달(Modal) 창의 생성, 소멸 및 중첩 제어 로직
- 다양한 좌표 속성을 이용한 요소의 위치 계산 (`getBoundingClientRect`, `offsetTop` 등)
- HTML5 Drag and Drop API의 기본 이벤트 흐름 (`dragstart`, `dragover`, `drop`, `dragend`)
- `preventDefault()`를 이용한 드래그 앤 드롭 이벤트 제어

---

## 어려웠던 점 💣

* 외부 클릭을 감지할 때 `node.contains(otherNode)`와 `element.matches('selector')`의 용도가 혼란스러웠다. `contains`는 DOM 노드를 기준으로 포함 관계(자식
  포함)를 확인하여 더 안정적인 반면, `matches`는 CSS 선택자를 기준으로 자기 자신만 비교하므로 HTML 구조 변경에 취약할 수 있다는 차이점을 이해해야 했다.

* `mouseover`와 `mouseenter` 이벤트가 비슷해 보였지만, 자식 요소를 드나들 때 이벤트가 계속 발생하는 `mouseover`(버블링 O)와 달리 `mouseenter`는 해당 요소의 경계를 처음
  넘어설 때 한 번만 발생(버블링 X)하여 드롭다운 메뉴 같은 UI에 더 적합하다는 점을 구분하기 어려웠다.

* `dragover` 이벤트에서 `e.preventDefault()`를 호출해야만 `drop` 이벤트가 발생하는 이유가 직관적으로 와닿지 않았다. 브라우저의 기본 동작은 '드롭을 허용하지 않는 것'이므로, 이 기본
  동작을 막아야 해당 영역이 드롭 가능한区域임을 알려주는 규칙이라는 것을 알게 되었다.

* 드래그 시작 시 `setTimeout(() => e.target.classList.add('hidden'), 0)`을 사용하는 이유를 이해하기 어려웠다. 이는 브라우저가 드래그할 요소의 '고스트 이미지'를 생성한
  후, 다음 이벤트 루프 틱에서 원본을 숨기도록 하여, 고스트 이미지가 제대로 생성되도록 보장하는 비동기 트릭이라는 것을 깨달았다.

---

## 정리 🖇️

### 1. 드롭다운 메뉴 구현과 제어

버튼 클릭 시 메뉴가 나타나고, 외부를 클릭하면 사라지는 드롭다운 UI의 핵심 원리를 학습했다.

* **학습 목표 (Why?)**:
  일반적인 웹 UI에서 자주 사용되는 드롭다운 메뉴를 구현하며, `position`을 이용한 레이아웃, 클래스 토글을 통한 상태 관리, 외부 클릭 감지, 이벤트 버블링 제어 등 복합적인 DOM 제어 기술을 익히기
  위함이다.

* **핵심 원리 (What?)**:
    * **위치 지정**: 부모 요소(`position: relative`)를 기준으로, 드롭다운 메뉴(`position: absolute`)의 위치를 잡는다.
    * **상태 관리**: `active` 클래스를 `toggle`하거나 `add`/`remove`하여 메뉴의 표시/숨김 상태를 제어한다.
    * **외부 클릭 감지**: `document`에 클릭 이벤트를 걸어, 클릭된 위치가 드롭다운 메뉴 영역 내부가 아닐 경우 메뉴를 닫는다.
    * **마우스 이벤트**: `mouseenter`/`mouseleave`는 버블링이 없어 자식 요소를 드나들어도 이벤트가 중복 발생하지 않아 메뉴 UI에 안정적이다.

      | 외부 클릭 감지 | `element.contains(node)` | `element.matches('selector')` |
              | :--- | :--- | :--- |
      | **비교 대상**| DOM 노드 객체 | CSS 선택자 문자열 |
      | **포함 범위**| 자기 자신 및 모든 자손 | 자기 자신만 |
      | **안정성** | HTML 구조 변경에 강함 (권장) | 구조 변경에 취약함 |
      | 마우스 이벤트 | `mouseover` / `mouseout` | `mouseenter` / `mouseleave` |
      | :--- | :--- | :--- |
      | **버블링** | ✅ 발생함 | ❌ 발생 안 함 |
      | **사용처** | 이벤트 위임 등 전파가 필요할 때 | 특정 요소의 진입/이탈만 감지할 때 (권장) |

* **문법 및 사용법 (How?)**:
  ```javascript
  const $dropdown = document.querySelector('.dropdown');

  // 드롭다운 토글
  $dropdown.addEventListener('click', e => {
    e.currentTarget.classList.toggle('active');
  });

  // 외부 클릭 감지하여 닫기
  document.addEventListener('click', e => {
    // 클릭된 곳이 드롭다운 영역 외부일 때
    if (!$dropdown.contains(e.target)) {
      $dropdown.classList.remove('active');
    }
  });
  ```

---

### 2. 탭 인터페이스와 모달 창

클릭에 따라 콘텐츠를 전환하는 탭 UI와, 페이지 위에 레이어로 띄워지는 모달 창을 제어하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  한정된 공간에 많은 정보를 효율적으로 보여주고(탭), 사용자의 특정 행동(e.g., 확인, 입력)에 집중시키기 위한(모달) UI 패턴을 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **탭 인터페이스**: 모든 탭 버튼과 콘텐츠에서 `active` 클래스를 제거한 뒤, 클릭된 탭 버튼과 그에 해당하는 콘텐츠에만 `active` 클래스를 추가하여 상태를 전환한다. `data-*` 속성을
      이용해 버튼과 콘텐츠를 연결한다.
    * **모달 창**: `display` 속성을 변경하여 표시/숨김을 제어한다. `Escape` 키보드 이벤트나 모달 바깥 영역 클릭 이벤트를 감지하여 닫기 기능을 구현한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 탭 UI 로직
  const $tabs = document.querySelector('.tabs');
  $tabs.addEventListener('click', e => {
    if (!e.target.matches('.tab-button')) return;

    // 모든 active 클래스 제거
    document.querySelectorAll('.tab-button, .tab-content').forEach(el => el.classList.remove('active'));

    // 클릭된 버튼과 연결된 콘텐츠에 active 클래스 추가
    const targetId = e.target.dataset.tab;
    e.target.classList.add('active');
    document.querySelector(`#${targetId}`).classList.add('active');
  });

  // 모달 외부 클릭 닫기 로직
  const $modalOverlay = document.querySelector('.modal-overlay');
  $modalOverlay.addEventListener('click', e => {
    if (e.target === $modalOverlay) { // 오버레이 자체를 클릭했을 때만
      $modalOverlay.style.display = 'none';
    }
  });
  ```

---

### 3. 드래그 앤 드롭 (Drag and Drop)

HTML5 Drag and Drop API를 이용하여 요소를 드래그하여 위치를 변경하는 인터랙션을 학습했다.

* **학습 목표 (Why?)**:
  사용자가 직접 UI 요소를 재정렬(e.g., 할 일 목록 순서 변경)하는 등 직관적이고 인터랙티브한 사용자 경험을 제공하기 위함이다.

* **핵심 원리 (What?)**:
  드래그 앤 드롭은 `draggable="true"` 속성을 가진 요소에서 시작되며, 일련의 이벤트 흐름에 따라 동작한다.

  | 이벤트 | 역할 | 주요 처리 내용 |
      | :--- | :--- | :--- |
  | `dragstart`| 드래그가 시작될 때 발생. | 드래그 중인 아이템 정보를 변수에 저장. |
  | `dragover` | 드래그 중인 아이템이 드롭 가능한 영역 위에 있을 때 계속 발생. | `e.preventDefault()`를 호출하여 드롭이 가능함을 브라우저에 알려야 함. |
  | `drop` | 드롭 가능한 영역에 아이템을 놓았을 때 발생. | `e.preventDefault()`로 기본 동작(e.g., 링크 열기)을 막고, 아이템을 DOM에 추가하는 로직 실행. |
  | `dragend` | 드래그가 종료될 때 발생 (성공 여부 무관). | 드래그 과정에서 추가했던 클래스나 스타일을 정리. |

* **문법 및 사용법 (How?)**:
  ```javascript
  let draggedItem = null;
  const dropZone = document.querySelector('.drop-zone');

  // 드래그할 아이템에 이벤트 리스너 등록
  document.querySelector('.draggable-item').addEventListener('dragstart', e => {
    draggedItem = e.target; // 드래그 시작된 아이템 저장
    // 브라우저가 고스트 이미지를 생성할 시간을 준 뒤 원본을 숨김
    setTimeout(() => e.target.classList.add('hidden'), 0);
  });

  // 드롭 영역에 이벤트 리스너 등록
  dropZone.addEventListener('dragover', e => {
    e.preventDefault(); // 드롭을 허용하기 위해 필수!
  });

  dropZone.addEventListener('drop', e => {
    e.preventDefault(); // 파일/링크 열기 등 기본 동작 방지 (반드시 첫 줄에!)
    e.target.append(draggedItem);
  });

  // 드래그 종료 시 정리
  document.querySelector('.draggable-item').addEventListener('dragend', e => {
    e.target.classList.remove('hidden'); // 숨겼던 원본을 다시 보이게 함
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`dragover`의 `preventDefault()`**: 이 처리가 없으면 `drop` 이벤트는 절대 발생하지 않는다. 브라우저의 기본 정책이 드롭을 막는 것이기 때문이다.
    * **`drop`의 `preventDefault()`**: 이 처리는 반드시 핸들러의 **가장 첫 줄**에 위치해야 한다. 그렇지 않으면 브라우저가 기본 동작(e.g., 드래그한 이미지를 새 탭에서 열기)을
      먼저 처리해버릴 수 있다.
    * **시각적 피드백**: 드래그하는 동안 원래 위치에 `placeholder` 요소를 두거나, 드롭 가능한 영역의 스타일을 변경하여 사용자에게 명확한 시각적 피드백을 제공하는 것이 UX에 매우 중요하다.

---

## 오늘의 깨달음 💡

* UI 인터랙션을 구현할 때, `contains()`와 `matches()` 같은 메서드의 미묘한 차이를 이해하는 것이 얼마나 중요한지 깨달았다. `contains()`는 DOM 요소 간의 포함 관계를 확인하여
  구조적으로 안정적인 반면, `matches()`는 특정 선택자에 의존하므로 CSS 클래스 이름이 바뀌면 코드가 깨질 수 있다. 상황에 맞는 적절한 도구를 선택해야 한다.

* 드래그 앤 드롭의 `dragover`와 `drop` 이벤트에서 `preventDefault()`를 호출하는 것은 단순한 옵션이 아니라, 브라우저의 기본 동작을 제어하고 API가 의도대로 작동하게 만들기 위한 *
  *필수적인 계약**과 같다는 것을 이해했다.

* `setTimeout`을 이용해 드래그 시작 시 요소를 숨기는 트릭은 브라우저의 렌더링 파이프라인과 이벤트 루프에 대한 이해가 필요한 고급 기법이었다. 이는 JavaScript 코드가 항상 순차적으로만 동작하지
  않으며, 때로는 브라우저에게 '숨 쉴 틈'을 주어야 한다는 것을 보여준다.

* 결국 정교한 UI 인터랙션은 단순히 이벤트 몇 개를 연결하는 것이 아니라, DOM의 구조적 관계, 이벤트 전파 모델, 브라우저의 기본 동작, 그리고 비동기 처리까지 모두 고려해야 하는 종합 예술에 가깝다는 것을
  느꼈다.