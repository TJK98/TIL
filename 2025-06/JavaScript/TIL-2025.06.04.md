# TIL - 2025.06.04 - JavaScript 함수 정의, 호출, 스코프 및 전개 연산자 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Function #Scope #Return #Parameters #SpreadOperator

---

## 오늘 배운 내용 🔍

- 함수(Function)의 기본 개념: 정의와 호출
- 함수 선언문과 함수 표현식의 차이점 (호이스팅)
- 입력 값을 받는 매개변수(Parameter)와 전달하는 인자(Argument)
- 함수의 실행 결과를 반환하고 흐름을 종료하는 `return` 키워드
- 변수의 유효 범위를 결정하는 전역 스코프와 지역 스코프
- 가변 인자를 효율적으로 처리하는 전개 연산자(`...`)의 활용

---

## 어려웠던 점 💣

* 함수를 정의하는 것만으로는 아무 일도 일어나지 않고, 반드시 `함수이름()` 형태로 '호출'해야만 코드가 실행된다는 개념이 처음에는 낯설었다. 정의와 실행이 분리되어 있다는 점을 인지하는 것이 중요했다.

* `return` 키워드가 단순히 값을 반환하는 역할만 하는 줄 알았으나, 그 즉시 함수 실행을 완전히 '종료'시키는 흐름 제어의 역할도 한다는 점이 놀라웠다. 반복문을 탈출하는 `break`와는 다르게 함수
  전체의 실행을 중단시킨다는 차이를 구분해야 했다.

* 함수 내에서 선언된 지역 변수는 함수 호출이 끝나면 메모리에서 사라진다는 '생명 주기' 개념이 추상적으로 느껴졌다. 이는 JavaScript의 스코프 기반 메모리 관리 방식과 관련이 깊다는 것을 알게 되었다.

* `return` 문이 없는 함수를 호출하고 그 결과를 변수에 저장했을 때, 변수에 `undefined`가 할당되는 것을 보고 당황했다. 모든 함수는 명시적인 `return`이 없으면 기본적으로
  `undefined`를 반환한다는 규칙을 이해해야 했다.

---

## 정리 🖇️

### 1. 함수(Function)의 정의와 호출

특정 작업을 수행하는 코드 블록을 하나의 단위로 묶고, 필요할 때마다 재사용할 수 있는 방법을 학습했다.

* **학습 목표 (Why?)**:
  코드의 중복을 피하고, 특정 기능(e.g., 로그인 처리, 값 계산)을 독립적인 단위로 만들어 프로그램의 구조를 명확하게 하고 유지보수성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  함수는 '정의' 단계와 '호출' 단계로 나뉜다.
    * **함수 정의 (Function Definition)**: 어떤 작업을 수행할지 코드 블록을 작성하는 것.
    * **함수 호출 (Function Call)**: 정의된 함수를 실제로 실행하도록 명령하는 것.
    * **함수 선언문 vs. 함수 표현식**:

      | 구분 | 함수 선언문 | 함수 표현식 |
              | :--- | :--- | :--- |
      | **형태** | `function a() {}` | `const b = function() {};` |
      | **호이스팅**| ✅ **가능**. 코드의 어디서든 호출할 수 있다. | ❌ **불가능**. 변수가 선언되고 함수가 할당된 이후에만 호출할 수 있다. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 1. 함수 정의 (선언문 방식)
  function greet() {
    console.log("Hello, world!");
  }

  // 2. 함수 호출
  greet(); // "Hello, world!" 출력

  // 1. 함수 정의 (표현식 방식)
  const sayGoodbye = function() {
    console.log("Goodbye!");
  };

  // 2. 함수 호출
  sayGoodbye(); // "Goodbye!" 출력
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 함수 표현식은 변수의 스코프 규칙을 그대로 따르므로, 코드의 예측 가능성을 높여주어 현대 JavaScript에서는 `const`와 함께 함수 표현식을 사용하는 것을 선호하는 경향이 있다.

---

### 2. 매개변수(Parameter)와 반환값(Return)

함수가 외부로부터 값을 입력받고, 처리된 결과를 외부로 내보내는 방법을 학습했다.

* **학습 목표 (Why?)**:
  함수를 재사용 가능한 부품처럼 만들기 위함이다. 매개변수를 통해 다양한 입력 값에 따라 다른 결과를 만들고, `return`을 통해 그 결과를 다른 코드에서 활용할 수 있다.

* **핵심 원리 (What?)**:
    * **매개변수 (Parameter)**: 함수를 정의할 때, 외부로부터 받을 값을 저장하기 위해 선언하는 변수.
    * **인자 (Argument)**: 함수를 호출할 때, 매개변수에 실제로 전달하는 값.
    * **`return`**: 함수의 실행 결과를 반환하고, 그 즉시 함수의 실행을 **종료**한다. `return` 키워드 뒤에 오는 코드는 실행되지 않는다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // a와 b는 매개변수
  function add(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
      return "숫자를 입력해주세요."; // 조건에 따라 함수가 여기서 종료됨
    }
    return a + b; // a와 b의 합을 반환하고 함수 종료
  }

  // 5와 10은 인자
  const result = add(5, 10);
  console.log(result); // 15

  // 함수의 반환값을 다른 함수의 인자로 바로 사용할 수 있음
  const finalResult = add(add(1, 2), add(3, 4)); // add(3, 7) -> 10
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `return`이 없는 함수는 기본적으로 `undefined`를 반환한다.
    * 하나의 함수는 오직 하나의 값만 `return`할 수 있다. 여러 값을 반환해야 할 경우, 배열이나 객체로 묶어서 반환하는 방식을 사용한다.
      ```javascript
      function getUserInfo() {
        return { name: "Alice", age: 30 }; // 객체로 여러 값 반환
      }
      ```
    * 매개변수에 기본값(Default Parameter)을 설정할 수 있다. 인자가 전달되지 않을 경우 이 기본값이 사용된다.
      ```javascript
      function greet(name = "손님") {
        console.log(`안녕하세요, ${name}님!`);
      }
      greet(); // "안녕하세요, 손님님!"
      ```

---

### 3. 스코프(Scope): 전역과 지역

변수가 유효한 범위를 결정하는 규칙을 학습했다.

* **학습 목표 (Why?)**:
  변수 이름의 충돌을 방지하고, 코드의 특정 부분에서만 사용되는 변수를 안전하게 관리하여 프로그램의 안정성과 예측 가능성을 높이기 위함이다.

* **핵심 원리 (What?)**:
    * **전역 스코프 (Global Scope)**: 코드의 가장 바깥 영역. 여기서 선언된 변수(전역 변수)는 코드 어디에서든 접근할 수 있다.
    * **지역 스코프 (Local Scope) / 함수 스코프 (Function Scope)**: 함수 내부의 영역. 여기서 선언된 변수(지역 변수)는 오직 해당 함수 내부에서만 접근할 수 있으며, 함수 실행이
      끝나면 메모리에서 사라진다.

* **문법 및 사용법 (How?)**:
  ```javascript
  const globalVar = "전역 변수";

  function testScope() {
    const localVar = "지역 변수";
    console.log(globalVar); // "전역 변수" (전역 변수 접근 가능)
    console.log(localVar);  // "지역 변수" (지역 변수 접근 가능)
  }

  testScope();
  console.log(globalVar); // "전역 변수"
  // console.log(localVar); // ReferenceError: localVar is not defined (에러 발생)
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 전역 변수는 어디서든 변경될 수 있어 코드의 복잡성을 높이고 버그의 원인이 되기 쉽다. 가능한 한 지역 변수를 사용하고, 전역 변수의 사용은 최소화하는 것이 좋다.

---

### 4. 전개 연산자(Spread Operator)와 가변 인자 함수

정해지지 않은 개수의 인자를 함수에 전달하고 처리하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  입력 값의 개수가 유동적인 함수(e.g., 모든 숫자의 합을 구하는 함수)를 유연하게 만들기 위함이다.

* **핵심 원리 (What?)**:
  함수의 매개변수 자리에 `...` (전개 연산자)를 사용하면, 함수에 전달된 여러 개의 인자들을 하나의 **배열**로 모아서 받을 수 있다. 이를 나머지 매개변수(Rest Parameters)라고 한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // numbers는 전달된 모든 인자를 담은 배열이 됨
  function sumAll(...numbers) {
    let total = 0;
    for (const num of numbers) {
      total += num;
    }
    return total;
  }

  console.log(sumAll(1, 2, 3)); // 6
  console.log(sumAll(10, 20, 30, 40, 50)); // 150
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 전개 연산자는 배열을 합치거나 복사할 때도 매우 유용하게 사용된다.
      ```javascript
      const arr1 = [1, 2];
      const arr2 = [3, 4];
      const combined = [...arr1, ...arr2]; // [1, 2, 3, 4]
      ```

---

## 오늘의 깨달음 💡

* 함수는 단순한 코드 묶음이 아니라, 독립적인 '스코프'를 생성하고 '입력(parameter)'을 받아 '출력(return)'을 내보내는 하나의 작은 프로그램과 같다는 것을 이해했다.

* `return` 키워드가 값을 반환하는 동시에 함수 실행을 '종료'시키는 제어문의 역할을 한다는 점을 명확히 알게 되었다. 이는 조건부로 함수를 조기 종료시키는 등 다양한 흐름 제어에 활용될 수 있음을 의미한다.

* 스코프 개념을 통해, 함수 내부에서 선언된 변수가 '휘발성'을 가진다는 것을 깨달았다. 이는 메모리를 효율적으로 관리하는 JavaScript 엔진의 중요한 동작 방식이며, 나중에 배울 클로저(Closure)
  개념의 기반이 됨을 예감했다.

* 전개 연산자(`...`)는 함수의 유연성을 극대화하는 강력한 도구였다. 정해진 개수의 매개변수만 받을 수 있다는 고정관념에서 벗어나, 동적인 입력에 대응할 수 있는 함수를 설계할 수 있게 되었다.