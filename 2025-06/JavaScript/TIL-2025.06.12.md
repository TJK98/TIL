# TIL - 2025.06.12 - JavaScript 비동기 타이머(setTimeout, setInterval)와 상태 관리 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Asynchronous #setTimeout #setInterval #DOM #StateManagement

---

## 오늘 배운 내용 🔍

- JavaScript의 동기(Synchronous)와 비동기(Asynchronous) 실행 흐름의 차이
- 일정 시간 후 코드를 실행하는 `setTimeout`과 주기적으로 코드를 실행하는 `setInterval`
- 예약된 타이머를 취소하는 `clearTimeout`과 `clearInterval`
- 정확한 시간 측정을 위한 `Date` 객체의 활용
- 스탑워치 구현을 통한 상태 변수(State Flag) 관리 및 UI 제어 기법

---

## 어려웠던 점 💣

* `let timerId = null;` 처럼 타이머 ID를 담을 변수를 함수 바깥에 선언하고 `null`로 초기화하는 이유를 이해하기 어려웠다. 이벤트 핸들러 함수 내부에 선언하면 지역 변수가 되어 다른 함수(
  e.g., 취소 함수)에서 접근할 수 없기 때문에, 여러 함수에서 공유할 수 있도록 **전역 스코프에 변수를 미리 준비**해두는 것이라는 점을 깨달았다. `null`은 '아직 타이머가 설정되지 않았음'을 나타내는
  초기 상태 값이었다.

* `setInterval`과 `setTimeout`을 `for`문과 함께 사용하는 것의 차이가 모호했다. `setInterval`은 '정해진 간격마다 자동으로 반복 실행'하는 비동기 작업 예약인 반면,
  `setTimeout`을 `for`문 안에서 사용하는 것은 '여러 개의 단발성 비동기 작업을 거의 동시에 예약'하는 것이라 동작 방식이 전혀 다르다는 것을 이해해야 했다.

* `clearInterval(timerId);`만으로 타이머가 멈추는데, 왜 굳이 `timerId = null;`을 다시 할당하는지 의문이었다. 이는 단순히 타이머를 멈추는 것을 넘어, "현재 타이머가 동작 중이
  아님"이라는 **상태를 명시적으로 초기화**하여, 나중에 다시 시작할 때 `if (timerId !== null)` 과 같은 조건문으로 중복 실행을 막는 안전장치 역할을 한다는 것을 알게 되었다.

* 스탑워치 예제에서 `isRunning`과 같은 상태 플래그 변수의 필요성이 와닿지 않았다. '일시정지'와 '재개'처럼 동일한 버튼이 상황에 따라 다른 기능을 수행하게 하려면, 현재 프로그램의 상태를 기억하는
  변수가 반드시 필요하다는 것을 실습을 통해 체감했다.

---

## 정리 🖇️

### 1. 동기(Synchronous) vs. 비동기(Asynchronous)

JavaScript 코드의 실행 흐름에 대한 두 가지 방식을 학습했다.

* **학습 목표 (Why?)**:
  시간이 오래 걸리는 작업(e.g., 서버 요청, 타이머)이 전체 프로그램의 실행을 막지 않도록 하여, 사용자에게 멈춤 없는 부드러운 UI 경험을 제공하기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 설명 | 예시 |
  | :--- | :--- | :--- |
  | **동기(Sync)** | 코드가 위에서 아래로 순서대로 실행되며, 한 작업이 끝나야 다음 작업이 시작된다. | `console.log('첫 번째');`<br>`console.log('두 번째');` |
  | **비동기(Async)**| 특정 작업의 완료를 기다리지 않고 즉시 다음 코드를 실행한다. 해당 작업은 나중에 별도의 흐름으로 실행된다. |
  `setTimeout(() => console.log('나중에 실행'), 1000);`<br>`console.log('먼저 실행');` |

---

### 2. 비동기 타이머 함수

지정된 시간 이후 또는 주기적으로 코드를 실행시키는 브라우저 내장 함수를 학습했다.

* **학습 목표 (Why?)**:
  알림 팝업 자동 닫기, 실시간 시계, 주기적인 데이터 업데이트 등 시간 기반의 동적인 기능을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  타이머 함수를 호출하면 브라우저는 타이머를 예약하고, 즉시 **타이머 ID**를 반환한다. 이 ID를 변수에 저장해두었다가 나중에 타이머를 취소할 때 사용한다.
  | 함수 | 설명 |
  | :--- | :--- |
  | `setTimeout(callback, delay)` | `delay`(밀리초) 이후에 `callback` 함수를 **단 한 번** 실행한다. |
  | `clearTimeout(timerId)` | `setTimeout`으로 예약된 실행을 취소한다. |
  | `setInterval(callback, delay)` | `delay`(밀리초)마다 `callback` 함수를 **주기적으로 반복** 실행한다. |
  | `clearInterval(timerId)` | `setInterval`로 예약된 반복 실행을 중단한다. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 타이머 ID를 저장할 변수를 외부 스코프에 null로 초기화
  let intervalId = null;

  function startTimer() {
    // 이미 타이머가 실행 중이면 중복 실행 방지
    if (intervalId !== null) return;

    intervalId = setInterval(() => {
      console.log("1초마다 실행됩니다.");
    }, 1000);
  }

  function stopTimer() {
    clearInterval(intervalId);
    // 타이머가 멈췄다는 상태를 명시적으로 표시
    intervalId = null;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **타이머 ID 관리**: `setTimeout`이나 `setInterval`을 나중에 제어(취소)하려면, 반드시 반환되는 ID 값을 변수에 저장해야 한다. 이 변수는 타이머를 시작하는 함수와 중단하는
      함수 모두에서 접근할 수 있어야 하므로, 보통 함수 바깥 스코프에 선언한다.

---

### 3. `Date` 객체를 이용한 경과 시간 측정

`setInterval`의 시간 간격이 항상 정확하지는 않다는 한계를 극복하고, 정밀한 시간을 측정하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  스탑워치, 게임 타이머 등 정확한 시간 측정이 중요한 기능을 구현하기 위함이다. `setInterval`의 `delay`는 최소 대기 시간일 뿐, 브라우저의 다른 작업 때문에 지연될 수 있다.

* **핵심 원리 (What?)**:
  타이머 시작 시점의 시간을 `new Date()`로 기록하고, `setInterval` 내부에서 현재 시간을 반복적으로 측정하여 두 시간의 차이를 계산한다. 이 시간 차이는 밀리초(ms) 단위의 타임스탬프 값으로
  계산된다.

* **문법 및 사용법 (How?)**:
  ```javascript
  let startTime = null;

  function start() {
    startTime = new Date(); // 시작 시간 기록

    setInterval(() => {
      const now = new Date();
      const elapsedTime = now - startTime; // 경과 시간(ms) 계산
      const seconds = (elapsedTime / 1000).toFixed(2); // 초 단위로 변환 및 포맷팅
      console.log(`${seconds}초 경과`);
    }, 100);
  }
  ```

---

### 4. 실무 UI 제어 기법: 상태 관리와 이벤트 위임

스탑워치 예제를 통해, 비동기 로직과 UI를 연동하는 실용적인 기법들을 학습했다.

* **학습 목표 (Why?)**:
  단순히 기능을 구현하는 것을 넘어, 사용자의 오작동을 방지하고, 동적으로 생성되는 요소들을 효과적으로 제어하는 등 견고한 UI를 만들기 위함이다.

* **핵심 원리 (What?)**:
    * **상태 변수 (State Flag)**: `isRunning`, `isPaused`와 같이 프로그램의 현재 상태를 boolean 값으로 저장하는 변수. 이 변수를 통해 조건문을 만들어, 같은 버튼이라도
      현재 상태에 따라 다른 동작(e.g., '시작'/'일시정지')을 하도록 제어할 수 있다.
    * **UI 제어**: `button.disabled = true;`와 같이 요소의 속성을 변경하여 사용자의 특정 행동(e.g., 시작 버튼 중복 클릭)을 막는다.
    * **동적 요소와 이벤트 위임**: `createElement`로 생성된 여러 개의 로그 아이템에 각각 이벤트를 붙이는 대신, 그들의 부모 요소(`$logEntry`)에 이벤트 리스너를 하나만 등록하여
      이벤트를 처리한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  let isRunning = false; // 현재 스탑워치가 실행 중인지 여부를 나타내는 상태 변수
  const $pauseBtn = document.querySelector('#pause');

  $pauseBtn.addEventListener('click', () => {
    if (isRunning) { // 실행 중일 때 클릭하면
      // 일시정지 로직
      isRunning = false; // 상태 변경
      $pauseBtn.textContent = '재개'; // UI 텍스트 변경
    } else { // 멈춰있을 때 클릭하면
      // 재개 로직
      isRunning = true; // 상태 변경
      $pauseBtn.textContent = '일시정지'; // UI 텍스트 변경
    }
  });
  ```

---

## 오늘의 깨달음 💡

* 비동기 타이머를 제어하려면 타이머의 'ID'가 필요하고, 이 ID를 여러 함수에서 공유하기 위해 함수 바깥 스코프에 변수를 선언하는 패턴을 이해하게 되었다. `let timerId = null;`은 단순히 변수를
  만드는 것이 아니라, 비동기 작업을 제어하기 위한 '핸들'을 미리 준비해두는 중요한 설계였다.

* 프로그램의 현재 상태를 기억하는 '상태 변수(State Flag)'의 중요성을 깨달았다. `isRunning`과 같은 변수가 없다면, '시작', '일시정지', '재개'처럼 복잡하게 얽힌 UI의 흐름을 제어하는
  것이 거의 불가능에 가깝다. 상태가 코드를 지배한다.

* `clearInterval` 후 `timerId = null`로 다시 초기화하는 것은, 타이머를 멈추는 행위를 넘어 "현재 타이머가 동작 중이 아님"이라는 상태를 코드에 명시적으로 기록하는 행위이다. 이는 미래의
  다른 개발자나 자기 자신이 코드를 볼 때, 현재 상태를 명확히 파악하고 중복 실행과 같은 버그를 방지하게 해주는 좋은 습관임을 알게 되었다.

* 스탑워치를 직접 구현해보니, 하나의 작은 기능을 완성하기 위해 이전에 배운 DOM 조작, 이벤트 처리, 상태 관리, 비동기 로
  직 등 모든 개념이 유기적으로 결합되어야 함을 체감했다. 이론으로만 알던 개념들이 실제 문제 해결 과정에서 어떻게 상호작용하는지 깊이 이해할 수 있었다.