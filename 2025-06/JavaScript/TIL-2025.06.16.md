# TIL - 2025.06.16 - JavaScript 디바운스, 스로틀, 클로저 및 무한 스크롤 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Performance #Debounce #Throttle #Closure #InfiniteScroll

---

## 오늘 배운 내용 🔍

- 과도한 이벤트 호출을 제어하는 성능 최적화 기법: 디바운스(Debounce)와 스로틀(Throttle)
- 클로저(Closure)를 활용한 상태 은닉 및 독립적인 상태 관리 방법
- `...` 연산자의 두 가지 역할: 전개(Spread) 구문과 나머지 매개변수(Rest Parameters)
- 스크롤 이벤트와 DOM 측정을 이용한 무한 스크롤(Infinite Scroll) 구현 원리

---

## 어려웠던 점 💣

* 디바운스와 스로틀의 개념적 차이가 처음에는 명확하게 구분되지 않았다. 디바운스는 '연속된 이벤트가 모두 끝난 후 마지막에 한 번만 실행'하는 것(e.g., 검색어 입력)이고, 스로틀은 '연속된 이벤트가 발생하는
  동안 일정 시간 간격으로 주기적으로 실행'하는 것(e.g., 스크롤)이라는 핵심적인 차이를 예제를 통해 반복하며 이해해야 했다.

* 클로저를 단순히 "함수가 외부 함수의 변수를 기억하는 것"이라고만 생각하니 그 유용성이 와닿지 않았다. 하지만 여러 개의 카운터를 만들 때 각각의 `count` 변수가 서로에게 영향을 주지 않고 독립적으로
  관리되는 예제를 통해, 클로저가 **상태를 캡슐화하고 외부로부터의 직접적인 수정을 막는 '비공개 변수'처럼 동작**한다는 점을 깨달았다.

* `...` 연산자가 사용되는 위치에 따라 전개 구문(값을 펼침)과 나머지 매개변수(값을 모음)로 완전히 다르게 동작하는 점이 혼란스러웠다. 함수를 '정의'할 때 매개변수 자리에 쓰이면 나머지 매개변수, 함수를 '
  호출'할 때나 배열/객체 리터럴 안에서 쓰이면 전개 구문이라는 문맥적 차이를 구분하는 것이 중요했다.

---

## 정리 🖇️

### 1. 디바운스(Debounce)와 스로틀(Throttle)

잦은 이벤트 발생으로 인한 성능 저하를 막기 위한 이벤트 제어 기법을 학습했다.

* **학습 목표 (Why?)**:
  `resize`, `scroll`, `input` 이벤트 등 짧은 시간 동안 수없이 많이 발생하는 이벤트를 그대로 처리하면 브라우저에 과도한 부하가 걸린다. 이를 제어하여 불필요한 연산을 줄이고 애플리케이션의
  성능을 최적화하기 위함이다.

* **핵심 원리 (What?)**:
  두 기법 모두 고차 함수(Higher-Order Function) 패턴으로 구현된다.

  | 구분 | 디바운스 (Debounce) | 스로틀 (Throttle) |
      | :--- | :--- | :--- |
  | **핵심 개념** | 연이어 발생하는 이벤트를 그룹화하여, **마지막 이벤트 후 일정 시간이 지나면 딱 한 번만** 콜백 함수를 실행. | 연이어 발생하는 이벤트를 **일정 시간 간격으로 최대 한 번씩만** 실행하도록 조절. |
  | **실행 시점** | 이벤트 흐름이 **끝난 후**. | 이벤트 흐름 **도중에 주기적으로**. |
  | **주요 사용 예시** | 검색어 자동 완성, 창 크기 조절 후 레이아웃 재계산. | 스크롤 위치에 따른 애니메이션, 무한 스크롤. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 디바운스 구현 패턴
  function debounce(callback, delay = 500) {
    let timerId = null;
    return (...args) => {
      clearTimeout(timerId); // 이전 타이머는 취소
      // 마지막 이벤트로부터 delay 이후에 콜백 실행 예약
      timerId = setTimeout(() => callback(...args), delay);
    };
  }

  // 스로틀 구현 패턴
  function throttle(callback, delay = 500) {
    let timerId = null;
    return (...args) => {
      // 현재 실행 중인 타이머가 없을 때만
      if (timerId === null) {
        // delay 이후에 콜백 실행 예약
        timerId = setTimeout(() => {
          callback(...args);
          timerId = null; // 실행 후에는 다시 null로 만들어 다음 호출을 허용
        }, delay);
      }
    };
  }

  // 실제 적용
  const $input = document.querySelector('input');
  $input.addEventListener('input', debounce(e => console.log(e.target.value), 300));

  window.addEventListener('scroll', throttle(() => console.log('scrolling!'), 1000));
  ```

---

### 2. 무한 스크롤 (Infinite Scroll)

사용자가 페이지 하단에 도달했을 때 새로운 콘텐츠를 동적으로 불러오는 UI 패턴을 학습했다.

* **학습 목표 (Why?)**:
  대량의 콘텐츠를 페이지네이션 없이 사용자에게 자연스럽게 제공하여 끊김 없는 탐색 경험을 주기 위함이다.

* **핵심 원리 (What?)**:
  스크롤 이벤트가 발생할 때마다, 현재 사용자가 보고 있는 화면의 하단 위치가 문서 전체 높이의 끝에 가까워졌는지를 계산하여 판단한다.

  | 값 | 설명 |
      | :--- | :--- |
  | `window.scrollY` | 스크롤 바가 수직으로 얼마나 내려왔는지 (현재 스크롤 위치). |
  | `window.innerHeight`| 현재 브라우저 창(뷰포트)의 높이. |
  | `document.body.offsetHeight` | 렌더링된 전체 문서의 높이. |

* **문법 및 사용법 (How?)**:
  ```javascript
  const scrollHandler = () => {
    // 현재 화면 하단 위치 >= (문서 전체 높이 - 버퍼 영역)
    if (window.scrollY + window.innerHeight >= document.body.offsetHeight - 100) {
      loadMoreData(); // 새로운 데이터를 불러오는 함수
    }
  };

  // scroll 이벤트는 매우 자주 발생하므로 반드시 스로틀 적용!
  window.addEventListener('scroll', throttle(scrollHandler, 1000));
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **스로틀은 필수**: 스크롤 이벤트에 스로틀을 적용하지 않으면, 사용자가 스크롤하는 동안 수십, 수백 번의 불필요한 계산과 함수 호출이 발생하여 심각한 성능 저하를 유발한다.
    * **디바운스는 부적합**: 무한 스크롤에 디바운스를 사용하면, 사용자가 스크롤을 완전히 '멈춘 후에야' 데이터가 로드되므로 의도한 대로 동작하지 않는다.

---

### 3. 클로저(Closure)를 이용한 상태 관리

함수가 선언될 때의 렉시컬 환경(Lexical Environment)을 기억하여, 외부 함수의 실행이 끝난 후에도 내부 변수에 접근할 수 있는 방법을 학습했다.

* **학습 목표 (Why?)**:
  전역 변수를 사용하지 않으면서도, 특정 상태(state)를 함수가 호출될 때마다 유지하고 변경하기 위함이다. 이를 통해 상태를 외부로부터 안전하게 보호(캡슐화)하고, 독립적인 여러 개의 상태 인스턴스를 만들 수
  있다.

* **핵심 원리 (What?)**:
  외부 함수(`counterClosure`)가 내부 함수(`increment`, `decrement`)를 반환할 때, 이 내부 함수들은 자신이 생성될 때의 환경(외부 함수의 `count` 변수)을 계속 참조할 수
  있다. 이 현상 또는 함수를 클로저라고 한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  function createCounter() {
    let count = 0; // 이 count 변수는 외부에서 직접 접근 불가능 (비공개 변수)

    // count 변수를 참조하는 내부 함수들을 객체로 묶어 반환
    return {
      increase: () => ++count,
      getCount: () => count,
    };
  }

  const counter1 = createCounter();
  counter1.increase();
  console.log(counter1.getCount()); // 1

  const counter2 = createCounter(); // counter1과는 완전히 독립된 새로운 count 변수를 가짐
  counter2.increase();
  counter2.increase();
  console.log(counter2.getCount()); // 2
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 클로저는 React의 `useState` 훅과 같은 현대적인 상태 관리 패턴의 근간이 되는 중요한 개념이다.

---

### 4. 전개(Spread) vs. 나머지(Rest) 연산자 (`...`)

동일한 `...` 문법이 사용되는 위치(문맥)에 따라 완전히 다른 역할을 수행하는 것을 학습했다.

| 구분 | 문법 | 역할 | 주요 사용 위치 |
| :--- | :--- | :--- | :--- |
| **전개(Spread)** | `...배열` 또는 `...객체` | 배열이나 객체의 요소들을 **펼쳐서** 다른 곳에 넣음. | 함수 **호출 시** 인자로 전달, 배열/객체 리터럴 내부. |
| **나머지(Rest)** | `...변수명` | 여러 개의 인자들을 하나의 **배열로 모음**. | 함수 **정의 시** 매개변수 자리. |

---

## 오늘의 깨달음 💡

* 디바운스와 스로틀은 단순히 이벤트를 줄이는 기술이 아니라, 사용자의 '의도'를 파악하는 지능적인 제어 기법임을 깨달았다. 사용자가 타이핑을 '마쳤는지'(디바운스), 아니면 스크롤을 '하고 있는지'(스로틀)를
  구분하여 최적의 UX를 제공할 수 있다.

* 클로저는 "상태를 은닉하고 보호하는 안전한 금고"와 같았다. 전역 변수를 사용하면 어디서든 값이 변경될 위험이 있지만, 클로저를 사용하면 오직 허용된 메서드(`increase` 등)를 통해서만 내부 상태(
  `count`)에 접근할 수 있어, 더 안정적이고 예측 가능한 코드를 작성할 수 있다.

* 무한 스크롤 구현을 통해, 사용자 경험과 시스템 성능 사이의 균형을 맞추는 것이 얼마나 중요한지 체감했다. 스크롤 이벤트를 그대로 사용하는 것은 쉽지만 성능을 해치고, 스로틀을 적용하는 것은 약간의 복잡성을
  더하지만 사용자 경험과 성능을 모두 잡는 프로다운 방식이다.

* JavaScript의 고급 개념들은 각각 독립적으로 존재하는 것이 아니라, 서로 유기적으로 연결되어 있음을 알게 되었다. 디바운스와 스로틀은 고차 함수와 클로저를 기반으로 구현되고, 무한 스크롤은 스로틀과 DOM
  API를 함께 사용해야 하는 것처럼, 개념들을 조합하여 문제를 해결하는 능력이 중요하다.