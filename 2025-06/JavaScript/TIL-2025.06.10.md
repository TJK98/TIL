# TIL - 2025.06.10 - DOM 구조, 요소 선택/조작 및 클래스 제어 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #DOM #DOMManipulation #querySelector #classList

---

## 오늘 배운 내용 🔍

- 브라우저가 HTML을 해석하는 방식인 DOM(Document Object Model)의 구조
- 다양한 DOM 요소 선택 메서드 비교 (`getElementById`, `querySelector`, `querySelectorAll` 등)
- 선택된 요소를 기준으로 DOM 트리를 탐색하는 방법 (`parentElement`, `children` 등)
- DOM 요소의 콘텐츠(`textContent`, `innerHTML`) 및 속성(`setAttribute`) 조작
- 새로운 DOM 요소를 동적으로 생성, 삽입, 교체, 제거하는 방법
- `style` 객체와 `classList`를 이용한 스타일 및 클래스 제어

---

## 어려웠던 점 💣

* JavaScript의 `.classList.add()`로 클래스를 추가해도 브라우저의 '페이지 소스 보기'에서는 보이지 않아 혼란스러웠다. 이는 DOM 조작이 정적인 HTML 파일을 수정하는 것이 아니라,
  메모리에 로드된 **동적인 문서 객체(DOM)를 변경**하는 것이라는 개념을 이해하고 나서야 납득할 수 있었다.

* `children[0]`(JavaScript)과 `:nth-child(1)`(CSS)처럼, 동일한 첫 번째 자식 요소를 가리키더라도 인덱싱 시작 번호가 각각 `0`과 `1`로 다른 점이 헷갈렸다. **
  JavaScript는 프로그래밍의 배열 관점(0-based), CSS는 문서의 순서 관점(1-based)**이라는 차이를 명확히 인지해야 했다.

* `getElementsByClassName`이 반환하는 `HTMLCollection`과 `querySelectorAll`이 반환하는 `NodeList`가 배열처럼 보이지만, `map`이나 `filter` 같은
  배열 고차 함수를 직접 사용할 수 없다는 점이 혼란스러웠다. 이들은 '유사 배열 객체(Array-like Object)'이므로, 배열 메서드를 사용하기 위해서는 실제 배열로 변환하는 과정이 필요하다는 것을 알게
  되었다.

---

## 정리 🖇️

### 1. DOM(Document Object Model) 요소 선택

JavaScript가 HTML 문서를 제어할 수 있도록, 문서의 특정 요소를 찾아내는 방법을 학습했다.

* **학습 목표 (Why?)**:
  웹 페이지의 특정 부분(버튼, 입력창, 텍스트 등)에 동적인 기능을 추가하거나 내용을 변경하려면, 먼저 JavaScript가 해당 HTML 요소를 정확히 '선택'할 수 있어야 하기 때문이다.

* **핵심 원리 (What?)**:
  DOM은 HTML 문서를 노드(Node)와 객체(Object)로 표현한 트리 구조다. JavaScript는 다양한 메서드를 제공하여 이 트리 구조에서 원하는 노드를 효율적으로 찾을 수 있다.
  | 메서드 | 반환 개수 | 선택자 문법 | 반환 타입 | 특징 |
  | :--- | :--- | :--- | :--- | :--- |
  | `getElementById('id')` | 1개 | ID 이름 (문자열) | `HTMLElement` | 빠르고 명확함. |
  | `querySelector(selector)` | **첫 번째** 1개 | CSS 선택자 | `Element` | 매우 유연. 복잡한 선택 가능. |
  | `getElementsByClassName('class')`| 여러 개 | Class 이름 (문자열) | `HTMLCollection`| **Live**. DOM 변경이 실시간 반영됨. |
  | `querySelectorAll(selector)`| 여러 개 | CSS 선택자 | `NodeList` | **Static**. 선택 시점의 상태를 유지함. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // ID로 선택 (가장 빠름)
  const titleElement = document.getElementById('main-title');

  // CSS 선택자로 첫 번째 요소 선택
  const firstItem = document.querySelector('.list-item');

  // CSS 선택자로 모든 요소 선택
  const allItems = document.querySelectorAll('.list-item');
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **작명 관례**: DOM 요소를 담는 변수는 `$title`이나 `titleElem`처럼 일반 변수와 구분되는 접두사/접미사를 붙여 가독성을 높이는 것이 좋다.
    * **`HTMLCollection` & `NodeList`**: 이들은 배열이 아니므로 `map`, `filter` 등의 배열 메서드를 직접 사용할 수 없다. 사용하려면 실제 배열로 변환해야 한다.
      ```javascript
      const items = document.querySelectorAll('.item');

      // NodeList는 forEach는 지원함
      items.forEach(item => console.log(item.textContent));

      // map을 사용하려면 배열로 변환
      const texts = Array.from(items).map(item => item.textContent);
      // 또는 const texts = [...items].map(item => item.textContent);
      ```

---

### 2. DOM 탐색 및 콘텐츠 조작

선택한 요소를 기준으로 부모, 자식, 형제 요소를 탐색하고, 요소 내부의 내용을 변경하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  특정 이벤트를 기준으로 연관된 다른 요소들을 제어하거나, 서버로부터 받아온 데이터로 페이지의 내용을 동적으로 업데이트하기 위함이다.

* **핵심 원리 (What?)**:
    * **DOM 탐색**: 선택된 요소를 기점으로 상하좌우 관계에 있는 다른 요소 노드에 접근한다.
    * **콘텐츠 조작**: 요소 내부의 텍스트나 HTML 구조를 변경한다.
      | 탐색 속성 | 설명 |
      | :--- | :--- |
      | `parentElement` | 부모 요소를 반환. |
      | `children` | **요소 노드**로만 구성된 `HTMLCollection`을 반환. (텍스트 노드 제외) |
      | `childNodes` | 텍스트, 주석 등 **모든 노드**를 포함한 `NodeList`를 반환. |
      | `firstElementChild`, `lastElementChild` | 첫 번째/마지막 자식 요소를 반환. |
      | `nextElementSibling`, `previousElementSibling`| 다음/이전 형제 요소를 반환. |
      | `closest(selector)` | 자신을 포함하여 가장 가까운 상위 조상 중 CSS 선택자와 일치하는 요소를 반환. |
      | 콘텐츠 조작 속성 | 설명 |
      | :--- | :--- |
      | `textContent` | 순수한 텍스트 내용만 가져오거나 설정. HTML 태그는 일반 텍스트로 처리됨. |
      | `innerHTML` | HTML 태그를 포함한 내용을 가져오거나 설정. 보안에 취약할 수 있음(XSS 공격). |

* **문법 및 사용법 (How?)**:
  ```javascript
  const list = document.querySelector('.my-list');
  const firstItem = list.firstElementChild;

  // 첫 번째 아이템의 텍스트 변경
  firstItem.textContent = 'Updated Item 1';

  // 리스트의 마지막에 새로운 HTML 콘텐츠 추가
  list.innerHTML += '<li>New Item From innerHTML</li>';
  ```

---

### 3. DOM 요소 생성 및 속성/클래스 제어

JavaScript로 새로운 HTML 요소를 만들고 문서에 추가하며, 속성과 클래스를 동적으로 제어하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  사용자 인터랙션에 따라 새로운 UI 요소를 동적으로 생성하거나(e.g., 댓글 추가), 요소의 상태 변화를 시각적으로 표현하기(e.g., 버튼 활성화/비활성화) 위함이다.

* **핵심 원리 (What?)**:
    * **요소 생성/삽입**: `document.createElement()`로 요소를 만들고, `append()`, `prepend()` 등으로 문서 트리에 삽입한다.
    * **속성 조작**: `setAttribute()`, `getAttribute()` 등으로 HTML 속성을 제어한다. `data-*` 속성은 `dataset` 객체로 쉽게 접근할 수 있다.
    * **클래스 조작**: `classList` 객체를 사용하는 것이 문자열인 `className` 속성을 직접 조작하는 것보다 훨씬 안전하고 편리하다.
      | `classList` 주요 메서드 | 설명 |
      | :--- | :--- |
      | `add('class')` | 클래스를 추가한다. |
      | `remove('class')` | 클래스를 제거한다. |
      | `toggle('class')` | 클래스가 있으면 제거하고, 없으면 추가한다. |
      | `contains('class')`| 클래스의 존재 여부를 `true`/`false`로 반환한다. |
      | `replace('old', 'new')` | 기존 클래스를 새로운 클래스로 교체한다. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 1. 'p' 태그 요소 생성
  const newParagraph = document.createElement('p');

  // 2. 콘텐츠 및 속성, 클래스 설정
  newParagraph.textContent = 'This is a new paragraph.';
  newParagraph.setAttribute('id', 'new-para');
  newParagraph.classList.add('highlight');

  // 3. body의 마지막 자식으로 삽입
  document.body.append(newParagraph);

  // 4. 스타일 직접 조작
  // CSS 속성명은 카멜 케이스(camelCase)로 변환하여 사용
  newParagraph.style.backgroundColor = 'yellow';
  newParagraph.style.fontSize = '1.2rem';
  ```

---

## 오늘의 깨달음 💡

* DOM 조작은 정적인 HTML 파일을 바꾸는 것이 아니라, 브라우저가 메모리에 그려놓은 '살아있는 문서 객체'를 변경하는 과정임을 명확히 이해했다. `.classList.add()`의 결과가 개발자 도구의 '
  Elements' 탭에는 보이지만 '페이지 소스'에는 보이지 않는 이유가 바로 이것이었다.

* `querySelector`는 단순히 "하나만 선택"하는 도구가 아니라, 복잡한 CSS 선택자를 그대로 활용하여 DOM 트리의 깊은 곳에 있는 요소도 한 번에 찾아낼 수 있는 매우 강력하고 유연한 도구임을
  깨달았다.

* `HTMLCollection`과 `NodeList`가 배열이 아니라는 사실, 그리고 이를 실제 배열로 변환(`Array.from()`, `...`)해야 `map`, `filter`와 같은 강력한 배열 메서드를
  활용할 수 있다는 점을 알게 되었다. 이는 DOM 요소를 다룰 때 생산성을 극적으로 높여주는 핵심적인 기법이다.

* 스타일 제어 시, `element.style` 속성을 직접 바꾸는 것은 특정 요소에 대한 일회성 변경에 적합하지만, 재사용성과 유지보수 측면에서는 미리 정의된 CSS 클래스를 `classList`로 추가/제거하는
  방식이 훨씬 우월하다는 것을 깨달았다. 이는 구조(HTML), 표현(CSS), 동작(JS)을 분리하는 중요한 원칙과도 맞닿아 있다.