# TIL - 2025.06.11 - JavaScript 이벤트 리스너, 이벤트 객체 및 이벤트 위임 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #DOM #Event #EventListener #EventPropagation #EventDelegation

---

## 오늘 배운 내용 🔍

- 웹 페이지와 사용자 상호작용의 핵심인 이벤트(Event)의 개념
- 세 가지 이벤트 리스너 등록 방식 비교 (HTML 속성, 프로퍼티, `addEventListener`)
- `addEventListener`의 장점과 `removeEventListener`를 이용한 이벤트 핸들러 제거
- 이벤트 발생 시 브라우저가 제공하는 이벤트 객체(Event Object)와 주요 속성
- 이벤트 전파(Event Propagation) 메커니즘: 캡처링과 버블링
- 성능 최적화와 동적 요소 제어를 위한 이벤트 위임(Event Delegation) 패턴

---

## 어려웠던 점 💣

* 이벤트 리스너에 함수를 등록할 때 `handler`와 `handler()`의 차이를 구분하는 것이 혼란스러웠다. `handler()`처럼 괄호를 붙이면 함수가 그 자리에서 즉시 '실행'되어 그 '반환값'이
  리스너로 등록되는 반면, `handler`처럼 괄호 없이 함수 이름만 전달해야 함수 자체가 '참조'로 전달되어 이벤트 발생 시 호출된다는 개념을 이해해야 했다.

* 이벤트 핸들러 함수의 첫 번째 매개변수(`e`)가 어디서 오는지 명확하지 않았다. 이 이벤트 객체는 개발자가 직접 만드는 것이 아니라, 이벤트가 발생했을 때 **브라우저가 자동으로 생성하여 핸들러 함수에 인자로
  전달**해주는 특별한 객체라는 것을 알게 되었다.

* 자식 요소에서 발생한 이벤트가 부모 요소로 전파되는 '버블링' 현상이 왜 기본 동작인지, 그리고 이것이 왜 유용한지 직관적으로 와닿지 않았다.

* 이벤트 위임 패턴의 동작 방식이 복잡하게 느껴졌다. 부모 요소에 이벤트를 등록해두고, `event.target`을 이용해 실제 이벤트가 발생한 자식 요소를 식별하여 처리하는 흐름을 이해하는 데 시간이 걸렸다.

* `event.preventDefault()`를 왜 사용해야 하는지 명확한 목적을 파악하기 어려웠다. `<a>` 태그의 페이지 이동이나 `<form>` 태그의 새로고침 같은 브라우저의 '기본 동작'을 막고, 대신
  JavaScript로 커스텀 동작(e.g., AJAX 요청)을 실행해야 할 때 필요하다는 것을 알게 되었다.

---

## 정리 🖇️

### 1. 이벤트 리스너(Event Listener) 등록

사용자의 행동(클릭, 키보드 입력 등)에 반응하여 특정 JavaScript 코드를 실행시키는 방법을 학습했다.

* **학습 목표 (Why?)**:
  정적인 웹 페이지를 넘어, 사용자의 상호작용에 따라 동적으로 변화하고 반응하는 인터랙티브한 웹 애플리케이션을 만들기 위함이다.

* **핵심 원리 (What?)**:
  이벤트 리스너는 특정 요소(Event Target)에서 특정 이벤트(Event Type)가 발생하는 것을 감지하고 있다가, 이벤트가 발생하면 지정된 함수(Event Handler)를 실행하는 메커니즘이다.
  | 등록 방식 | 특징 |
  | :--- | :--- |
  | **1. HTML 속성 방식** (`onclick="..."`) | HTML과 JavaScript가 분리되지 않아 비권장. |
  | **2. 프로퍼티 방식** (`element.onclick = fn;`)| 간단하지만, 이벤트 타입당 **하나의 핸들러만 등록 가능** (기존 핸들러 덮어씀). |
  | **3. `addEventListener` 방식** | **여러 개의 핸들러를 등록**할 수 있고, `removeEventListener`로 제거도 가능하여 가장 권장됨. |

* **문법 및 사용법 (How?)**:
  ```javascript
  const $button = document.querySelector('#my-btn');

  const handleClick = () => {
    console.log('버튼이 클릭되었습니다.');
  };

  // 가장 권장되는 방식
  $button.addEventListener('click', handleClick);

  // 이벤트 핸들러 제거 (반드시 참조가 동일한 함수여야 함)
  $button.removeEventListener('click', handleClick);
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **함수 참조 전달**: `addEventListener`의 두 번째 인자로는 실행할 함수 **자체(참조)**를 전달해야 한다. `handleClick()`과 같이 괄호를 붙이면 함수가 즉시 실행되어 그
      반환값(`undefined`)이 리스너로 등록되므로 의도대로 동작하지 않는다.
    * **네이밍 관례**: 이벤트 핸들러 함수는 `handleClick`, `submitHandler`처럼 이름에 `handle`이나 `Handler`를 붙여 일반 함수와 구분하는 것이 좋다.

---

### 2. 이벤트 객체(Event Object)와 이벤트 전파(Propagation)

이벤트가 발생했을 때 생성되는 부가 정보 객체와, 이벤트가 DOM 트리를 따라 전파되는 방식을 학습했다.

* **학습 목표 (Why?)**:
  이벤트가 발생한 요소가 무엇인지(`target`), 어떤 키가 눌렸는지(`key`) 등 이벤트에 대한 상세 정보를 활용하고, 이벤트의 전파 흐름을 제어하여 더 정교한 인터랙션을 구현하기 위함이다.

* **핵심 원리 (What?)**:
    * **이벤트 객체**: 이벤트 발생 시 브라우저가 자동으로 생성하여 핸들러 함수에 첫 번째 인자로 전달하는 객체.
      | 주요 속성/메서드 | 설명 |
      | :--- | :--- |
      | `event.type` | 발생한 이벤트의 종류 (e.g., `'click'`) |
      | `event.target` | **실제로 이벤트가 시작된** 가장 안쪽의 요소 |
      | `event.currentTarget`| 이벤트 리스너가 **등록된** 요소 (이벤트 위임 시 중요) |
      | `event.preventDefault()`| 브라우저의 기본 동작(e.g., 링크 이동)을 막음 |
      | `event.stopPropagation()`| 이벤트 전파(버블링 또는 캡처링)를 중단시킴 |
    * **이벤트 전파**: 이벤트가 발생하면 DOM 트리를 따라 전파되는 현상.
      | 단계 | 설명 |
      | :--- | :--- |
      | **캡처링(Capturing) 단계**| 최상위 `window` 객체에서부터 이벤트 발생 지점(`target`)까지 **내려가는** 과정. |
      | **버블링(Bubbling) 단계**| 이벤트 발생 지점(`target`)에서부터 최상위 `window` 객체까지 **올라가는** 과정. (기본 동작) |

* **문법 및 사용법 (How?)**:
  ```javascript
  const $form = document.querySelector('form');
  const $button = document.querySelector('button');

  $form.addEventListener('click', (e) => {
    console.log('form에서 이벤트 감지!'); // 2. 버블링으로 인해 두 번째로 실행
  });

  $button.addEventListener('click', (e) => {
    e.stopPropagation(); // 이 코드가 없으면 이벤트가 $form으로 전파됨
    console.log('button에서 이벤트 감지!'); // 1. target이므로 가장 먼저 실행
  });
  ```

---

### 3. 이벤트 위임 (Event Delegation)

여러 개의 자식 요소에 각각 이벤트를 등록하는 대신, 부모 요소 하나에만 이벤트를 등록하여 이벤트를 관리하는 디자인 패턴을 학습했다.

* **학습 목표 (Why?)**:
    1. **성능 최적화**: 수많은 자식 요소에 각각 리스너를 등록하는 것보다 부모 하나에만 등록하는 것이 메모리 사용량이 적다.
    2. **동적 요소 처리**: JavaScript로 나중에 새로 추가되는 자식 요소에도 별도의 이벤트 등록 없이 동일한 이벤트가 동작하게 만들 수 있다.

* **핵심 원리 (What?)**:
  이벤트 버블링을 활용하는 기법이다. 자식 요소에서 발생한 이벤트는 부모 요소로 전파(버블링)되므로, 부모 요소에 등록된 이벤트 리스너가 이를 감지할 수 있다. 이때 `event.target`을 확인하면 실제로
  어떤 자식 요소에서 이벤트가 시작되었는지 알 수 있다.

* **문법 및 사용법 (How?)**:
  ```javascript
  const $itemList = document.querySelector('#item-list');

  $itemList.addEventListener('click', (e) => {
    // 클릭된 요소가 'li'가 아니면 함수를 즉시 종료
    if (!e.target.matches('li.item')) return;

    // 실제로 클릭된 li 요소에 대한 처리
    e.target.classList.toggle('selected');
    console.log(`${e.target.textContent}이(가) 선택되었습니다.`);
  });

  // 나중에 새로운 li를 추가해도 위 이벤트 리스너가 정상적으로 동작함
  const $newItem = document.createElement('li');
  $newItem.className = 'item';
  $newItem.textContent = '새로운 아이템';
  $itemList.append($newItem);
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `event.target`은 이벤트가 시작된 가장 깊은 요소를, `event.currentTarget`은 이벤트 리스너가 부착된 요소(여기서는 `$itemList`)를 가리킨다. 이벤트 위임에서는 주로
      `event.target`을 사용하여 실제 클릭된 요소를 판별한다.
    * `e.target.matches('selector')`는 `e.target`이 주어진 CSS 선택자와 일치하는지 여부를 `true`/`false`로 반환해주므로, 원하는 자식 요소에서 이벤트가 발생했는지
      필터링하는 데 매우 유용하다.

---

## 오늘의 깨달음 💡

* 이벤트 리스너에 함수를 전달할 때 괄호의 유무는 '미래에 실행될 약속(참조)'과 '지금 당장의 실행(호출)'이라는 근본적인 차이를 만든다는 것을 깨달았다. 이벤트 핸들링은 '약속'을 등록하는 과정이다.

* 이벤트 버블링은 불필요한 기능이 아니라, 이벤트 위임이라는 강력한 패턴을 가능하게 하는 핵심 메커니즘이었다. 부모 요소 하나만으로 수많은 자식 요소를 제어하고, 심지어 미래에 생성될 요소까지 제어할 수 있다는
  점에서 매우 효율적인 설계 방식임을 이해했다.

* `event.target`은 마치 "사건의 진원지"와 같았다. 이벤트 리스너가 어디에 등록되었든 상관없이, 실제로 사용자가 상호작용한 지점이 어디인지 정확히 알려주므로, 이벤트 위임 패턴을 구현하는 데 없어서는
  안 될 중요한 정보임을 알게 되었다.

* `preventDefault()`는 브라우저와의 '주도권 싸움'에서 개발자가 승리하게 해주는 도구다. 폼 제출 시 유효성 검사를 먼저 수행하거나, 링크 클릭 시 페이지 이동 대신 모달 창을 띄우는 등, 브라우저의
  기본 동작을 가로채고 개발자가 의도한 사용자 경험을 만들어낼 수 있게 해준다.