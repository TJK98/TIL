# TIL - 2025.06.20 - 브라우저 저장소(localStorage, sessionStorage), 모듈화 및 번들링 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #WebStorage #localStorage #sessionStorage #ESModules #Webpack #Babel

---

## 오늘 배운 내용 🔍

- 브라우저 저장소인 로컬 스토리지(localStorage)와 세션 스토리지(sessionStorage)의 차이점
- Web Storage API의 기본 메서드 (`setItem`, `getItem`, `removeItem`, `clear`)
- 객체 데이터를 저장하기 위한 `JSON.stringify`와 `JSON.parse`의 활용
- 코드의 재사용성과 유지보수성을 높이는 JavaScript 모듈화 (`import`, `export`)
- 여러 모듈 파일을 하나로 합쳐주는 번들러(Bundler) Webpack의 역할
- 최신 JavaScript 문법을 구형 브라우저에서 동작하도록 변환해주는 트랜스파일러(Transpiler) Babel의 역할

---

## 어려웠던 점 💣

* 로컬 스토리지와 세션 스토리지의 차이를 '브라우저를 닫으면 사라진다'는 기술적인 설명만으로는 명확히 구분하기 어려웠다. 로컬 스토리지는 '사용자 설정'처럼 영구적인 데이터에, 세션 스토리지는 '일회성 폼
  데이터'처럼 현재 탭 세션에서만 유효한 임시 데이터에 사용된다는 구체적인 사용 맥락을 통해 비로소 그 차이를 체감할 수 있었다.

* `localStorage`가 오직 문자열만 저장할 수 있다는 제약이 처음에는 불편하게 느껴졌다. 이 때문에 JavaScript 객체를 저장하려면 `JSON.stringify()`로 문자열화하고, 다시 꺼내 쓸
  때는 `JSON.parse()`로 객체화하는 과정이 반드시 필요하다는 점을 인지해야 했다.

* Webpack과 Babel은 개념적으로는 '파일을 합치고 변환하는 도구'라고 이해했지만, 실제 설정 파일(`webpack.config.js`, `.babelrc`)을 보면 어떤 원리로 동작하는지, 왜 필요한지에
  대한 깊은 이해가 부족함을 느꼈다.

* 코드가 여러 개의 모듈 파일로 분리되자, 전체 애플리케이션의 데이터 흐름과 함수 호출 관계를 한눈에 파악하기가 어려워졌다. 각 파일이 명확한 단일 책임(Single Responsibility)을 갖도록 설계하는
  것이 얼마나 중요한지 깨달았다.

---

## 정리 🖇️

### 1. 브라우저 저장소: 로컬 스토리지 vs. 세션 스토리지

사용자의 웹 브라우저에 데이터를 키-값 쌍 형태로 저장하는 Web Storage API를 학습했다.

* **학습 목표 (Why?)**:
  서버와의 불필요한 통신을 줄이고, 사용자의 설정이나 임시 데이터를 브라우저에 저장하여 더 나은 사용자 경험을 제공하기 위함이다. (e.g., 다크 모드 설정 유지, API 응답 캐싱)

* **핵심 원리 (What?)**:
  두 저장소는 동일한 API를 공유하지만, 데이터의 생명 주기(Life Cycle)에서 결정적인 차이가 있다.

  | 항목 | localStorage | sessionStorage |
      | :--- | :--- | :--- |
  | **저장 기간** | **영구적**. 사용자가 직접 삭제하거나 브라우저 캐시를 지우지 않는 한 계속 유지됨. | **일시적**. 현재 탭(또는 브라우저)이 닫히면 데이터가 자동으로 삭제됨. |
  | **스코프** | 동일한 출처(Origin)의 모든 탭과 창에서 데이터가 공유됨. | 데이터가 현재 탭 내에서만 유효하며, 다른 탭과 공유되지 않음. |
  | **주요 사용 예시**| 사용자 테마 설정, 자동 로그인 정보(비민감), API 응답 캐시. | 일회성 폼 데이터, 현재 세션에서만 유효한 정보, 이전 페이지 기록. |

* **문법 및 사용법 (How?)**:
  ```javascript
  // [공통 메서드]
  // 데이터 저장 (값은 반드시 문자열이어야 함)
  localStorage.setItem('theme', 'dark');

  // 데이터 조회
  const currentTheme = localStorage.getItem('theme'); // 'dark'

  // 데이터 삭제
  localStorage.removeItem('theme');

  // 전체 데이터 삭제
  localStorage.clear();

  // [객체 데이터 저장 및 조회]
  const userSettings = { theme: 'dark', fontSize: 16 };
  // 1. 객체를 JSON 문자열로 변환하여 저장
  localStorage.setItem('settings', JSON.stringify(userSettings));
  // 2. 저장된 JSON 문자열을 가져와 다시 객체로 변환
  const loadedSettings = JSON.parse(localStorage.getItem('settings'));
  console.log(loadedSettings.theme); // 'dark'
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **보안 문제**: 로컬 스토리지는 JavaScript를 통해 쉽게 접근할 수 있어 XSS(Cross-Site Scripting) 공격에 취약하다. 따라서 **비밀번호, 개인 정보, 인증 토큰 등 민감한
      데이터는 절대 저장해서는 안 된다.**
    * **API 응답 캐싱**: 자주 변경되지 않는 데이터를 로컬 스토리지에 캐싱해두면, 불필요한 네트워크 요청을 줄여 애플리케이션의 로딩 속도를 향상시킬 수 있다.

---

### 2. JavaScript 모듈화 (ES Modules)

코드를 기능 단위로 여러 개의 파일로 분리하고, 필요에 따라 서로 불러와 사용하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  거대한 하나의 JavaScript 파일로 모든 기능을 구현하는 대신, 코드를 재사용 가능한 작은 조각(모듈)으로 나누어 **관심사를 분리**하고, 코드의 가독성, 유지보수성, 협업 효율성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  ES6 모듈 시스템은 `export`와 `import`라는 두 가지 핵심 키워드로 동작한다.
    * **`export`**: 특정 변수, 함수, 클래스를 다른 파일에서 사용할 수 있도록 외부로 내보낸다.
    * **`import`**: 다른 파일에서 `export`된 모듈을 현재 파일로 가져온다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 📁 dom.js: DOM 요소들을 모아둔 모듈
  export const $todoInput = document.querySelector('.todo-input');
  export const $addBtn = document.querySelector('.add-btn');

  // 📁 state.js: 데이터 상태 관리 모듈
  let todos = [];
  export function addTodo(text) { /* ... */ }
  export function getTodos() { return [...todos]; }

  // 📁 app.js: 메인 애플리케이션 파일
  import { $todoInput, $addBtn } from './dom.js';
  import { addTodo, getTodos } from './state.js';

  $addBtn.addEventListener('click', () => {
    addTodo($todoInput.value);
    console.log(getTodos());
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **실무 파일 구조**: `features`(기능별), `utils`(공용 함수), `api`(서버 통신) 등 명확한 역할에 따라 폴더 구조를 설계하는 것이 중요하다.
    * **상태 흐름**: 현대 프론트엔드 애플리케이션은 **[이벤트 발생] → [상태 변경] → [UI 렌더링] → [필요시 스토리지 저장]** 과 같은 예측 가능한 단방향 데이터 흐름을 따르는 경우가 많다.

---

### 3. 번들링(Bundling)과 트랜스파일링(Transpiling)

현대 JavaScript 개발에 필수적인 빌드 도구의 기본 개념을 학습했다.

* **학습 목표 (Why?)**:
  여러 개로 분리된 모듈 파일들을 브라우저가 효율적으로 로드할 수 있도록 하나의 파일로 합치고(번들링), 최신 JavaScript 문법(ES6+)을 구형 브라우저에서도 동작할 수 있도록 호환 가능한 코드로 변환(
  트랜스파일링)하기 위함이다.

* **핵심 원리 (What?)**:
    * **Webpack (모듈 번들러)**: `entry` 파일(시작점)부터 시작하여 `import`와 `export` 관계를 분석하고, 필요한 모든 JavaScript 파일과 리소스(CSS, 이미지 등)를
      하나의 파일(또는 여러 개)로 묶어주는 도구.
    * **Babel (트랜스파일러)**: 최신 JavaScript 코드(e.g., 화살표 함수, `const`/`let`)를 구형 브라우저에서도 이해할 수 있는 ES5 문법으로 변환해주는 컴파일러.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 📁 webpack.config.js: Webpack의 기본 설정 파일
  const path = require('path');

  module.exports = {
    entry: './src/app.js', // 번들링을 시작할 진입점 파일
    output: {
      filename: 'bundle.js', // 결과물 파일 이름
      path: path.resolve(__dirname, 'dist'), // 결과물을 저장할 폴더
    },
    // ... 추가 로더 및 플러그인 설정 ...
  };
  ```

---

## 오늘의 깨달음 💡

* 브라우저 저장소는 단순한 데이터 저장 공간이 아니라, **사용자 경험(UX)과 성능 최적화**를 위한 중요한 도구임을 깨달았다. 로컬 스토리지를 이용한 테마 설정 유지나 API 응답 캐싱은 사용자의 편의성을 크게
  높여주고 불필요한 네트워크 비용을 줄여준다.

* `localStorage`와 `sessionStorage`의 선택 기준은 데이터의 '중요도'가 아니라 '생명 주기'에 달려있다. "이 데이터가 현재의 브라우징 세션을 넘어서도 필요한가?"라는 질문이 두 기술을
  구분하는 가장 좋은 기준이었다.

* 모듈화는 단순히 코드를 파일 단위로 나누는 행위가 아니라, 각 파일이 **하나의 명확한 책임**을 갖도록 **기능을 분리하고 캡슐화**하는 설계 철학에 가깝다는 것을 이해했다.

* 로컬 스토리지가 매우 편리하지만, 클라이언트 측에서 쉽게 조작될 수 있다는 점에서 **보안에 대한 경각심**을 갖게 되었다. 특히 인증 토큰과 같은 민감 정보는 서버에서 제어하는 `HttpOnly` 쿠키를
  사용하는 것이 훨씬 안전하다는 실무적인 지식을 얻었다.