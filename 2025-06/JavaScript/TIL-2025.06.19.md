# TIL - 2025.06.19 - fetch와 curl을 이용한 API 요청 및 비동기 반복 제어 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Asynchronous #fetch #API #curl #async #await

---

## 오늘 배운 내용 🔍

- 브라우저 환경(`fetch`)과 CLI 환경(`curl`)에서의 API 요청 방식 비교
- HTTP POST 요청의 주요 구성 요소: URL, 메서드(method), 헤더(headers), 본문(body)
- `fetch` API 사용 시 `body` 데이터의 `JSON.stringify()` 필요성
- `fetch`의 옵션 객체를 구성하는 주요 메타데이터(metadata)의 역할
- `forEach`와 `async/await` 조합의 문제점과 순차적 비동기 처리를 위한 `for...of` 루프 활용

---

## 어려웠던 점 💣

* `fetch`와 `curl`이 동일한 API에 요청을 보내는 다른 '도구'일 뿐이라는 개념이 처음에는 명확하지 않았다. `fetch`는 브라우저의 JavaScript 런타임에서, `curl`은 터미널(CLI)
  환경에서 HTTP 통신을 수행하는 클라이언트라는 역할 차이를 구분해야 했다.

* `fetch` API의 두 번째 인자로 전달하는 옵션 객체의 `mode`, `credentials`, `cache`와 같은 속성들이 어떤 상황에 필요한지 실용성이 와닿지 않았다. 이 속성들이 단순한 설정이
  아니라, CORS 정책, 쿠키 전송, 캐싱 전략 등 브라우저의 보안 및 통신 정책을 제어하는 중요한 메타데이터임을 알게 되었다.

* `forEach` 루프 안에서 `async` 콜백 함수와 `await`를 사용했을 때, 반복이 순서대로 실행될 것이라고 예상했지만 실제로는 거의 동시에 병렬적으로 실행되어 당황했다. `forEach`는
  `await`를 기다려주지 않고 다음 반복으로 넘어간다는 내부 동작 원리를 이해해야 했다.

---

## 정리 🖇️

### 1. API 요청 방식 비교: `fetch` vs. `curl`

동일한 API 엔드포인트에 HTTP 요청을 보내는 두 가지 다른 환경의 도구를 비교 학습했다.

* **학습 목표 (Why?)**:
  웹 프론트엔드 개발(브라우저)과 서버 테스트 및 스크립팅(터미널)이라는 각기 다른 환경에서 API와 상호작용하는 방법을 이해하고, 각 도구의 문법과 특징을 구분하기 위함이다.

* **핵심 원리 (What?)**:
  `fetch`는 브라우저에 내장된 비동기 통신 API이며, `curl`은 다양한 프로토콜로 데이터를 전송할 수 있는 강력한 커맨드 라인 도구이다.

  | 항목 | `fetch` (브라우저 JavaScript) | `curl` (터미널/CLI) |
      | :--- | :--- | :--- |
  | **실행 환경**| 브라우저의 JavaScript 엔진 | 커맨드 라인 인터페이스 (터미널) |
  | **요청 메서드**| `method: 'POST'` 옵션으로 지정 | `-X POST` 플래그로 지정 |
  | **헤더 설정** | `headers: { 'Content-Type': 'application/json' }` | `-H 'Content-Type: application/json'` |
  | **본문 데이터**| **객체를 JSON 문자열로 변환** (`body: JSON.stringify(payload)`) | `-d '{ ... }'` 형태로 JSON 문자열 직접 전달 |
  | **응답 처리** | `Promise` 기반 (`.then()`, `async/await`)으로 비동기 처리 | 터미널 표준 출력(stdout)으로 즉시 결과 확인 |

* **문법 및 사용법 (How?)**:
  ```javascript
  // fetch 예시
  const API_KEY = 'YOUR_API_KEY';
  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`;
  const payload = { contents: [{ parts: [{ text: "Hello, world" }] }] };

  async function fetchData() {
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await response.json();
    console.log(data.candidates[0].content.parts[0].text);
  }
  ```
  ```bash
  # curl 예시 (터미널에서 실행)
  curl -X POST \
       -H 'Content-Type: application/json' \
       -d '{ "contents": [{ "parts": [{ "text": "Hello, world" }] }] }' \
       "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=YOUR_API_KEY"
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `fetch`로 `POST` 요청을 보낼 때 `body`에 JavaScript 객체를 그대로 넣으면 안 된다. 반드시 `JSON.stringify()`를 사용하여 JSON 형식의 문자열로 변환해야 한다.
    * API 응답 데이터에 접근할 때는 `candidates[0]`와 같이 정확한 경로를 사용해야 한다. 오타가 발생하면 `undefined`의 속성에 접근하려다 `TypeError`가 발생할 수 있다.

---

### 2. `fetch`의 메타데이터(옵션 객체)

`fetch` 함수에 전달하는 두 번째 인자인 옵션 객체의 주요 속성들을 학습했다.

* **학습 목표 (Why?)**:
  단순한 데이터 요청을 넘어, CORS 정책, 인증 정보(쿠키) 전송 여부, 캐싱 방식 등 브라우저의 통신 동작을 세밀하게 제어하기 위함이다.

* **핵심 원리 (What?)**:
  이 옵션 객체는 HTTP 요청에 대한 상세한 '설명서' 또는 '메타데이터' 역할을 한다.

  | 속성 | 설명 | 기본값 |
      | :--- | :--- | :--- |
  | `method` | HTTP 요청 방식 (`'GET'`, `'POST'`, `'PUT'`, `'DELETE'` 등) | `'GET'` |
  | `headers` | 요청 헤더. `Content-Type`, `Authorization` 등을 설정 | `{}` |
  | `body` | 요청 본문(payload). `GET` 요청에는 포함되지 않음. | `null` |
  | `mode` | 요청 모드. `cors`(기본), `no-cors`, `same-origin` 등 CORS 정책을 결정. | `'cors'` |
  | `credentials` | 쿠키와 같은 인증 정보를 요청에 포함할지 여부. `include`로 설정하면 다른 도메인 요청에도 쿠키를 전송. | `'same-origin'` |
  | `cache` | 브라우저 캐시를 어떻게 사용할지 결정. `no-store`(캐시 사용 안함), `reload`(캐시 무시) 등. | `'default'` |

---

### 3. 비동기 반복 제어: `forEach`의 함정과 `for...of`의 활용

배열을 순회하며 비동기 작업을 처리할 때 발생할 수 있는 순서 보장 문제를 학습했다.

* **학습 목표 (Why?)**:
  여러 개의 API 요청을 순차적으로 보내고 그 결과를 순서대로 처리하는 등, 비동기 작업의 실행 순서를 보장해야 하는 로직을 정확하게 구현하기 위함이다.

* **핵심 원리 (What?)**:
  `Array.prototype.forEach()` 메서드는 콜백 함수가 `Promise`를 반환하더라도 `await`를 기다려주지 않는다. `forEach`는 내부적으로 각 요소를 순회하며 콜백 함수를 '호출'만
  할 뿐, 그 콜백 함수의 비동기 작업이 끝날 때까지 기다리지 않고 즉시 다음 요소로 넘어간다.

  | 반복 구문 | 순차적 `await` 대기 | 순서 보장 | 특징 |
      | :--- | :--- | :--- | :--- |
  | `forEach(async (item) => ...)` | ❌ **불가능** | ❌ **안 됨** | 모든 비동기 작업이 거의 동시에 병렬적으로 시작됨. |
  | `for (const item of array) { await ... }`| ✅ **가능** | ✅ **보장됨** | `await`가 완료될 때까지 다음 반복으로 넘어가지 않고 기다림. |

* **문법 및 사용법 (How?)**:
  ```javascript
  const ids = [1, 2, 3];

  // ❌ 잘못된 사용 예: 순서 보장 안 됨 (거의 동시에 1, 2, 3 출력)
  async function fetchDataWithForEach() {
    console.log('forEach 시작');
    ids.forEach(async (id) => {
      await new Promise(resolve => setTimeout(resolve, 100)); // 0.1초 대기
      console.log(`ID: ${id}`);
    });
    console.log('forEach 끝'); // 이 라인이 id 출력보다 먼저 실행됨
  }

  // ✅ 올바른 사용 예: 순서 보장 됨 (0.1초 간격으로 1, 2, 3 순차 출력)
  async function fetchDataWithForOf() {
    console.log('for...of 시작');
    for (const id of ids) {
      await new Promise(resolve => setTimeout(resolve, 100));
      console.log(`ID: ${id}`);
    }
    console.log('for...of 끝'); // 모든 await가 끝난 후에 실행됨
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 비동기 작업을 '병렬'로 처리하여 전체 시간을 단축하고 싶을 때는 `forEach`가 아닌 `Promise.all()`과 `map`을 함께 사용하는 것이 좋다.
      `await Promise.all(ids.map(async id => ...))`

---

## 오늘의 깨달음 💡

* `fetch`와 `curl`은 같은 목적(HTTP 통신)을 가졌지만, 실행 환경(브라우저 vs. 터미널)과 문법이 완전히 다른 도구임을 명확히 구분하게 되었다. `curl`은 API를 빠르고 간단하게 테스트하고
  응답 구조를 파악하는 데 매우 유용했다.

* `fetch`의 옵션 객체는 단순한 설정값이 아니라, 브라우저의 복잡한 통신 메커니즘(보안, 캐싱 등)을 제어하는 '메타데이터'의 집합이라는 것을 깨달았다. 이는 프론트엔드 개발이 단순히 데이터를 요청하는 것을
  넘어, 웹 환경의 규칙을 이해해야 함을 의미한다.

* `forEach`가 `await`를 기다리지 않는다는 사실은 비동기 JavaScript의 중요한 함정 중 하나였다. 이는 `forEach`가 '동기적인 반복'을 위해 설계된 메서드이기 때문이며, 순서가 중요한
  비동기 작업을 처리할 때는 반드시 `for...of` 루프를 사용해야 한다는 명확한 기준을 세우게 되었다.

* 결국, 비동기 코드를 다룰 때는 '이 코드가 언제 실행되는가?'와 '다음 코드는 이 코드의 완료를 기다리는가?'를 항상 질문해야 한다. 이 질문에 대한 답이 `for...of`와 `forEach`의 선택을
  결정한다.