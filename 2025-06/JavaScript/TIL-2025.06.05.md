# TIL - 2025.06.05 - JavaScript 함수, 콜백, 고차 함수 및 스코프 체인 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Function #Scope #Callback #HigherOrderFunctions #ES6

---

## 오늘 배운 내용 🔍

- `const`와 `let`의 차이점과 불변성(Immutability)의 개념
- `for...of` 반복문과 이터러블(Iterable) 자료형의 순회
- 함수 선언문, 함수 표현식, 화살표 함수의 특징과 차이점
- 함수를 값처럼 다루는 일급 객체(First-Class Citizen) 특성
- 다른 함수의 인자로 전달되는 콜백(Callback) 함수의 개념과 활용
- `map`, `filter`, `reduce` 등 고차 함수(Higher-Order Function)의 원리 직접 구현

---

## 어려웠던 점 💣

* 블록 스코프(`{}`) 내에 찾는 변수가 없을 때, JavaScript 엔진이 바깥 스코프로 계속 올라가며 변수를 찾는 **스코프 체인**의 동작 방식이 처음에는 직관적으로 이해되지 않았다.

* `const`로 선언한 변수는 값을 변경할 수 없다는 규칙에 익숙해지는 데 시간이 걸렸다. 특히 습관적으로 `let`을 사용하던 방식에서 벗어나, '재할 μόνο이 필요한가?'를 먼저고민하고 기본적으로
  `const`를 사용하는 습관을 들이는 것이 중요했다.

* 함수를 다른 함수의 인자로 전달하고, 전달받은 함수 내부에서 그 함수를 호출하는 **콜백 패턴**의 실행 흐름이 추상적으로 느껴졌다. '행동' 자체를 값처럼 넘긴다는 개념에 익숙해지는 것이 어려웠다.

* 화살표 함수의 축약 문법(`(a, b) => a + b`)이 간결하지만, `function` 키워드에 익숙한 상태에서는 오히려 코드를 해석하는 데 시간이 더 걸렸다.

---

## 정리 🖇️

### 1. 변수 선언과 불변성 (`const` vs. `let`)

변수 선언 시 값의 변경 가능성에 따라 `const`와 `let`을 구분하여 사용하는 원칙을 학습했다.

* **학습 목표 (Why?)**:
  코드의 안정성과 예측 가능성을 높이기 위함이다. `const`를 사용함으로써 의도치 않은 재할당을 방지하고, 이 변수는 변하지 않는 값이라는 의도를 명확히 드러낼 수 있다.

* **핵심 원리 (What?)**:
    * `const`: **재할당이 불가능**한 상수를 선언한다. 한 번 할당된 값을 다른 값으로 바꿀 수 없다.
    * `let`: **재할당이 가능**한 변수를 선언한다.
    * **객체와 배열의 불변성**: `const`로 선언된 객체나 배열은 변수 자체가 다른 객체/배열로 재할당될 수 없을 뿐, **내부의 속성이나 요소는 수정이 가능**하다. 완전한 불변 객체를 만들려면
      `Object.freeze()`를 사용해야 한다.

* **문법 및 사용법 (How?)**:
  ```javascript
  const PI = 3.14;
  // PI = 3.14159; // TypeError: Assignment to constant variable.

  const user = { name: "Alice" };
  user.name = "Bob"; // 가능. user 객체 내부의 속성을 변경하는 것이므로.

  // user = { name: "Charlie" }; // 불가능. user 변수 자체를 다른 객체로 재할당.

  const frozenUser = Object.freeze({ name: "Dave" });
  frozenUser.name = "Eve"; // 변경이 무시됨.
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **스코프 체인(Scope Chain)**: 함수나 블록 내에서 변수를 찾을 때, 해당 스코프에 변수가 없으면 바깥쪽 상위 스코프로 계속 올라가며 변수를 찾는다. 이 때문에 내부 스코프에서는 상위 스코프의
      변수에 접근할 수 있다.
    * 실무에서는 일단 모든 변수를 `const`로 선언하고, 재할당이 꼭 필요한 경우에만 `let`으로 변경하는 방식을 권장한다.

---

### 2. `for...of` 반복문과 이터러블(Iterable)

배열, 문자열 등 순회 가능한(iterable) 자료구조의 각 **값(value)**에 직접 접근하는 간결한 반복문을 학습했다.

* **학습 목표 (Why?)**:
  전통적인 `for` 루프처럼 인덱스 변수를 직접 관리할 필요 없이, 데이터 컬렉션의 내용물을 더 직관적이고 가독성 높게 순회하기 위함이다.

* **핵심 원리 (What?)**:
  `for...of`는 `Symbol.iterator` 속성을 가진 **이터러블 객체**에만 사용할 수 있다.
  | 구분 | `for...in` | `for...of` |
  | :--- | :--- | :--- |
  | **순회 대상** | 객체의 **키(key)** 또는 배열의 **인덱스** | 이터러블 객체의 **값(value)** |
  | **주 사용처**| 일반 객체(Plain Object)의 프로퍼티 순회 | 배열, 문자열, Set, Map 등 |

* **문법 및 사용법 (How?)**:
  ```javascript
  const fruits = ['apple', 'banana', 'cherry'];

  for (const fruit of fruits) {
    console.log(fruit); // 'apple', 'banana', 'cherry' 순서로 출력
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 배열을 순회할 때 `for...in`을 사용하면 배열의 인덱스뿐만 아니라 예상치 못한 프로토타입 속성까지 순회할 수 있으므로, 배열 순회에는 `for...of`나 `forEach` 같은 전용 메서드를
      사용하는 것이 안전하다.

---

### 3. 함수 표현 방식과 일급 객체

JavaScript에서 함수를 정의하는 다양한 방법과, 함수가 값처럼 취급되는 특성을 학습했다.

* **학습 목표 (Why?)**:
  각 함수 선언 방식의 특징(특히 호이스팅과 `this` 바인딩)을 이해하고, 상황에 맞는 적절한 방식을 선택하며, 함수를 변수에 할당하거나 다른 함수의 인자로 전달하는 등 유연한 프로그래밍 패턴을 구현하기
  위함이다.

* **핵심 원리 (What?)**:
    * **일급 객체 (First-Class Citizen)**: JavaScript에서 함수는 변수에 할당할 수 있고, 다른 함수의 인자로 전달될 수 있으며, 함수의 반환값이 될 수도 있는, 다른 값들(숫자,
      문자열 등)과 동등한 지위를 갖는다.
      | 구분 | 함수 선언식 | 함수 표현식 | 화살표 함수 |
      | :--- | :--- | :--- | :--- |
      | **호이스팅** | ✅ 가능 | ❌ 불가능 | ❌ 불가능 |
      | **`this` 바인딩**| 호출 방식에 따라 동적으로 결정 | 호출 방식에 따라 동적으로 결정 | ❌ 없음 (상위 스코프의 `this`를 그대로 사용) |
      | **`return` 생략** | 불가능 | 불가능 | 본문이 한 줄일 경우 가능 |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 선언식 (호이스팅 O)
  function add(a, b) { return a + b; }

  // 표현식
  const subtract = function(a, b) { return a - b; };

  // 화살표 함수
  const multiply = (a, b) => a * b;

  // 함수 참조 복사
  const calculation = multiply;
  console.log(calculation(3, 4)); // 12
  ```

---

### 4. 콜백 함수(Callback Function)와 고차 함수(Higher-Order Function)

'행동'을 추상화하여 코드를 더 유연하고 재사용 가능하게 만드는 핵심적인 함수형 프로그래밍 패턴을 학습했다.

* **학습 목표 (Why?)**:
  특정 작업(e.g., 배열 순회)의 '언제', '어떻게'는 고정해두고, '무엇을' 할 것인지를 외부에서 주입받아 동작을 커스터마이징하기 위함이다. 이는 비동기 처리, 이벤트 핸들링 등 JavaScript의 많은
  핵심 기능의 기반이 된다.

* **핵심 원리 (What?)**:
    * **콜백 함수 (Callback Function)**: 다른 함수의 인자로 전달되어, 그 함수 내부에서 나중에 호출되는 함수.
    * **고차 함수 (Higher-Order Function)**: 콜백 함수를 인자로 받거나, 함수를 반환하는 함수. (e.g., `map`, `filter`)

* **문법 및 사용법 (How?)**:
  ```javascript
  // greetUser는 'formatter'라는 콜백 함수를 받는 고차 함수
  const greetUser = (name, formatter) => {
    console.log(formatter(name));
  };

  // formal과 casual은 greetUser에 전달될 콜백 함수들
  const formal = name => `안녕하세요, ${name}님`;
  const casual = name => `안녕, ${name}`;

  greetUser("Alice", formal); // 안녕하세요, Alice님
  greetUser("Bob", casual);   // 안녕, Bob
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 콜백 함수를 전달할 때는 함수 자체(`printMsg`)를 전달해야 하며, 함수를 실행한 결과(`printMsg()`)를 전달하면 안 된다. 후자는 함수의 반환값(주로 `undefined`)을 전달하는
      것이므로 의도대로 동작하지 않는다.

---

### 5. (추가 개념) 고차 함수 직접 구현하기

배열의 내장 고차 함수들의 동작 원리를 이해하기 위해 직접 구현해보았다.

* **`map(callback)`**: 배열의 모든 요소를 순회하며 콜백 함수를 적용한 **결과를 모아 새로운 배열**을 반환한다.
  ```javascript
  function map(array, callback) {
      const result = [];
      for (const item of array) { result.push(callback(item)); }
      return result;
  }
  ```
* **`filter(callback)`**: 배열의 모든 요소를 순회하며 콜백 함수가 `true`를 반환하는 **요소만 모아 새로운 배열**을 반환한다.
  ```javascript
  function filter(array, callback) {
      const result = [];
      for (const item of array) { if (callback(item)) { result.push(item); } }
      return result;
  }
  ```
* **`every(callback)`**: 배열의 **모든 요소**가 콜백 조건을 만족하면 `true`, 아니면 `false`를 반환한다.
  ```javascript
  function every(array, callback) {
      for (const item of array) { if (!callback(item)) { return false; } }
      return true;
  }
  ```
* **`some(callback)`**: 배열의 요소 중 **하나라도** 콜백 조건을 만족하면 `true`, 아니면 `false`를 반환한다.
  ```javascript
  function some(array, callback) {
      for (const item of array) { if (callback(item)) { return true; } }
      return false;
  }
  ```
* **`find(callback)`**: 콜백 조건을 만족하는 **첫 번째 요소**를 반환한다. 없으면 `undefined`를 반환한다.
  ```javascript
  function find(array, callback) {
      for (const item of array) { if (callback(item)) { return item; } }
      return undefined;
  }
  ```
* **`reduce(callback, initialValue)`**: 배열을 순회하며 누적 계산을 수행하여 **하나의 최종 결과값**을 반환한다.
  ```javascript
  function reduce(array, callback, initialValue) {
      let accumulator = initialValue;
      for (const item of array) { accumulator = callback(accumulator, item); }
      return accumulator;
  }
  ```

---

## 오늘의 깨달음 💡

* 스코프 체인은 JavaScript의 변수 탐색이 단방향(안쪽 → 바깥쪽)으로 이루어지는 중요한 규칙임을 이해했다. 이를 통해 왜 내부 함수가 외부 함수의 변수에 접근할 수 있는지 명확히 알게 되었다.

* `const`를 기본으로 사용하는 습관은 단순히 실수를 방지하는 것을 넘어, 코드의 '의도'를 명확히 하고 다른 개발자가 코드를 더 쉽게 예측할 수 있도록 돕는 중요한 커뮤니케이션 도구임을 깨달았다.

* 콜백 함수는 단순한 기술이 아니라, '어떻게 할 것인가(How)'와 '무엇을 할 것인가(What)'를 분리하는 프로그래밍 패러다임에 가깝다는 것을 느꼈다. 고차 함수가 'How'를 담당하고, 콜백 함수가 '
  What'을 담당함으로써 코드의 유연성과 재사용성이 극대화된다.

* 배열의 고차 함수들을 직접 `for...of` 문으로 구현해보니, 추상적으로만 느껴졌던 `map`, `filter` 등의 내부 동작 원리가 명확하게 이해되었다. 모든 고차 함수는 결국 '반복'과 '조건(콜백)'의
  조합이라는 본질을 파악할 수 있었다.