# TIL - 2025.05.20 - CSS 박스 모델, display 속성 및 단위 개념 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #BoxModel #Display #CSSUnits #Viewport

---

## 오늘 배운 내용 🔍

- 뷰포트 기준 상대 단위 `vw`, `vh`의 개념과 활용법
- 다양한 CSS 단위(`px`, `%`, `em`, `rem`, `vw`, `vh`)의 기준점과 특징 비교
- CSS 박스 모델(Box Model)의 4가지 구성 요소: `content`, `padding`, `border`, `margin`
- 레이아웃 계산을 편리하게 만드는 `box-sizing: border-box` 속성
- 요소의 배치 방식을 결정하는 `display` 속성 (`block`, `inline`, `inline-block`)
- 요소의 가시성을 제어하는 `display`, `visibility`, `opacity` 속성의 차이점

---

## 어려웠던 점 💣

* `%`, `em`, `rem`, `vw` 등 여러 상대 단위들의 기준점이 각각 달라 혼란스러웠다. 특히 `width: 50%`는 부모 요소의 너비를 기준으로 하고, `width: 50vw`는 브라우저 화면(
  뷰포트)의 너비를 기준으로 한다는 차이를 명확히 구분하는 것이 중요했다.

* `padding`과 `margin` 모두 여백을 만드는 속성이지만, 언제 어떤 것을 사용해야 하는지 명확한 기준을 세우기 어려웠다. `padding`은 요소의 내부 여백으로 요소 자체의 크기에 영향을 주고,
  `margin`은 요소의 외부 여백으로 다른 요소와의 간격을 조절한다는 근본적인 역할 차이를 이해해야 했다.

* 마진 병합(Margin Collapsing) 현상 때문에 예상과 다른 레이아웃 결과가 나왔다. 위쪽 박스의 `margin-bottom`과 아래쪽 박스의 `margin-top`이 만나면 더 큰 값 하나만 적용되는
  현상을 인지하지 못해 디버깅에 어려움을 겪었다.

* `display: inline-block`으로 지정된 요소들 사이에 의도치 않은 작은 공백이 생기는 문제가 발생했다. 이는 HTML 코드상의 줄바꿈이나 공백이 실제 화면에 공백 문자로 렌더링되기 때문이라는 것을
  알게 되었다.

---

## 정리 🖇️

### 1. CSS 단위 (Units)의 이해와 비교

요소의 크기, 글자 크기 등을 지정하는 다양한 단위의 특징과 사용 목적을 학습했다.

* **학습 목표 (Why?)**:
  다양한 화면 크기와 해상도에 유연하게 대응하는 반응형 웹 디자인을 구현하고, 유지보수가 용이한 스타일 시트를 작성하기 위함이다.

* **핵심 원리 (What?)**:
  CSS 단위는 기준 대상에 따라 절대 단위와 상대 단위로 나뉜다.

  | 단위 | 기준 대상 | 설명 | 반응형 |
      | :--- | :--- | :--- | :--- |
  | `px` | 고정값 (절대 단위) | 화면의 픽셀 수. 항상 고정된 크기를 가짐. | ❌ |
  | `%` | 부모 요소의 크기 | 부모 요소의 너비, 높이 등에 대한 백분율. | 🔺 |
  | `em` | 부모 요소의 폰트 크기 | 부모의 폰트 크기를 1em으로 하는 배수. 중첩 시 계산이 복잡해짐. | 🔺 |
  | `rem`| **루트 요소(`html`)**의 폰트 크기 | `html`의 폰트 크기를 1rem으로 하는 배수. 일관성 유지에 유리. | ✅ |
  | `vw` | **뷰포트(화면) 너비** | 브라우저 화면 너비의 1/100. | ✅ |
  | `vh` | **뷰포트(화면) 높이** | 브라우저 화면 높이의 1/100. | ✅ |

* **문법 및 사용법 (How?)**:
  ```css
  html {
    /* rem 단위의 기준이 되는 폰트 크기 */
    font-size: 16px;
  }

  .container {
    width: 80%; /* 부모 너비의 80% */
    font-size: 1.2em; /* 부모 폰트 크기의 1.2배 */
  }

  .title {
    font-size: 2rem; /* html 폰트 크기(16px)의 2배 = 32px */
  }

  .fullscreen-banner {
    width: 100vw; /* 화면 너비와 동일하게 */
    height: 100vh; /* 화면 높이와 동일하게 */
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`rem` vs `vw`**: `rem`은 폰트 크기를 기준으로 하므로 주로 텍스트, 간격 등 UI 요소 크기에 사용되어 접근성을 높인다. 반면 `vw`와 `vh`는 화면 크기 자체를 기준으로 하므로,
      전체 섹션의 높이나 너비를 화면에 꽉 채우는 등 레이아웃 구성에 주로 사용된다.
    * `%` 단위를 `height` 속성에 사용할 때, 부모 요소에 명시적인 `height` 값이 없으면 자식의 `height`는 계산되지 않아 0이 될 수 있다.
    * `em` 단위는 요소가 중첩될수록 `1.2em * 1.2em = 1.44em` 과 같이 계산이 복잡해지므로, 전역적인 크기 조절에는 `rem`을 사용하는 것이 훨씬 예측 가능하고 편리하다.

---

### 2. 박스 모델 (Box Model)과 `box-sizing`

모든 HTML 요소가 화면에서 공간을 차지하는 방식에 대한 핵심 원리를 학습했다.

* **학습 목표 (Why?)**:
  웹 페이지의 모든 요소는 사각형의 '박스'로 렌더링된다. 이 박스의 크기와 여백을 정확히 제어하여 의도한 레이아웃을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  CSS 박스 모델은 4개의 영역으로 구성된다.
    * **`content`**: 텍스트나 이미지가 표시되는 실제 내용 영역.
    * **`padding`**: `content`와 `border` 사이의 **내부 여백**. 요소의 배경색이나 배경 이미지가 적용되는 영역이다.
    * **`border`**: `padding`을 감싸는 테두리.
    * **`margin`**: `border` 바깥의 **외부 여백**. 다른 요소와의 간격을 조절하는 투명한 공간이다.

  `box-sizing` 속성은 요소의 너비(`width`)와 높이(`height`)를 계산하는 기준을 바꾼다.
    * `content-box` (기본값): `width`와 `height`가 `content` 영역만을 의미한다. `padding`과 `border`가 추가되면 요소의 전체 크기는
      `width + padding + border`가 되어 커진다.
    * `border-box`: `width`와 `height`가 `border`까지 포함한 전체 크기를 의미한다. `padding`이나 `border`를 추가해도 요소의 전체 크기는 변하지 않고, 내부의
      `content` 영역이 자동으로 줄어든다.

* **문법 및 사용법 (How?)**:
  ```css
  .box {
    width: 200px;
    padding: 20px;
    border: 5px solid black;
    margin: 10px;

    /* 이 속성이 없으면 실제 너비는 200 + 40 + 10 = 250px가 됨 */
    /* 이 속성이 있으면 실제 너비는 200px로 고정됨 */
    box-sizing: border-box;
  }

  /* width가 지정된 블록 요소를 수평 중앙 정렬하는 공식 */
  .center-box {
    width: 500px;
    margin: 0 auto; /* 상하 0, 좌우 auto */
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`padding` vs. `margin`**: `padding`은 "박스 안쪽으로 살을 찌우는 것"이고, `margin`은 "박스 바깥쪽으로 거리를 두는 것"이다. 요소에 배경색이 있을 때,
      `padding` 영역은 배경색이 칠해지지만 `margin` 영역은 투명하다.
    * **마진 병합 (Margin Collapsing)**: 수직으로 인접한 두 블록 요소의 `margin`이 만나면, 둘 중 더 큰 값의 `margin` 하나만 적용된다. (e.g., 위 요소의
      `margin-bottom: 20px`와 아래 요소의 `margin-top: 30px`이 만나면 간격은 50px가 아닌 30px가 됨)
    * **실무 Best Practice**: 예측 가능한 레이아웃 설계를 위해, CSS 초기화 코드에 아래와 같이 모든 요소에 `box-sizing: border-box`를 적용하는 것이 현대 웹 개발의
      표준이다.
      ```css
      * {
        box-sizing: border-box;
      }
      ```

---

### 3. `display` 속성과 요소의 배치

요소가 화면에 어떻게 배치될지를 결정하는 `display` 속성의 주요 값들을 학습했다.

* **학습 목표 (Why?)**:
  요소의 성격(줄바꿈 여부, 크기 지정 가능 여부 등)을 제어하여 원하는 레이아웃 구조를 만들기 위함이다.

* **핵심 원리 (What?)**:
  | 값 | 특징 | 너비/높이 | 상하 마진/패딩 | 대표 태그 |
  | :--- | :--- | :--- | :--- | :--- |
  | `block` | 한 줄 전체를 차지 (줄바꿈 발생) | O | O | `<div>`, `<p>`, `<h1>` |
  | `inline` | 콘텐츠 너비만큼만 차지 (줄바꿈 없음) | X | X | `<span>`, `<a>`, `<img>` |
  | `inline-block` | `inline`처럼 배치되지만 `block`처럼 크기/여백 제어 가능 | O | O | `<button>`, `<input>` |

* **문법 및 사용법 (How?)**:
  ```css
  /* a 태그는 기본적으로 inline 요소라 크기를 가질 수 없지만, block으로 변경하여 가능하게 함 */
  a.button-style {
    display: block;
    width: 100px;
    height: 40px;
    background-color: blue;
    color: white;
    text-align: center;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `inline-block` 요소들 사이에 생기는 미세한 공백은 HTML 코드상의 줄바꿈이나 띄어쓰기 때문이다. 이를 해결하기 위해 부모 요소에 `font-size: 0;`을 적용하거나, HTML 태그를
      붙여 쓰는 등의 방법이 있다.

---

### 4. 요소의 가시성 제어 비교

요소를 화면에서 보이지 않게 처리하는 세 가지 주요 속성의 차이점을 학습했다.

* **학습 목표 (Why?)**:
  상황에 맞게 요소를 숨기는 적절한 방법을 선택하기 위함이다. 단순히 보이지 않게 하는 것을 넘어, 레이아웃에 미치는 영향까지 고려해야 한다.

* **핵심 원리 (What?)**:

  | 속성 | 화면 표시 | 차지하는 공간 | 특징 |
      | :--- | :--- | :--- | :--- |
  | `display: none;` | 숨김 (사라짐) | **없음** (X) | 렌더링 트리에서 완전히 제거됨. 레이아웃에 영향을 줌. |
  | `visibility: hidden;` | 숨김 (보이지만 않음) | **유지** (O) | 공간은 차지한 채로 보이지만 않음. 자식 요소에서 `visibility: visible`로 다시 보이게 할 수 있음. |
  | `opacity: 0;` | 숨김 (투명함) | **유지** (O) | 완전히 투명한 상태일 뿐, 모든 속성과 이벤트(클릭 등)는 그대로 동작함. |

---

## 오늘의 깨달음 💡

* CSS 레이아웃의 핵심은 '박스'를 이해하는 것에서 시작된다는 것을 깨달았다. `width` 값을 정해도 `padding`과 `border` 때문에 전체 크기가 예상과 달라지는 경험을 통해,
  `box-sizing: border-box;`가 왜 현대 CSS의 필수적인 설정이 되었는지 체감했다.

* `display` 속성은 요소의 '본질'을 바꾸는 것과 같았다. `inline` 요소인 `<a>` 태그에 `display: block`을 부여하자, 너비와 높이를 가지는 버튼처럼 동작하는 것을 보며 CSS가
  단순히 꾸미는 것을 넘어 구조의 동작 방식까지 제어할 수 있음을 이해했다.

* 요소를 숨기는 방법이 세 가지나 있다는 사실이 놀라웠다. `display: none`은 존재 자체를 없애 레이아웃을 재배치시키는 반면, `visibility: hidden`은 자리만 차지하게 한다는 차이점을
  통해, CSS 속성 하나가 전체 페이지 구조에 미치는 영향을 신중하게 고려해야 함을 배웠다.