# TIL - 2025.05.21 - CSS Flexbox 기본 개념과 주요 속성 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #Layout #Flexbox

---

## 오늘 배운 내용 🔍

- `display` 속성의 `block`, `inline`, `inline-block` 특징 복습
- 1차원 레이아웃 시스템 Flexbox의 기본 개념 (컨테이너, 아이템, 주축/교차축)
- Flex 컨테이너 속성: `flex-direction`, `justify-content`, `align-items`, `flex-wrap`, `align-content`
- Flex 아이템 속성: `order`, `flex-grow`, `flex-shrink`, `flex-basis`, `align-self`
- `flex-wrap`과 `overflow` 속성의 역할 차이 비교

---

## 어려웠던 점 💣

* `justify-content`와 `align-items`가 `margin`이나 `padding`처럼 시각적으로 요소를 배치하는 점에서 비슷해 보였다. 하지만 `margin`이 고정된 공간을 추가하는 방식이라면,
  Flexbox 정렬 속성은 컨테이너 내의 가용 공간을 어떻게 '분배'하고 '정렬'할 것인지에 대한 규칙이라는 개념적 차이를 이해하는 데 시간이 필요했다.

* `align-items`와 `align-content`의 용도가 혼란스러웠다. `align-items`는 한 줄 안에서 아이템들의 교차축 정렬을 다루는 반면, `align-content`는
  `flex-wrap: wrap`으로 인해 아이템이 여러 줄로 나뉘었을 때, 그 '여러 줄 사이의 간격'을 조절하는 속성이라는 점을 구분해야 했다.

* `flex-wrap: wrap`과 `overflow` 모두 '콘텐츠가 넘칠 때'를 다룬다는 점에서 역할이 헷갈렸다. `flex-wrap`은 Flexbox 레이아웃 규칙에 따라 아이템을 다음 줄로 '내려보내는'
  정렬 방식이고, `overflow`는 요소의 박스 모델을 기준으로 넘치는 내용을 시각적으로 '잘라내거나 스크롤을 만드는' 처리 방식이라는 본질적인 차이를 인지했다.

* `flex-direction`이 `row`에서 `column`으로 바뀌면 주축과 교차축 자체가 뒤바뀐다는 점이 처음에는 직관적이지 않았다. 이로 인해 `justify-content`가 수평이 아닌 수직 정렬을,
  `align-items`가 수직이 아닌 수평 정렬을 제어하게 되는 것을 여러 번 실습을 통해 체득했다.

---

## 정리 🖇️

### 1. Flexbox의 기본 개념: 컨테이너와 아이템, 그리고 축

기존의 레이아웃 방식(float, inline-block 등)의 한계를 극복하는 현대적인 1차원 레이아웃 시스템을 학습했다.

* **학습 목표 (Why?)**:
  요소 간의 공간 배분과 정렬을 복잡한 계산 없이, 간결하고 유연하게 처리하기 위함이다. 특히 수직 중앙 정렬과 같이 기존 방식으로는 구현이 까다로웠던 레이아웃을 쉽게 만들기 위해 사용한다.

* **핵심 원리 (What?)**:
  Flexbox는 부모 요소인 **Flex Container**와 자식 요소인 **Flex Item**으로 구성된다. 모든 정렬은 **주축(Main Axis)**과 **교차축(Cross Axis)**이라는 두 개의
  축을 기준으로 이루어진다.
    * **`display: flex;`**: 특정 요소를 Flex Container로 만든다. 이 순간부터 직계 자식 요소들은 Flex Item이 되어 Flexbox의 규칙을 따른다.
    * **주축 (Main Axis)**: Flex 아이템들이 배치되는 기본 방향. 기본값은 가로(왼쪽 → 오른쪽)이다.
    * **교차축 (Cross Axis)**: 주축에 수직인 방향. 기본값은 세로(위 → 아래)이다.

* **문법 및 사용법 (How?)**:
  ```css
  .container {
    /* 이 선언 하나로 .container는 Flex Container가 되고,
       자식 .item들은 Flex Item이 된다. */
    display: flex;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * Flexbox의 모든 속성은 `Container`에 적용하는 속성과 `Item`에 적용하는 속성으로 명확히 구분되므로, 어떤 속성이 어디에 적용되는지 정확히 알아야 한다.
    * 주축과 교차축의 방향은 고정된 것이 아니며, `flex-direction` 속성에 의해 언제든지 바뀔 수 있다.

---

### 2. Flex 컨테이너(Container) 속성

Flex 아이템들의 그룹 전체에 대한 정렬, 방향, 줄바꿈 등을 제어하는 속성들을 학습했다.

* **학습 목표 (Why?)**:
  아이템들의 배치 방향을 결정하고, 주축 및 교차축을 기준으로 아이템 그룹을 정렬하며, 공간이 부족할 때 아이템들을 어떻게 처리할지 정의하기 위함이다.

* **핵심 원리 (What?)**:
  컨테이너에 적용되는 속성들은 아이템들의 전반적인 흐름과 배치를 결정한다.

* **문법 및 사용법 (How?)**:
  **1. `flex-direction`: 축의 방향 설정**

  | 값 | 설명 |
      | :--- | :--- |
  | `row` (기본값) | 아이템을 가로 방향(왼쪽→오른쪽)으로 정렬. 주축이 가로가 됨. |
  | `row-reverse` | 아이템을 가로 역방향(오른쪽→왼쪽)으로 정렬. |
  | `column` | 아이템을 세로 방향(위→아래)으로 정렬. 주축이 세로가 됨. |
  | `column-reverse`| 아이템을 세로 역방향(아래→위)으로 정렬. |

  **2. `justify-content`: 주축(Main Axis) 방향 정렬**

  | 값 | 설명 |
      | :--- | :--- |
  | `flex-start` (기본값) | 아이템들을 주축의 시작점으로 정렬. |
  | `flex-end` | 아이템들을 주축의 끝점으로 정렬. |
  | `center` | 아이템들을 주축의 중앙으로 정렬. |
  | `space-between`| 첫 아이템은 시작점, 마지막 아이템은 끝점에 붙이고 나머지 공간을 균등하게 배분. |
  | `space-around` | 모든 아이템 주변에 균등한 공간을 배분 (양 끝 아이템은 절반의 공간). |
  | `space-evenly` | 모든 아이템 사이와 양 끝에 완전히 동일한 공간을 배분. |

  **3. `align-items`: 교차축(Cross Axis) 방향 정렬 (한 줄 기준)**

  | 값 | 설명 |
      | :--- | :--- |
  | `stretch` (기본값) | 아이템의 높이를 컨테이너 높이에 맞춰 꽉 채움 (아이템에 height가 없어야 함). |
  | `flex-start` | 아이템들을 교차축의 시작점으로 정렬. |
  | `flex-end` | 아이템들을 교차축의 끝점으로 정렬. |
  | `center` | 아이템들을 교차축의 중앙으로 정렬 (수직 중앙 정렬). |
  | `baseline` | 아이템 내부의 텍스트 기준선(baseline)에 맞춰 정렬. |

  **4. `flex-wrap`: 아이템 줄바꿈 처리**

  | 값 | 설명 |
      | :--- | :--- |
  | `nowrap` (기본값) | 아이템이 컨테이너를 벗어나도 한 줄에 모두 배치. |
  | `wrap` | 공간이 부족하면 아이템을 다음 줄로 줄바꿈. |
  | `wrap-reverse` | `wrap`과 동일하나, 줄바꿈 방향이 역방향(아래→위)으로 발생. |

  **5. `align-content`: 교차축 방향 정렬 (여러 줄 기준)**

  | 값 | 설명 |
      | :--- | :--- |
  | `stretch` (기본값) | 각 줄을 늘려 교차축의 남는 공간을 모두 채움. |
  | `flex-start`, `flex-end`, `center` | 여러 줄 전체를 하나의 덩어리로 보고 교차축 기준으로 정렬. |
  | `space-between`, `space-around`, `space-evenly` | `justify-content`와 동일한 원리로, 여러 줄 사이의 간격을 배분. |

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`align-items` vs `align-content`**: `align-items`는 **한 줄** 내에서의 아이템 정렬을, `align-content`는 `flex-wrap: wrap`으로 인해
      발생한 **여러 줄** 사이의 간격과 정렬을 다룬다. 아이템이 한 줄일 경우 `align-content`는 아무런 효과가 없다.
    * **`flex-wrap` vs `overflow`**: `flex-wrap`은 Flexbox 레이아웃 규칙에 따라 아이템을 다음 줄로 '재배치'하는 속성이다. 반면 `overflow`는 박스 모델을
      기준으로, 넘치는 내용을 시각적으로 '잘라내거나 스크롤을 만드는' 속성이다. 목적 자체가 다르다.

---

### 3. Flex 아이템(Item) 속성

개별 Flex 아이템의 크기, 순서, 정렬 등을 제어하는 속성들을 학습했다.

* **학습 목표 (Why?)**:
  컨테이너의 전반적인 규칙을 따르면서도, 특정 아이템만 다르게 배치하거나 크기를 유연하게 조절하는 등 세밀한 제어를 하기 위함이다.

* **핵심 원리 (What?)**:
  아이템에 적용되는 속성들은 아이템 자체의 유연성(크기 조절)과 배치 순서, 개별 정렬을 정의한다.

* **문법 및 사용법 (How?)**:
  **1. `order`: 아이템 배치 순서 제어**

  | 값 | 설명 |
      | :--- | :--- |
  | `0` (기본값) | HTML 코드 순서대로 배치. |
  | 양수/음수 | 숫자가 작을수록 주축의 시작점 방향으로 먼저 배치됨 (`-1`은 `0`보다 앞). |

  **2. `flex-grow`, `flex-shrink`, `flex-basis`: 아이템 크기 유연성 제어**

  | 속성 | 설명 |
      | :--- | :--- |
  | `flex-grow` | 컨테이너에 남는 공간이 있을 때, 아이템이 늘어나는 비율 (기본값 `0`: 안 늘어남). |
  | `flex-shrink`| 컨테이너 공간이 부족할 때, 아이템이 줄어드는 비율 (기본값 `1`: 줄어듦). |
  | `flex-basis` | 아이템의 기본 크기. `width`나 `height`보다 우선순위가 높다. |

  **3. `align-self`: 개별 아이템의 교차축 정렬**

  | 값 | 설명 |
      | :--- | :--- |
  | `auto` (기본값) | 부모 컨테이너의 `align-items` 속성값을 상속. |
  | `flex-start`, `flex-end`, `center` 등 | 컨테이너의 설정을 무시하고 해당 아이템만 교차축 기준으로 개별 정렬. |

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`flex` 단축 속성**: 실무에서는 `flex-grow`, `flex-shrink`, `flex-basis`를 한번에 쓰는 `flex` 단축 속성을 주로 사용한다.
      `flex: <grow> <shrink> <basis>;` 순서.
    * `flex: 1;`은 `flex: 1 1 0;`을 의미하며, "기본 크기는 0이지만, 남는 공간을 모두 차지하라"는 뜻으로, 특정 아이템이 남은 영역을 모두 채우게 만들 때 매우 유용하다.

---

## 오늘의 깨달음 💡

* Flexbox는 `margin`이나 `padding`으로 공간을 '밀어내는' 방식이 아니라, 컨테이너 안의 가용 공간을 아이템들에게 어떻게 '분배할 것인가'에 대한 규칙을 정의하는, 한 차원 높은 레이아웃 제어
  방식임을 이해했다.

* `flex-direction`을 바꾸는 것은 단순히 아이템의 나열 방향을 바꾸는 것이 아니라, 레이아웃의 기준이 되는 '주축'과 '교차축' 자체를 회전시키는 근본적인 변화였다. 이 개념을 이해하자
  `justify-content`와 `align-items`의 동작이 비로소 명확하게 예측되기 시작했다.

* `align-items`와 `align-content`의 차이를 통해, Flexbox가 단일 행뿐만 아니라 다중 행 레이아웃까지 얼마나 정교하게 제어할 수 있는지 알게 되었다. 이는 복잡한 반응형 그리드 시스템을
  구축할 때 매우 강력한 도구가 될 것임을 깨달았다.