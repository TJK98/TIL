# TIL - 2025.05.22 - CSS Position, z-index 및 Flex/Grid 레이아웃 개념 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #Layout #Flexbox #Grid #Positioning #zIndex

---

## 오늘 배운 내용 🔍

- Flex 아이템의 크기 조절 속성 (`flex-grow`, `flex-basis`)
- 2차원 레이아웃 시스템 CSS Grid의 기본 개념
- 문서 흐름을 제어하는 `position` 속성 (`static`, `relative`, `absolute`, `fixed`, `sticky`)
- 요소의 쌓임 순서를 결정하는 `z-index`와 쌓임 맥락(Stacking Context)
- 레이아웃 제어에서 CSS와 JavaScript의 역할 분담

---

## 어려웠던 점 💣

* 동적인 레이아웃 변경은 JavaScript의 역할처럼 느껴졌으나, 기본적인 구조와 반응형 처리는 CSS가 담당한다는 원칙을 구분하는 것이 혼란스러웠다. `flex-grow`나 `grid` 같은 속성도 JS로
  제어할 수 있어, 어디까지가 CSS의 영역인지 명확한 경계를 설정하기 어려웠다.

* 요소의 쌓임 순서(stacking order)가 결정되는 규칙이 다층적이어서 이해하기 어려웠다. `position` 속성 유무, HTML 코드 순서, `z-index` 값 등 여러 조건이 복합적으로 작용하는
  원리를 파악하는 데 시간이 걸렸다.

---

## 정리 🖇️

### 1. Flex 아이템 크기 조절 (`flex-grow`, `flex-basis`)

Flex 컨테이너 내에서 아이템들이 공간을 차지하는 방식을 유연하게 제어하는 속성들을 학습했다.

* **학습 목표 (Why?)**:
  고정된 `width` 값 대신, 컨테이너의 가용 공간에 따라 아이템의 너비가 유동적으로 늘어나거나, 설정된 기본 크기를 유지하도록 하여 반응형 레이아웃을 구현하기 위함이다.

* **핵심 원리 (What?)**:

  | 속성 | 설명 |
    | :--- | :--- |
  | `flex-basis` | 아이템의 **기본 크기**를 설정. `width`와 유사하지만, Flexbox 레이아웃 계산에서 우선권을 가짐. 기본값은 `auto`. |
  | `flex-grow` | 컨테이너에 남는 공간이 있을 때, 아이템들이 **늘어나는 비율**을 설정. 기본값은 `0`(늘어나지 않음). |

* **문법 및 사용법 (How?)**:
  ```css
  .container {
    display: flex;
    width: 600px;
  }
  .item-A {
    flex-basis: 100px; /* 기본 크기 100px */
    flex-grow: 1;      /* 남는 공간의 1/3을 차지 */
  }
  .item-B {
    flex-basis: 200px; /* 기본 크기 200px */
    flex-grow: 2;      /* 남는 공간의 2/3을 차지 */
  }
  /* 
   * 컨테이너(600px) - A(100px) - B(200px) = 남는 공간 300px
   * A는 300px의 1/3인 100px을 추가로 가져가 최종 200px
   * B는 300px의 2/3인 200px을 추가로 가져가 최종 400px
   */
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `flex-basis`가 `0`으로 설정되면 아이템은 내용물의 크기를 무시하고 오로지 `flex-grow` 비율에 따라 공간을 나눠 갖는다.

---

### 2. (추가 개념) 2차원 레이아웃: CSS Grid 소개

행과 열을 동시에 제어하여 복잡한 2차원 격자 레이아웃을 만드는 Grid 시스템의 개념을 학습했다.

* **학습 목표 (Why?)**:
  Flexbox가 한 줄(행 또는 열) 단위의 1차원 레이아웃에 최적화된 반면, Grid는 웹 페이지 전체와 같이 행과 열이 복합적으로 구성된 2차원 레이아웃을 더 직관적으로 구현하기 위해 사용된다.

* **핵심 원리 (What?)**:
  `display: grid;`를 선언하여 그리드 컨테이너를 만들고, `grid-template-columns`와 `grid-template-rows` 속성을 사용하여 열과 행의 크기와 개수를 정의한다.
    * **Flexbox**: 1차원(One-Dimensional) - 콘텐츠 중심의 배치.
    * **Grid**: 2차원(Two-Dimensional) - 레이아웃 중심의 배치.

* **문법 및 사용법 (How?)**:
  ```css
  .container {
    display: grid;
    /* 1fr은 사용 가능한 공간의 1 비율을 의미.
       아래는 동일한 너비의 3개 열을 생성. */
    grid-template-columns: 1fr 1fr 1fr;
    /* 2개의 행을 각각 100px, 200px 높이로 생성 */
    grid-template-rows: 100px 200px;
    gap: 10px; /* 아이템 사이의 간격 */
  }
  ```

---

### 3. CSS 포지셔닝 (`position`)

요소를 일반적인 문서 흐름(Document Flow)에서 벗어나 원하는 위치에 배치하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  모달 창, 드롭다운 메뉴, 화면에 고정된 헤더 등 다른 요소 위로 겹쳐지거나 특정 위치에 고정되는 UI를 구현하기 위함이다.

* **핵심 원리 (What?)**:
  `position` 속성은 요소가 배치되는 기준과 방식을 결정한다. `top`, `right`, `bottom`, `left` 속성으로 위치를 미세 조정할 수 있다.

  | `position` 값 | 기준 위치 | 스크롤 영향 | 특징 |
    | :--- | :--- | :--- | :--- |
  | `static` | 일반적인 문서 흐름 | O | 기본값. 위치 조정 불가. |
  | `relative` | **자기 자신의 원래 위치** | O | 원래 있던 자리는 비워둔 채로 위치만 이동. |
  | `absolute` | **가장 가까운 `position` 조상** | O (조상 따라감)| 문서 흐름에서 완전히 벗어남. 주변 레이아웃에 영향을 줌. |
  | `fixed` | **뷰포트(브라우저 창)** | X | 화면 스크롤과 상관없이 항상 같은 위치에 고정됨. |
  | `sticky` | 일반적인 문서 흐름 + 스크롤 | O | 스크롤이 특정 위치에 도달하면 `fixed`처럼 동작. |

* **문법 및 사용법 (How?)**:
  ```css
  .wrapper {
    /* absolute 요소의 기준점이 되기 위해 relative 선언 */
    position: relative;
    width: 300px;
    height: 300px;
  }

  .modal {
    /* .wrapper의 좌측 상단을 기준으로 50px씩 떨어진 곳에 위치 */
    position: absolute;
    top: 50px;
    left: 50px;
  }

  .header {
    /* 화면 상단에 고정 */
    position: sticky;
    top: 0;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `position: absolute;`를 사용할 때, 기준점으로 삼고 싶은 부모 또는 조상 요소에 반드시 `position: relative;` (또는 `absolute`, `fixed`,
      `sticky`)를 선언해야 한다. 그렇지 않으면 `<body>` 태그가 기준이 된다.
    * `position`이 `static`이 아닌 요소는 문서 흐름에서 벗어나 다른 요소와 겹칠 수 있다.

---

### 4. 쌓임 맥락(Stacking Context)과 `z-index`

겹쳐진 요소들의 수직 쌓임 순서를 제어하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  어떤 요소를 다른 요소보다 위에 표시할지(e.g., 모달 창이 배경보다 위에 표시) 명시적으로 제어하여 의도한 UI 계층을 만들기 위함이다.

* **핵심 원리 (What?)**:
  `z-index`는 `position` 속성이 `static`이 아닌 요소에만 적용되는 '쌓임 순서' 값이다. 값이 클수록 더 위에 쌓인다.
    * **기본 쌓임 순서**:
        1. `position`이 없는 요소 (HTML 코드 순서대로 쌓임)
        2. `position`이 있는 요소 (`z-index`가 없거나 같으면 HTML 코드 순서대로 쌓임)
        3. `z-index` 값이 있는 `position` 요소 (`z-index` 값이 높을수록 위에 쌓임)

* **문법 및 사용법 (How?)**:
  ```css
  .background-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 100; /* 배경은 아래에 */
  }

  .popup-modal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 101; /* 팝업은 배경보다 위에 */
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`z-index`가 동작하지 않는 가장 흔한 이유는 해당 요소에 `position` 속성(`relative`, `absolute` 등)이 없기 때문이다.** 두 속성은 항상 함께 고려해야 한다.
    * `z-index`는 부모가 다른 '쌓임 맥락(Stacking Context)'을 가질 경우, 부모의 `z-index`를 넘어설 수 없다. 무작정 큰 숫자를 주는 것보다 HTML 구조와 `position`을
      함께 고려하는 것이 중요하다.

---

### 5. CSS와 JavaScript의 역할 분담

웹 애플리케이션을 만들 때 CSS와 JavaScript의 역할을 명확히 구분하는 원칙을 학습했다.

* **학습 목표 (Why?)**:
  관심사 분리(Separation of Concerns) 원칙에 따라, 코드의 가독성, 유지보수성, 성능을 향상시키기 위함이다.

* **핵심 원리 (What?)**:

  | 구분 | 역할 | 주 담당 |
    | :--- | :--- | :--- |
  | **구조 (Structure)** | 콘텐츠의 의미와 뼈대 | HTML |
  | **표현 (Presentation)**| 레이아웃, 디자인, 애니메이션 | **CSS** |
  | **동작 (Behavior)** | 사용자 상호작용, 데이터 처리, 상태 변화 | **JavaScript** |

* **실무 Best Practice**:
  JavaScript는 요소의 스타일을 직접 제어(`element.style.color = 'red'`)하기보다, 미리 정의된 CSS 클래스를 추가하거나 제거(
  `element.classList.add('is-active')`)하는 방식으로 상태를 변경하는 것이 좋다.
    * **CSS**: `.modal { display: none; } .modal.is-active { display: block; }`
    * **JavaScript**: `modalElement.classList.add('is-active');` // 모달을 보여줌
    * 이렇게 하면 스타일의 구체적인 내용은 CSS 파일에 위임되고, JavaScript는 '언제' 보여줄지만 결정하므로 역할이 명확해진다.

---

## 오늘의 깨달음 💡

* '레이아웃은 CSS로, 동작은 JavaScript로'라는 원칙은 단순히 코드를 분리하는 것을 넘어, 웹의 구조를 더 견고하고 효율적으로 만드는 핵심 철학임을 이해했다.

* CSS `position` 속성은 요소의 좌표를 바꾸는 것을 넘어, 해당 요소가 문서 흐름(document flow)에 어떻게 참여할지를 결정하는 근본적인 규칙임을 이해했다. `absolute`를 사용하는 순간,
  그 요소는 다른 요소들과 다른 차원에서 존재하게 된다.

* `z-index`가 효과를 발휘하려면 반드시 `position` 속성이 `static`이 아니어야 한다는 전제 조건을 명확히 알게 되었다. 두 속성은 하나의 세트로 동작하며, 이 관계를 이해하는 것이 레이어드
  UI 디버깅의 시작이다.