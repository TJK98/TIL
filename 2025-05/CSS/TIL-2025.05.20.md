# TIL - 2025.05.20 - CSS 박스 모델, display 속성 및 단위 개념 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #BoxModel #Display #CSSUnits #Viewport

---

## 오늘 배운 내용 🔍

- 뷰포트 기준 상대 단위 `vw`, `vh`의 개념과 활용법
- 다양한 CSS 단위(`px`, `%`, `em`, `rem`, `vw`, `vh`)의 기준점과 특징 비교
- 텍스트 및 폰트 스타일링을 위한 다양한 CSS 속성
- CSS 박스 모델(Box Model)의 4가지 구성 요소와 `box-sizing` 속성
- 요소의 배치 방식을 결정하는 `display` 속성 (`block`, `inline`, `inline-block`)
- 콘텐츠 넘침을 제어하는 `overflow` 속성
- 요소의 가시성을 제어하는 `display`, `visibility`, `opacity` 속성의 차이점

---

## 어려웠던 점 💣

* `%`, `em`, `rem`, `vw` 등 여러 상대 단위들의 기준점이 각각 달라 혼란스러웠다. 특히 `width: 50%`는 부모 요소의 너비를 기준으로 하고, `width: 50vw`는 브라우저 화면(
  뷰포트)의 너비를 기준으로 한다는 차이를 명확히 구분하는 것이 중요했다.

* `padding`과 `margin` 모두 여백을 만드는 속성이지만, 언제 어떤 것을 사용해야 하는지 명확한 기준을 세우기 어려웠다. `padding`은 요소의 내부 여백으로 요소 자체의 크기에 영향을 주고,
  `margin`은 요소의 외부 여백으로 다른 요소와의 간격을 조절한다는 근본적인 역할 차이를 이해해야 했다.

* 마진 병합(Margin Collapsing) 현상 때문에 예상과 다른 레이아웃 결과가 나왔다. 위쪽 박스의 `margin-bottom`과 아래쪽 박스의 `margin-top`이 만나면 더 큰 값 하나만 적용되는
  현상을 인지하지 못해 디버깅에 어려움을 겪었다.

* `display: inline-block`으로 지정된 요소들 사이에 의도치 않은 작은 공백이 생기는 문제가 발생했다. 이는 HTML 코드상의 줄바꿈이나 공백이 실제 화면에 공백 문자로 렌더링되기 때문이라는 것을
  알게 되었다.

---

## 정리 🖇️

### 1. CSS 단위 (Units)의 이해와 비교

요소의 크기, 글자 크기 등을 지정하는 다양한 단위의 특징과 사용 목적을 학습했다.

* **학습 목표 (Why?)**:
  다양한 화면 크기와 해상도에 유연하게 대응하는 반응형 웹 디자인을 구현하고, 유지보수가 용이한 스타일 시트를 작성하기 위함이다.

* **핵심 원리 (What?)**:
  CSS 단위는 기준 대상에 따라 절대 단위와 상대 단위로 나뉜다.
  | 단위 | 기준 대상 | 주요 사용 위치 | 설명 | 반응형 |
  | :--- | :--- | :--- | :--- | :--- |
  | `px` | 고정값 (절대 단위) | 모든 속성 | 화면의 픽셀 수. 항상 고정된 크기를 가짐. | ❌ |
  | `%` | 부모 요소의 크기 | `width`, `height` 등 | 부모 요소의 크기를 기준으로 한 백분율. | 🔺 |
  | `em` | 부모/자기자신 폰트 크기 | `font-size`, `padding` 등 | 부모(`font-size`) 또는 자기자신(`padding` 등)의 폰트 크기를 기준으로 한 배수. | 🔺 |
  | `rem`| **루트 요소(`html`)** 폰트 크기 | 모든 속성 | `html`의 폰트 크기를 기준으로 한 배수. 일관성 유지에 유리. | ✅ |
  | `vw` | **뷰포트(화면) 너비** | `width`, `font-size` 등 | 브라우저 화면 너비의 1/100. | ✅ |
  | `vh` | **뷰포트(화면) 높이** | `height` 등 | 브라우저 화면 높이의 1/100. | ✅ |

* **문법 및 사용법 (How?)**:
  ```css
  html {
    /* rem 단위의 기준이 되는 폰트 크기 */
    font-size: 16px;
  }

  .container {
    width: 80%; /* 부모 너비의 80% */
    font-size: 1.2em; /* 부모 폰트 크기의 1.2배 */
  }

  .title {
    font-size: 2rem; /* html 폰트 크기(16px)의 2배 = 32px */
  }

  .fullscreen-banner {
    width: 100vw; /* 화면 너비와 동일하게 */
    height: 100vh; /* 화면 높이와 동일하게 */
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`rem` vs `vw`**: `rem`은 폰트 크기를 기준으로 하므로 주로 텍스트, 간격 등 UI 요소 크기에 사용되어 접근성을 높인다. 반면 `vw`와 `vh`는 화면 크기 자체를 기준으로 하므로,
      전체 섹션의 높이나 너비를 화면에 꽉 채우는 등 레이아웃 구성에 주로 사용된다.
    * `%` 단위를 `height` 속성에 사용할 때, 부모 요소에 명시적인 `height` 값이 없으면 자식의 `height`는 계산되지 않아 0이 될 수 있다.
    * `em` 단위는 요소가 중첩될수록 `1.2em * 1.2em = 1.44em` 과 같이 계산이 복잡해지므로, 전역적인 크기 조절에는 `rem`을 사용하는 것이 훨씬 예측 가능하고 편리하다.

---

### 2. 텍스트 및 폰트 스타일링

문서의 가독성과 시각적 계층을 설정하기 위한 다양한 텍스트 관련 속성을 학습했다.

* **학습 목표 (Why?)**:
  웹 페이지의 텍스트 콘텐츠를 명확하고 아름답게 표현하여 사용자에게 정보를 효과적으로 전달하기 위함이다.

* **핵심 원리 (What?)**:
  텍스트 스타일링 속성은 글꼴 자체를 제어하는 `font-` 계열과, 텍스트의 정렬, 간격, 장식 등을 제어하는 `text-` 계열 등으로 나뉜다.
  | 속성 | 설명 |
  | :--- | :--- |
  | `font-family` | 글꼴 지정 (e.g., `"Arial", sans-serif`) |
  | `font-size` | 글자 크기 |
  | `font-weight` | 글자 굵기 (e.g., `bold`, `400`, `700`) |
  | `font-style` | 글자 스타일 (e.g., `italic`) |
  | `color` | 글자 색상 |
  | `text-align` | 텍스트 수평 정렬 (e.g., `left`, `center`, `right`) |
  | `line-height` | 줄 높이 (행간). 글자 크기의 1.5~1.6배 정도가 가독성에 좋음. |
  | `text-decoration` | 텍스트 장식 (e.g., `underline`, `line-through`) |
  | `text-transform`| 텍스트 대소문자 변환 (e.g., `uppercase`, `lowercase`) |

---

### 3. 박스 모델 (Box Model)

모든 HTML 요소가 화면에서 공간을 차지하는 방식에 대한 핵심 원리를 학습했다.

* **학습 목표 (Why?)**:
  웹 페이지의 모든 요소는 사각형의 '박스'로 렌더링된다. 이 박스의 크기와 여백을 정확히 제어하여 의도한 레이아웃을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  CSS 박스 모델은 4개의 영역으로 구성된다.
    * **`content`**: 텍스트나 이미지가 표시되는 실제 내용 영역.
    * **`padding`**: `content`와 `border` 사이의 **내부 여백**.
    * **`border`**: `padding`을 감싸는 테두리.
    * **`margin`**: `border` 바깥의 **외부 여백**. 다른 요소와의 간격을 조절.
      | 구분 | 마진 (`margin`) | 패딩 (`padding`) |
      | :--- | :--- | :--- |
      | **위치** | 요소 **바깥**의 여백 | 요소 **안쪽**의 여백 |
      | **역할** | 다른 요소와의 간격 조절 | 콘텐츠와 테두리 사이의 간격 조절 |
      | **배경 적용**| 적용되지 않음 (투명) | 적용됨 |
      | **상쇄 현상**| 수직 방향에서 상쇄(Collapse) 발생 가능 | 상쇄 현상 없음 |

* **문법 및 사용법 (How?)**:
  ```css
  .box {
    width: 200px;
    /* 단축 속성: 상하 10px, 좌우 20px */
    padding: 10px 20px;
    /* 단축 속성: 두께 1px, 실선, 검정색 */
    border: 1px solid black;
    margin: 15px;
  }

  /* width가 지정된 블록 요소를 수평 중앙 정렬하는 공식 */
  .center-box {
    width: 500px;
    margin: 0 auto; /* 상하 0, 좌우 auto */
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`padding` vs. `margin`**: `padding`은 "박스 안쪽으로 살을 찌우는 것"이고, `margin`은 "박스 바깥쪽으로 거리를 두는 것"이다. 요소에 배경색이 있을 때,
      `padding` 영역은 배경색이 칠해지지만 `margin` 영역은 투명하다.
    * **마진 병합 (Margin Collapsing)**: 수직으로 인접한 두 블록 요소의 `margin`이 만나면, 둘 중 더 큰 값의 `margin` 하나만 적용된다. (e.g., 위 요소의
      `margin-bottom: 20px`와 아래 요소의 `margin-top: 30px`이 만나면 간격은 50px가 아닌 30px가 됨)

---

### 4. 레이아웃 제어: `box-sizing`과 `display`

요소의 크기 계산 방식과 배치 방식을 제어하는 핵심 속성들을 학습했다.

* **학습 목표 (Why?)**:
  예측 가능한 크기 계산으로 레이아웃 설계를 단순화하고(`box-sizing`), 요소의 성격(줄바꿈 여부, 크기 지정 가능 여부 등)을 제어하여 원하는 레이아웃 구조를 만들기 위함이다.

* **핵심 원리 (What?)**:
    * **`box-sizing`**: 요소의 너비(`width`)와 높이(`height`)를 계산하는 기준을 바꾼다.
      | 값 | `width`/`height`의 계산 범위 |
      | :--- | :--- |
      | `content-box` (기본값) | `content` 영역만 포함. `padding`과 `border`가 추가되면 전체 크기가 커짐. |
      | `border-box` | `content` + `padding` + `border` 모두 포함. `padding`을 추가해도 전체 크기 고정. |

    * **`display`**: 요소의 외부(배치) 및 내부(자식 요소) 표시 유형을 설정한다.
      | 값 | 특징 | 너비/높이 | 상하 마진/패딩 |
      | :--- | :--- | :--- | :--- |
      | `block` | 한 줄 전체를 차지 (줄바꿈 발생) | O | O |
      | `inline` | 콘텐츠 너비만큼만 차지 (줄바꿈 없음) | X | X |
      | `inline-block` | `inline`처럼 배치되지만 `block`처럼 크기/여백 제어 가능 | O | O |

* **문법 및 사용법 (How?)**:
  ```css
  /* 실무 표준 CSS 초기화 설정 */
  * {
    box-sizing: border-box;
  }

  .box {
    width: 200px; /* 이제 이 너비는 padding과 border를 포함한 최종 너비 */
    padding: 20px;
  }

  a.button-style {
    /* inline 요소인 a를 inline-block으로 변경하여 크기와 여백을 줌 */
    display: inline-block;
    padding: 10px 15px;
    background-color: blue;
    color: white;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 예측 가능한 레이아웃 설계를 위해, CSS 초기화 코드에 모든 요소에 `box-sizing: border-box`를 적용하는 것이 현대 웹 개발의 표준이다.
    * `inline-block` 요소들 사이에 생기는 미세한 공백은 HTML 코드상의 줄바꿈이나 띄어쓰기 때문이다. 이를 해결하기 위해 부모 요소에 `font-size: 0;`을 적용하거나, HTML 태그를
      붙여 쓰는 등의 방법이 있다.

---

### 5. (추가 개념) 요소의 가시성 및 넘침 제어

요소를 화면에서 숨기거나, 내용이 넘칠 때의 처리 방식을 학습했다.
| 속성 | 설명 |
| :--- | :--- |
| `overflow: visible;` | 넘치는 내용을 그대로 표시 (기본값) |
| `overflow: hidden;` | 넘치는 내용을 잘라내어 숨김 |
| `overflow: scroll;` | 내용이 넘치지 않아도 항상 스크롤바 표시 |
| `overflow: auto;` | 내용이 넘칠 경우에만 스크롤바 표시 |
| `display: none;` | 요소를 화면에서 완전히 제거 (공간 차지 안 함) |
| `visibility: hidden;`| 요소의 공간은 유지한 채 보이지만 않게 함 |
| `opacity: 0;` | 요소를 완전히 투명하게 만듦 (공간 유지, 클릭 등 이벤트 동작) |

---

## 오늘의 깨달음 💡

* CSS 레이아웃의 핵심은 '박스'를 이해하는 것에서 시작된다는 것을 깨달았다. `width` 값을 정해도 `padding`과 `border` 때문에 전체 크기가 예상과 달라지는 경험을 통해,
  `box-sizing: border-box;`가 왜 현대 CSS의 필수적인 설정이 되었는지 체감했다.

* `display` 속성은 요소의 '본질'을 바꾸는 것과 같았다. `inline` 요소인 `<a>` 태그에 `display: block`을 부여하자, 너비와 높이를 가지는 버튼처럼 동작하는 것을 보며 CSS가
  단순히 꾸미는 것을 넘어 구조의 동작 방식까지 제어할 수 있음을 이해했다.

* 요소를 숨기는 방법이 세 가지나 있다는 사실이 놀라웠다. `display: none`은 존재 자체를 없애 레이아웃을 재배치시키는 반면, `visibility: hidden`은 자리만 차지하게 한다는 차이점을
  통해, CSS 속성 하나가 전체 페이지 구조에 미치는 영향을 신중하게 고려해야 함을 배웠다.