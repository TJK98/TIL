# TIL - 2025.05.19 - CSS 기본 문법, 선택자, 단위 및 우선순위 개념 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #Selector #Specificity #CSSUnits

---

## 오늘 배운 내용 🔍

- CSS의 역할과 HTML 구조와의 분리 원칙
- CSS 적용 방식: 인라인, 내부 스타일 시트, 외부 스타일 시트
- 기본 선택자(태그, 클래스, ID) 및 관계 선택자(자손, 자식, 형제)
- 속성 선택자(`[attr]`, `[attr^=""]`, `[attr$=""]`, `[attr*=""]`)
- 상태 및 구조에 따른 가상 클래스 선택자(`:hover`, `:nth-child(n)`)
- 스타일 충돌 시 적용 규칙을 결정하는 CSS 우선순위(Specificity)
- 절대 단위(`px`)와 상대 단위(`em`, `rem`, `%`, `vw/vh`)의 차이점과 사용법

---

## 어려웠던 점 💣

* `em`, `rem`, `%` 모두 상대 단위이지만, 각각의 크기가 결정되는 기준점이 달라 혼란스러웠다. `em`은 부모 요소의 폰트 크기, `%`는 부모 요소의 특정 속성값, `rem`은 최상위 `<html>`
  요소의 폰트 크기를 기준으로 한다는 차이점을 명확히 구분해야 했다.

* CSS 스타일의 우선순위 규칙이 복잡하게 느껴졌다. 단순히 '나중에 선언된 것이 이긴다'가 아니라, 인라인 스타일 > ID > 클래스 > 태그 순으로 정해진 '명시도(Specificity)' 점수가 있고, 이
  점수가 높은 규칙이 우선 적용된다는 개념을 이해하는 데 시간이 걸렸다.

* `:nth-child(n)` 선택자에서 `2n+1`, `-n+3` 과 같은 수식을 사용하여 특정 패턴의 요소를 선택하는 방식이 수학 공식처럼 느껴져 직관적으로 이해하기 어려웠다.

---

## 정리 🖇️

### 1. CSS의 기본 개념과 적용 방식

HTML로 정의된 구조에 시각적 스타일을 입히는 CSS의 역할과 기본 문법을 학습했다.

* **학습 목표 (Why?)**:
  웹 페이지의 내용(HTML)과 디자인(CSS)을 분리하여 코드의 유지보수성과 재사용성을 높이기 위함이다. 구조 변경 없이 디자인만 바꾸거나, 동일한 스타일을 여러 페이지에 쉽게 적용할 수 있다.

* **핵심 원리 (What?)**:
  CSS는 '선택자(Selector)'와 '선언부(Declaration)'로 구성된다. 선택자는 스타일을 적용할 대상을 지정하고, 선언부는 `{ }` 안에 `속성: 값;` 형태로 구체적인 스타일을 정의한다.
    * **인라인 스타일 (Inline Style)**: HTML 태그에 `style` 속성을 이용해 직접 작성.
    * **내부 스타일 시트 (Internal Style Sheet)**: HTML 문서의 `<head>` 안에 `<style>` 태그를 만들어 작성.
    * **외부 스타일 시트 (External Style Sheet)**: 별도의 `.css` 파일을 만들어 관리하고, HTML 문서에서 `<link>` 태그로 불러와 사용. 가장 권장되는 방식이다.

* **문법 및 사용법 (How?)**:
  ```css
  /* 기본 문법: 선택자 { 속성: 값; } */
  h1 {
    color: blue;
    font-size: 24px;
  }
  ```
  ```html
  <!-- 외부 스타일 시트 연결 -->
  <head>
    <link rel="stylesheet" href="styles.css">
  </head>
  ```

---

### 2. CSS 선택자 (Selector)

HTML 문서에서 특정 요소를 정확히 선택하여 스타일을 적용하는 다양한 방법을 학습했다.

* **학습 목표 (Why?)**:
  복잡한 HTML 구조 속에서 원하는 요소(들)만을 정교하게 찾아내어 스타일을 적용하기 위함이다. 선택자를 잘 활용하면 불필요한 `class`나 `id` 남발을 줄일 수 있다.

* **핵심 원리 (What?)**:
  다양한 유형의 선택자를 조합하여 원하는 요소를 정밀하게 타겟팅할 수 있다. `id`와 `class`의 차이점은 다음과 같다.
    * **ID**: 문서 내에서 단 한 번만 사용되는 고유한 이름. `#` 기호로 선택한다.
    * **Class**: 여러 요소에 반복적으로 적용할 수 있는 이름. `.` 기호로 선택하며, 한 요소에 공백으로 구분하여 여러 클래스를 부여할 수 있다.

* **문법 및 사용법 (How?)**:
  **1. 기본 및 관계 선택자**

  | 선택자 | 설명 | 예시 |
    | :--- | :--- | :--- |
  | `p` | 모든 `<p>` 태그를 선택 | `p { color: black; }` |
  | `.item` | `class`가 `item`인 모든 요소를 선택 | `.item { font-weight: bold; }` |
  | `#header` | `id`가 `header`인 요소를 선택 | `#header { background: #eee; }` |
  | `div p` | `<div>`의 **모든 하위(자손)** `<p>` 요소를 선택 | `div p { margin: 0; }` |
  | `div > p` | `<div>`의 **직계 자식**인 `<p>` 요소만 선택 | `div > p { padding: 10px; }` |
  | `h1 + p` | `<h1>` **바로 뒤에 인접한 형제** `<p>` 요소 하나만 선택 | `h1 + p { margin-top: 0; }` |
  | `h1 ~ p` | `<h1>` **이후에 오는 모든 형제** `<p>` 요소를 선택 | `h1 ~ p { text-decoration: underline; }` |
  | `h1, p` | 모든 `<h1>` 요소와 모든 `<p>` 요소를 함께 선택 | `h1, p { font-family: sans-serif; }` |

  **2. 속성 선택자**

  | 선택자 | 설명 | 예시                                                 |
    | :--- | :--- |:---------------------------------------------------|
  | `[disabled]` | `disabled` 속성을 가진 모든 요소를 선택 | `[disabled] { opacity: 0.5; }`                     |
  | `[type="text"]` | `type` 속성의 값이 정확히 `text`인 요소를 선택 | `input[type="text"] { border: 1px solid #ccc; }`   |
  | `[class^="btn-"]` | `class` 속성값이 `btn-`으로 **시작하는** 요소를 선택 | `[class^="btn-"] { padding: 8px; }`                |
  | `[class$="-dark"]` | `class` 속성값이 `-dark`로 **끝나는** 요소를 선택 | `[class$="-dark"] { color: white; }`               |
  | `[class*="-outline-"]` | `class` 속성값에 `-outline-`이 **포함된** 요소를 선택 | `[class*="-outline-"] { background: transparent; }`|

  **3. 가상 클래스 선택자 (Pseudo-class)**

  | 선택자 | 설명 | 예시 |
    | :--- | :--- | :--- |
  | `:hover` | 요소에 마우스를 올렸을 때 | `a:hover { color: red; }` |
  | `:focus` | 요소가 포커스를 받았을 때 (입력창 클릭 등) | `input:focus { border-color: blue; }` |
  | `:first-child` | 형제 요소 중 첫 번째 자식일 경우 선택 | `li:first-child { font-weight: bold; }` |
  | `:last-child` | 형제 요소 중 마지막 자식일 경우 선택 | `li:last-child { color: gray; }` |
  | `:nth-child(n)` | 형제 요소 중 n번째 자식일 경우 선택 | `li:nth-child(3) { background: #eee; }` |
  | `:nth-child(odd)` | 형제 요소 중 홀수 번째 자식들을 선택 | `tr:nth-child(odd) { background: #f9f9f9; }` |
  | `:nth-child(even)` | 형제 요소 중 짝수 번째 자식들을 선택 | `tr:nth-child(even) { background: #fff; }` |
  | `:nth-child(n+4)` | 4번째부터 모든 형제 자식들을 선택 | `li:nth-child(n+4) { display: none; }` |
  | `:nth-child(-n+3)`| 1번째부터 3번째까지의 형제 자식들을 선택 | `li:nth-child(-n+3) { border-left: 3px solid blue; }`|

---

### 3. CSS 우선순위 (Specificity)

하나의 요소에 여러 CSS 규칙이 동시에 적용될 때, 어떤 스타일이 최종적으로 적용될지를 결정하는 규칙을 학습했다.

* **학습 목표 (Why?)**:
  의도치 않게 스타일이 덮어씌워지거나, 원하는 스타일이 적용되지 않는 문제를 해결하고 예측 가능한 CSS 코드를 작성하기 위함이다.

* **핵심 원리 (What?)**:
  CSS는 각 선택자 규칙에 **명시도(Specificity)**라는 점수를 부여하여 우선순위를 결정한다. 점수가 높을수록 우선순위가 높다. 점수가 동일하면 나중에 선언된 규칙이 적용된다.

  | 우선순위 | 선택자 유형 | 점수 |
    | :--- | :--- | :--- |
  | **높음** | `!important` | 무한대 |
  | | 인라인 스타일 | 1000점 |
  | | ID 선택자 (`#id`) | 100점 |
  | | 클래스 (`.class`), 속성 (`[type]`), 가상 클래스 (`:hover`) | 10점 |
  | **낮음** | 태그 (`div`), 가상 요소 (`::before`) | 1점 |

* **문법 및 사용법 (How?)**:
  ```css
  /* 점수 계산 예시 */
  #main p.highlight { color: blue; } /* ID(100) + 태그(1) + 클래스(10) = 111점 */
  div.content p { color: red; }      /* 태그(1) + 클래스(10) + 태그(1) = 12점 */
  /* 결과: p 태그는 111점 규칙이 더 높아 파란색(blue)으로 적용됨 */
  ```

---

### 4. CSS 단위 (Units)

크기, 길이, 간격 등을 지정할 때 사용하는 다양한 단위를 학습했다.

* **학습 목표 (Why?)**:
  다양한 화면 크기와 기기에 유연하게 대응하는 반응형 웹 디자인을 구현하고, 유지보수가 용이한 스타일 시트를 작성하기 위함이다.

* **핵심 원리 (What?)**:
    * **절대 단위**: 다른 요소의 크기에 영향을 받지 않는 고정된 크기.
        * `px` (픽셀): 화면의 가장 작은 점 하나를 기준으로 하는 기본 단위.
    * **상대 단위**: 특정 기준에 따라 크기가 유동적으로 변함.
        * `%`: **부모 요소**의 동일한 속성값에 대한 백분율.
        * `em`: **해당 요소의 부모 요소**의 폰트 크기를 기준으로 하는 배수. 중첩 시 계산이 복잡해질 수 있다.
        * `rem` (Root em): **최상위 요소(`<html>`)**의 폰트 크기를 기준으로 하는 배수. 일관된 크기 조절에 용이하다.
        * `vw` / `vh`: **뷰포트(브라우저 화면)**의 너비/높이에 대한 백분율.

* **주의사항 및 실무 팁 (Watch out for)**:
    * 현대 웹 개발에서는 유지보수와 반응형 디자인의 이점 때문에 **`rem` 단위를 기본**으로 사용하는 것을 권장한다. 사용자가 브라우저의 기본 폰트 크기를 변경했을 때 전체 UI가 그에 맞춰 자연스럽게
      조절될 수 있어 접근성을 높인다.

---

## 오늘의 깨달음 💡

* CSS 선택자는 단순히 요소를 '선택'하는 것을 넘어, HTML 문서의 구조를 얼마나 잘 이해하고 있는지를 보여주는 척도라는 것을 깨달았다. 복잡한 선택자를 사용할수록 HTML의 부모-자식-형제 관계를 명확히
  파악해야 했다.

* CSS 우선순위(Specificity)는 CSS 코드 디버깅의 핵심 열쇠다. 스타일이 왜 적용되지 않는지 막막할 때, 명시도 점수를 계산해보면 대부분의 원인을 찾을 수 있다. `!important`는 문제를
  해결하는 가장 쉬운 방법처럼 보이지만, 실제로는 더 큰 문제를 만드는 지름길임을 명심해야 한다.

* 어떤 단위를 선택하느냐가 웹 페이지의 유연성을 결정한다. 모든 것을 `px`로 고정하는 것은 변화에 대응하기 어려운 경직된 설계를 만드는 것과 같았다. `rem`을 사용하면 전체 디자인의 일관성을 유지하면서도
  사용자의 접근성을 높일 수 있다는 점에서 매우 강력한 도구임을 이해했다.