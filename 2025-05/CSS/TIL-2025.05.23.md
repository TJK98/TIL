# TIL - 2025.05.23 - 반응형 디자인, 배경, 트랜지션 및 애니메이션 개념 이해

## 카테고리 🏷️

#TIL #CSS #Frontend #ResponsiveWeb #Animation #Transition #BoxShadow

---

## 오늘 배운 내용 🔍

- 다양한 디바이스 환경에 대응하는 반응형 웹 디자인의 개념
- 화면 크기에 따라 다른 스타일을 적용하는 미디어 쿼리(`@media`) 사용법
- 화면 크기를 기준으로 하는 뷰포트 단위(`vw`, `vh`)의 활용
- 다양한 배경 스타일링 속성 (`background-color`, `background-image`, `gradient`)
- 요소에 입체감을 더하는 그림자 효과 (`box-shadow`, `text-shadow`)
- 사용자 상호작용에 부드러운 변화를 주는 `transition`
- 시간의 흐름에 따라 복잡한 동작을 만드는 `@keyframes`와 `animation`

---

## 어려웠던 점 💣

* 반응형 디자인 시, 모바일 화면에서 버튼이나 검색창 같은 UI 요소의 시각적 순서를 변경해야 할 때 어떤 접근 방식이 가장 효율적인지 판단하기 어려웠다. HTML 구조를 바꾸지 않으면서 순서를 제어하는 방법을
  고민해야 했다.

* 다양한 화면 크기에 유연하게 대응하기 위한 텍스트와 요소의 크기 단위 선택이 혼란스러웠다. `px`은 고정적이어서 한계가 명확했고, `rem`, `%`, `vw` 등 여러 상대 단위 중 어떤 것을 어떤 상황에
  사용해야 최적의 결과를 얻을 수 있는지에 대한 기준이 필요했다.

---

## 정리 🖇️

### 1. 반응형 웹 디자인과 미디어 쿼리

하나의 웹사이트가 데스크톱, 태블릿, 모바일 등 다양한 디바이스의 화면 크기에 맞춰 최적의 레이아웃을 제공하도록 만드는 기술을 학습했다.

* **학습 목표 (Why?)**:
  사용자가 어떤 기기로 접속하든 일관되고 편리한 사용자 경험을 제공하기 위함이다. 별도의 모바일용 사이트를 만들 필요 없이, 하나의 소스 코드로 모든 환경에 대응하여 개발 및 유지보수 효율을 높일 수 있다.

* **핵심 원리 (What?)**:
  반응형 웹 디자인의 핵심 기술은 **미디어 쿼리(`@media`)**다. 미디어 쿼리는 접속한 디바이스의 화면 너비(width), 높이(height), 방향(orientation) 등의 조건을 감지하여, 해당
  조건에 부합할 때만 특정 CSS 스타일을 적용하도록 만든다.

  | 조건 | 설명 |
      | :--- | :--- |
  | `max-width` | 지정한 너비 **이하일 때** 스타일 적용 (주로 모바일 우선 접근 방식에서 사용) |
  | `min-width` | 지정한 너비 **이상일 때** 스타일 적용 (주로 데스크톱 우선 접근 방식에서 사용) |
  | `orientation` | 디바이스 방향 (`landscape`: 가로, `portrait`: 세로) |

* **문법 및 사용법 (How?)**:
  ```html
  <!-- HTML meta 태그 설정: 반응형 디자인의 필수 시작점 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  ```
  ```css
  /* 기본 스타일 (모바일) */
  .container {
    width: 100%;
  }

  /* 화면 너비가 768px 이상일 때 (태블릿) */
  @media (min-width: 768px) {
    .container {
      width: 750px;
      margin: 0 auto;
    }
  }

  /* 화면 너비가 1024px 이상일 때 (데스크톱) */
  @media (min-width: 1024px) {
    .container {
      width: 960px;
    }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **요소 순서 변경**: 모바일 화면에서 요소의 시각적 순서를 변경하고 싶을 때, HTML 구조를 바꾸는 대신 Flexbox 레이아웃을 사용하고 미디어 쿼리 내에서 아이템의 `order` 속성값을 변경하는
      것이 가장 효율적이고 유연한 방법이다.
    * **반응형 단위 선택**:
        * **길이/너비**: `px` 대신 `%`, `vw` 등 상대 단위를 사용하여 부모 요소나 화면 크기에 따라 유동적으로 변하게 하는 것이 좋다.
        * **폰트 크기**: `px` 대신 `rem` 단위를 사용하면 사용자의 브라우저 폰트 크기 설정에 반응하여 접근성을 높일 수 있다. 최신 기법으로는 `clamp()` 함수를 사용하여 최소-최대 폰트
          크기를 지정하는 방식도 많이 사용된다.

---

### 2. 배경(Background)과 그림자(Shadow)

요소의 배경을 꾸미고 입체감을 부여하여 시각적 완성도를 높이는 속성들을 학습했다.

* **학습 목표 (Why?)**:
  단순한 단색 배경을 넘어 이미지, 그라디언트 등 다채로운 배경을 구현하고, 그림자 효과를 통해 요소가 페이지로부터 떠 있는 듯한 깊이감을 표현하기 위함이다.

* **핵심 원리 (What?)**:
    * **`background`**: 색상, 이미지, 반복, 위치, 크기 등 배경에 관련된 여러 속성을 한번에 지정할 수 있는 단축 속성이다.
    * **`box-shadow`**: 요소의 사각형 박스에 그림자를 만든다. `x-offset y-offset blur spread color` 순서로 값을 지정하며, `inset` 키워드를 추가하면 내부
      그림자를 만들 수 있다.
    * **`text-shadow`**: 텍스트에 그림자 효과를 적용한다.

      | `background` 관련 주요 속성 | 설명 |
              | :--- | :--- |
      | `background-image` | 배경 이미지 설정 (`url()`, `linear-gradient()`, `radial-gradient()`) |
      | `background-size` | 배경 이미지 크기 조절 (`cover`: 꽉 채우기, `contain`: 이미지 전체 보이기) |
      | `background-position` | 배경 이미지 위치 지정 (`center`, `top left` 등) |
      | `background-repeat` | 이미지 반복 여부 설정 (`no-repeat`, `repeat-x` 등) |

* **문법 및 사용법 (How?)**:
  ```css
  .hero-section {
    /* background 단축 속성: 이미지, 반복 없음, 중앙 정렬, 꽉 채우기 */
    background: url("hero.jpg") no-repeat center/cover;
  }

  .card {
    /* x축 0, y축 4px, 블러 8px, 퍼짐 0, 색상 rgba(0,0,0,0.1) */
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1);
  }

  .title {
    text-shadow: 2px 2px 4px grey;
  }
  ```

---

### 3. 트랜지션(Transition)과 변형(Transform)

사용자의 상호작용(hover 등)에 반응하여 요소의 스타일이 부드럽게 변하는 효과를 학습했다.

* **학습 목표 (Why?)**:
  상태 변화가 딱딱하게 즉시 일어나는 대신, 중간 과정을 애니메이션으로 보여줌으로써 사용자에게 더 자연스럽고 직관적인 인터랙션을 제공하기 위함이다.

* **핵심 원리 (What?)**:
    * **`transition`**: 특정 CSS 속성이 변경될 때, 그 변화가 지정된 시간(`duration`) 동안 부드럽게 일어나도록 만든다.
    * **`transform`**: 요소의 모양을 변형시킨다. 이동(`translate`), 회전(`rotate`), 크기 조절(`scale`), 기울임(`skew`) 등의 기능을 제공한다.

      | `transition` 속성 | 설명 |
              | :--- | :--- |
      | `transition-property` | 효과를 적용할 CSS 속성 이름 (e.g., `width`, `all`) |
      | `transition-duration` | 효과가 지속되는 시간 (e.g., `0.3s`) |
      | `transition-timing-function`| 속도 곡선 (`ease`, `linear`, `ease-in-out` 등) |
      | `transition-delay` | 효과가 시작되기까지의 대기 시간 (e.g., `0.1s`) |

* **문법 및 사용법 (How?)**:
  ```css
  .button {
    background-color: blue;
    /* background-color 속성이 0.3초 동안 ease-in-out 속도로 변하도록 설정 */
    transition: background-color 0.3s ease-in-out;
  }

  .button:hover {
    background-color: navy;
    /* 마우스를 올리면 1.1배 커지는 효과 */
    transform: scale(1.1);
  }
  ```

---

### 4. 애니메이션(Animation)과 `@keyframes`

시간의 흐름에 따라 여러 단계의 스타일 변화를 자동으로 실행하는 복잡한 애니메이션을 학습했다.

* **학습 목표 (Why?)**:
  사용자의 특정 행동 없이도 로딩 스피너, 자동 슬라이드 쇼, 주목을 끄는 효과 등 동적인 시각 효과를 구현하기 위함이다.

* **핵심 원리 (What?)**:
  CSS 애니메이션은 두 부분으로 구성된다.
    1. **`@keyframes`**: 애니메이션의 각 시점(0%부터 100%까지, 또는 `from`에서 `to`까지)에 요소가 어떤 스타일을 가져야 하는지 정의하는 규칙.
    2. **`animation`**: `@keyframes`에서 정의한 애니메이션을 어떤 요소에, 얼마 동안, 어떻게 적용할지 설정하는 속성.
    
       | `animation` 속성 | 설명 |
               | :--- | :--- |
       | `animation-name` | 적용할 `@keyframes` 이름 |
       | `animation-duration`| 한 사이클의 지속 시간 |
       | `animation-iteration-count`| 반복 횟수 (`infinite`로 무한 반복 가능) |
       | `animation-direction`| 반복 시 방향 (`alternate`: 정방향-역방향 반복) |

* **문법 및 사용법 (How?)**:
  ```css
  /* 1. 애니메이션 정의 */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* 2. 요소에 애니메이션 적용 */
  .fade-in-element {
    /* fadeIn 애니메이션을 1초 동안 ease-out 속도로 실행 */
    animation: fadeIn 1s ease-out;
  }
  ```

---

## 오늘의 깨달음 💡

* 반응형 디자인의 핵심은 단순히 화면 크기에 따라 레이아웃을 바꾸는 것이 아니라, **HTML 구조는 그대로 유지한 채 CSS를 통해 시각적 표현(순서, 크기, 가시성 등)을 전략적으로 제어**하는 것임을
  깨달았다. `order` 속성과 미디어 쿼리의 조합은 이 원칙을 실현하는 강력한 도구다.

* 어떤 단위를 선택하느냐가 반응형 디자인의 성패를 좌우한다. `px`은 절대적인 기준을 제공하지만 유연성이 떨어지고, `%`, `rem`, `vw`와 같은 상대 단위들은 각각 다른 기준(부모, 루트, 뷰포트)을
  가지므로, 만들고자 하는 UI의 맥락에 맞게 전략적으로 조합하여 사용하는 지혜가 필요하다.

* `transition`은 **상태 A에서 상태 B로의 단일 변화**를 부드럽게 만드는 데 특화되어 있고, `animation`은 **시간의 흐름에 따른 복잡하고 다단계적인 시나리오**를 만드는 데 특화되어 있다는
  명확한 역할 차이를 이해했다. 목적에 맞는 도구를 선택하는 것이 중요하다.