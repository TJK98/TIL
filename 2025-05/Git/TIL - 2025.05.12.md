# TIL - 2025.05.12 - Git 병합, 충돌 해결 및 작업 관리 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Merge #Conflict #Stash #Diff

---

## 오늘 배운 내용 🔍

- 브랜치를 병합하는 두 가지 방식: Fast-forward와 3-way Merge
- 병합 시 발생하는 충돌(Conflict)의 원인과 해결 과정
- 파일의 변경사항을 비교하는 `git diff` 명령어의 다양한 사용법
- 작업 내용을 임시로 저장하는 `git stash` 명령어 활용
- 변경사항을 되돌리는 `git restore` 명령어의 역할
- 브랜치가 아닌 특정 커밋을 가리키는 `Detached HEAD` 상태의 이해

---

## 어려웠던 점 💣

* 의도적으로 3-way Merge 상황을 만드는 것이 어려웠다. `main` 브랜치에 추가적인 커밋을 만들지 않은 상태에서 병합을 시도하여, 계속해서 Fast-forward Merge가 발생하는 실수를 했다. 두
  브랜치의 역사가 갈라져야만 3-way Merge가 일어난다는 조건을 명확히 이해해야 했다.

* `git stash`는 단일 브랜치 내에서는 직관적이었지만, A 브랜치에서 작업 내용을 `stash`한 후 B 브랜치로 이동하여 `pop`하는 등 여러 브랜치를 오가는 상황에서는 어떤 변경사항이 어디에 적용되는지
  흐름을 추적하기가 다소 헷갈렸다.

---

## 정리 🖇️

### 1. 브랜치 병합 (Merge)

분리된 작업 흐름(브랜치)을 하나의 브랜치로 통합하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  기능 개발이 완료된 브랜치의 작업 내용을 `main`과 같은 주축 브랜치에 반영하여, 프로젝트에 새로운 기능을 통합하기 위함이다.

* **핵심 원리 (What?)**:
  병합 방식은 브랜치의 분기 상태에 따라 두 가지로 나뉜다.
    * **Fast-forward Merge**: 병합할 브랜치가 대상 브랜치의 최신 커밋에서 그대로 이어지는 '직선' 역사일 경우 발생한다. 별도의 병합 커밋 없이, 대상 브랜치의 포인터를 병합할 브랜치의 최신
      커밋으로 **단순히 이동**시킨다.
    * **3-way Merge**: 대상 브랜치와 병합할 브랜치가 공통 조상 커밋 이후 각자의 길을 간, 즉 역사가 '분기'되었을 때 발생한다. Git은 **두 브랜치의 공통 조상, 그리고 각 브랜치의 최신
      커밋(총 3개)을 비교**하여 변경사항을 합치고, 그 결과를 담은 **새로운 병합 커밋(Merge Commit)**을 생성한다.

* **문법 및 사용법 (How?)**:
  ```bash
  # 1. main 브랜치로 이동
  git switch main

  # 2. feature 브랜치의 내용을 main 브랜치로 병합
  git merge feature
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * Fast-forward를 막고 의도적으로 병합 커밋을 남기고 싶다면 `git merge --no-ff <브랜치명>` 옵션을 사용한다. 이는 특정 기능이 언제 병합되었는지 기록을 명확히 남기는 데 도움이
      된다.

---

### 2. 병합 충돌 (Merge Conflict)

두 개의 브랜치에서 같은 파일의 같은 부분을 수정했을 때 발생하는 충돌을 해결하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  여러 사람이 동시에 같은 파일을 작업할 때 발생할 수 있는 코드 충돌 상황을 이해하고, Git이 자동으로 해결할 수 없는 부분을 개발자가 직접 수정하여 병합을 안전하게 완료하기 위함이다.

* **핵심 원리 (What?)**:
  충돌이 발생하면 Git은 병합을 잠시 멈추고, 충돌이 발생한 파일 내부에 **충돌 표시기(Conflict Marker)**를 생성한다.
  ```
  <<<<<<< HEAD
  (현재 브랜치의 코드 내용)
  =======
  (병합하려는 브랜치의 코드 내용)
  >>>>>>> feature
  ```
  `HEAD`는 현재 브랜치(`main`)의 코드를, `feature`는 병합하려는 브랜치의 코드를 의미한다.

* **문법 및 사용법 (How?)**:
    1. 충돌이 발생한 파일을 열어 충돌 표시기(`<<<`, `===`, `>>>`)를 제거하고, 두 코드 중 어떤 것을 남길지, 혹은 어떻게 합칠지 직접 수정한다.
    2. 수정이 완료된 파일을 `git add` 명령어로 스테이징 영역에 추가한다. 이는 Git에게 "충돌을 모두 해결했음"을 알리는 신호다.
    3. `git commit`을 실행하여 병합을 마무리하는 새로운 커밋을 생성한다. (커밋 메시지는 자동으로 작성된다.)

* **주의사항 및 실무 팁 (Watch out for)**:
    * 충돌 해결 과정이 복잡하게 꼬였다면, `git merge --abort` 명령어를 사용하여 병합 시도 자체를 취소하고 이전 상태로 안전하게 돌아갈 수 있다.

---

### 3. 작업 임시 저장 (git stash)

아직 커밋하기 애매한 작업들을 임시로 저장하고, 작업 디렉터리를 깨끗한 상태로 되돌리는 방법을 학습했다.

* **학습 목표 (Why?)**:
  현재 브랜치에서 작업을 완료하지 않았는데, 다른 브랜치로 급하게 전환하여 다른 일을 해야 할 때 사용한다. 커밋 없이 작업 내용을 안전하게 보관하고 다른 작업을 처리한 뒤, 다시 원래 작업으로 돌아올 수 있다.

* **핵심 원리 (What?)**:
  `git stash`는 현재 작업 디렉터리와 스테이징 영역의 변경사항을 '스택(Stack)' 구조에 임시로 저장한다. 나중에 `pop`이나 `apply`를 통해 다시 꺼내어 적용할 수 있다.

* **문법 및 사용법 (How?)**:
  ```bash
  # 현재 변경사항을 stash에 저장
  git stash

  # (다른 브랜치로 이동하여 다른 작업 수행)

  # 가장 최근에 저장한 stash를 꺼내와 적용하고, stash 목록에서 제거
  git stash pop

  # stash를 적용하되, 목록에는 남겨둠
  git stash apply
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 기본적으로 `git stash`는 Git이 추적 중인(tracked) 파일의 변경사항만 저장한다. 새로 생성한 파일(untracked)까지 함께 저장하려면 `git stash -u` 또는
      `git stash --include-untracked` 옵션을 사용해야 한다.

---

### 4. 기타 주요 명령어 (diff, restore, Detached HEAD)

* **`git diff`**:
    * **학습 목표 (Why?)**: 커밋하기 전 변경사항을 다시 한번 검토하거나, 브랜치 간의 차이점을 한눈에 파악하기 위해 사용한다.
    * **핵심 원리 (What?)**:
        * `git diff`: Working Directory ↔ Staging Area 비교 (스테이징되지 않은 변경사항 확인)
        * `git diff --staged`: Staging Area ↔ 최신 커밋(HEAD) 비교 (커밋될 변경사항 미리보기)
        * `git diff <브랜치1>..<브랜치2>`: 두 브랜치 간의 최종 결과물 차이 비교

* **`git restore`**:
    * **학습 목표 (Why?)**: 실수로 변경한 파일 내용을 되돌리거나, `git add`한 파일을 스테이징에서 내리기 위해 사용한다.
    * **핵심 원리 (What?)**:
        * `git restore <파일명>`: Working Directory의 변경사항을 최신 커밋 상태로 되돌린다. (수정 내용 폐기)
        * `git restore --staged <파일명>`: Staging Area에 있던 파일을 다시 Working Directory로 내린다. (`add` 취소)

* **`Detached HEAD`**:
    * **학습 목표 (Why?)**: 과거의 특정 커밋 시점으로 프로젝트 상태를 되돌려 코드를 확인하거나 테스트해보기 위해 필요하다.
    * **핵심 원리 (What?)**: `HEAD` 포인터가 브랜치 이름이 아닌, 특정 커밋의 해시(ID) 값을 직접 가리키는 상태. 이 상태에서 새로운 커밋을 만들면, 해당 커밋은 어떤 브랜치에도 속하지
      않은 '유령 커밋'이 되어 나중에 유실될 수 있다.
    * **주의사항 (Watch out for)**: `Detached HEAD` 상태에서 작업한 내용을 저장하고 싶다면, 반드시 `git switch -c <새 브랜치명>` 명령어로 새로운 브랜치를 생성하여
      해당 커밋을 가리키도록 해야 한다.

---

## 오늘의 깨달음 💡

* Git은 단순히 코드를 기록하는 도구를 넘어, 작업 흐름과 충돌을 관리하는 협업의 규칙이자 소통 도구임을 체감했다.

* 병합 충돌은 피해야 할 '문제'가 아니라, 여러 개발자의 작업이 합쳐지는 과정에서 발생하는 자연스러운 '조율' 과정의 일부로 인식하게 되었다.

* `HEAD`가 항상 브랜치를 가리키는 것이 아니라는 `Detached HEAD` 개념을 통해, Git의 내부 포인터 시스템을 더 깊게 이해하는 계기가 되었다. Git의 동작이 더 이상 마법이 아닌, 예측 가능한
  원리에 따라 움직인다는 것을 알게 되었다.