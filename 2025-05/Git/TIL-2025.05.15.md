# TIL - 2025.05.15 - Git 고급 명령어(Rebase, Cherry-Pick)와 버전 관리 전략 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Rebase #CherryPick #Reflog #Tag #SemanticVersioning

---

## 오늘 배운 내용 🔍

- Git Merge와 Rebase의 개념, 작동 방식, 장단점 비교
- 대화형으로 커밋을 수정하는 `git rebase -i` (squash, reword, drop 등)
- 특정 커밋만 선택적으로 가져오는 `git cherry-pick`의 용도와 주의사항
- 프로젝트의 중요 버전을 표시하는 `git tag`와 Semantic Versioning 규칙
- 삭제된 커밋도 복구할 수 있는 안전장치 `git reflog`
- 자주 사용하는 명령어를 단축하는 `git alias` 설정 방법

---

## 어려웠던 점 💣

* `git rebase` 중 충돌을 해결한 뒤, 습관적으로 `git commit`을 시도하게 되었다. `rebase`가 내부적으로 커밋을 재작성하는 과정이므로, 사용자는 충돌 해결 후 `add`까지만 하고
  `rebase --continue`로 제어권을 넘겨야 한다는 흐름이 직관적으로 와닿지 않았다.

* `cherry-pick`의 필요성에 대해 깊은 의문이 들었다. 특정 커밋 하나만 병합하고 싶을 때, 해당 커밋에서 새 브랜치를 만들어 `merge`해도 동일한 결과를 얻을 수 있었기 때문이다.
  `cherry-pick`만이 가지는 고유한 장점과 명확한 사용 목적을 구분하는 것이 어려웠다.

---

## 정리 🖇️

### 1. 커밋 히스토리 재구성: `rebase` vs. `merge`

분기된 브랜치의 작업 내역을 통합하는 두 가지 다른 접근 방식을 학습했다.

| 항목       | git rebase             | git merge              |
|:---------|:-----------------------|:-----------------------|
| **목적**   | 커밋 히스토리를 선형으로 정리       | 브랜치의 작업 내역을 통합         |
| **방식**   | 각 커밋을 대상 브랜치 위로 재적용    | 공통 조상을 기준으로 3-way 병합   |
| **결과**   | 깔끔한 선형 히스토리 (병합 커밋 없음) | 병합 커밋(Merge commit) 생성 |
| **히스토리** | 브랜치의 분기 흔적이 사라짐        | 브랜치 구조가 그대로 유지됨        |
| **주의점**  | 공유된 브랜치에서 사용 시 큰 문제 발생 | 상대적으로 안전함              |

---

### 2. 커밋 골라내기: `cherry-pick`

다른 브랜치에 있는 특정 커밋 하나(또는 여러 개)만 현재 브랜치로 가져오는 방법을 학습했다.

| 항목        | git cherry-pick       | git merge           |
|:----------|:----------------------|:--------------------|
| **대상**    | 특정 커밋 1개 또는 여러 개      | 브랜치 전체              |
| **커밋 ID** | 원본 커밋을 복사한 새 커밋 ID 생성 | 기존 커밋 ID 유지         |
| **사용 목적** | 기능의 일부만 긴급하게 가져올 때    | 기능 전체를 통합할 때        |
| **주의점**   | 커밋 간 의존성 문제 발생 가능     | 브랜치 단위로 관리되어 의존성 안전 |

---

### 3. 대화형 리베이스: `rebase -i`

커밋 히스토리를 단순히 옮기는 것을 넘어, 커밋을 합치거나 메시지를 수정하는 등 세밀하게 편집하는 방법을 학습했다.

| 키워드      | 설명                                           |
|:---------|:---------------------------------------------|
| `pick`   | 해당 커밋을 그대로 사용                                |
| `reword` | 커밋 내용은 유지하고, 메시지만 수정                         |
| `squash` | 이전 커밋과 하나로 합치고, 두 커밋의 메시지도 합쳐서 편집            |
| `fixup`  | `squash`와 같지만, 이 커밋의 메시지는 버리고 이전 커밋의 메시지만 사용 |
| `drop`   | 해당 커밋을 히스토리에서 완전히 삭제                         |

---

### 4. 버전 명시와 복구 (`tag`, `reflog`)

프로젝트의 중요 시점을 기록하고, 실수로 삭제된 작업을 복구하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  배포 버전 등 중요한 이정표를 명시적으로 표시하고, `reset --hard`와 같은 위험한 명령어로 유실된 작업을 복구할 수 있는 안전장치를 마련하기 위함이다.

* **핵심 원리 (What?)**:
    * **`git tag`**: `v1.0.0`과 같이 특정 커밋에 이름표를 붙이는 기능. Semantic Versioning(Major.Minor.Patch) 규칙에 따라 버전을 관리하는 것이 일반적이다.
    * **`git reflog`**: `HEAD` 포인터가 이동했던 모든 기록. 브랜치에서 삭제된 커밋이라도 `reflog`에는 `HEAD@{n}` 형태로 기록이 남아있어 해당 시점으로 돌아갈 수 있다.

---

### 5. 기타 유용한 도구

* **파일 생성 명령어 비교**

  | 명령어 | 기능 | 특징 |
    | :--- | :--- | :--- |
  | `touch file.txt` | 빈 파일 생성 | 즉시 생성, 내용 없음 |
  | `echo "내용" > file.txt` | 내용 덮어쓰기 | 기존 내용 삭제 후 새로 작성 |
  | `echo "내용" >> file.txt` | 내용 이어쓰기 | 기존 내용 끝에 추가 |

* **Git Alias (별칭)**

  | alias 예시 | 원본 명령어 | 주의점 |
    | :--- | :--- | :--- |
  | `st` | `git status` | - |
  | `ac` | `git add . && git commit` | 모든 변경사항(`add .`)이 포함되므로, 특정 파일만 커밋할 때는 부적합. |

---

## 오늘의 깨달음 💡

* **`rebase` 중 `commit`을 하지 않는 이유**: `rebase`는 Git이 내부적으로 커밋을 재작성하는 자동화된 과정이다. 사용자가 임의로 `commit`을 하면 이 흐름이 깨진다. 사용자의 역할은
  충돌을 해결하고 `add`로 '해결 완료' 신호를 보내는 것까지이며, 이후 과정은 `rebase --continue`로 Git에게 위임해야 한다는 것을 이해했다.

* **`cherry-pick` vs. `merge`의 본질적 차이**: 특정 커밋에서 브랜치를 만들어 `merge`하면 불필요한 브랜치와 병합 커밋이 남아 히스토리가 복잡해진다. `cherry-pick`은 **"
  나는 이 기능(커밋) 하나만 명시적으로 필요하다"**는 의도를 히스토리에 가장 깔끔하게 표현하는, 더 가볍고 명확한 도구다.