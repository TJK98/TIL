# TIL - 2025.05.15 - Git 고급 명령어(Rebase, Cherry-Pick)와 버전 관리 전략 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Rebase #CherryPick #Reflog #Tag #SemanticVersioning

---

## 오늘 배운 내용 🔍

- 커밋 히스토리 재구성: `git rebase`와 `git merge`의 차이점 및 사용 전략
- 대화형으로 커밋을 수정하는 `git rebase -i` (squash, reword, drop 등)
- 특정 커밋만 선택적으로 가져오는 `git cherry-pick`의 용도와 주의사항
- 프로젝트의 중요 버전을 표시하는 `git tag`와 Semantic Versioning 규칙
- 삭제된 커밋도 복구할 수 있는 안전장치 `git reflog`
- 자주 사용하는 명령어를 단축하는 `git alias` 설정 방법

---

## 어려웠던 점 💣

* `git rebase` 중 충돌을 해결한 뒤, 습관적으로 `git commit`을 시도하게 되었다. `rebase`가 내부적으로 커밋을 재작성하는 과정이므로, 사용자는 충돌 해결 후 `add`까지만 하고
  `rebase --continue`로 제어권을 넘겨야 한다는 흐름이 직관적으로 와닿지 않았다.

* `cherry-pick`의 필요성에 대해 깊은 의문이 들었다. 특정 커밋 하나만 병합하고 싶을 때, 해당 커밋에서 새 브랜치를 만들어 `merge`해도 동일한 결과를 얻을 수 있었기 때문이다.
  `cherry-pick`만이 가지는 고유한 장점과 명확한 사용 목적을 구분하는 것이 어려웠다.

* 내가 만든 `git ac` (`add . && commit`) 같은 alias가 편리하지만, 의도치 않게 모든 파일을 스테이징해버려 정교한 커밋이 필요할 때는 오히려 방해가 된다는 점을 깨달았다. 편의성과 유연성
  사이의 트레이드오프를 고려해야 했다.

---

## 정리 🖇️

### 1. 커밋 히스토리 재구성: `rebase` vs. `merge`

분기된 브랜치의 작업 내역을 통합하는 두 가지 다른 접근 방식을 학습했다.

* **학습 목표 (Why?)**:
  프로젝트의 커밋 히스토리를 관리하는 목적에 따라, 협업의 흔적을 그대로 남길 것인지(merge), 아니면 간결한 선형 구조로 정리할 것인지(rebase)를 선택하기 위함이다.

* **핵심 원리 (What?)**:
    * **`git merge`**: 두 브랜치의 최종 결과물을 합치고, 그 사실을 기록하는 **병합 커밋(Merge Commit)**을 생성한다. 브랜치가 어떻게 분기되고 합쳐졌는지 히스토리에 명확하게 남는다.
      **"역사를 보존하는"** 방식이다.
    * **`git rebase`**: 대상 브랜치의 최신 커밋 위로 현재 브랜치의 커밋들을 **하나씩 순서대로 다시 적용(replay)**한다. 병합 커밋 없이 깔끔한 선형 히스토리를 만든다. **"역사를
      재작성하는"** 방식이다.

* **문법 및 사용법 (How?)**:
  ```bash
  # feature 브랜치에서 작업 후, main의 최신 변경사항을 rebase로 반영
  git switch feature
  git rebase main # main의 최신 커밋 위로 feature의 커밋들을 옮김

  # rebase 중 충돌 발생 시
  # 1. 충돌 파일 수정
  # 2. git add <수정한 파일>  # "충돌 해결 완료" 신호
  # 3. git rebase --continue # rebase 과정 계속 진행
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **이미 팀원과 공유된(pushed) 브랜치에서는 절대 `rebase`를 사용하면 안 된다.** 다른 사람의 작업 기준점이 되는 역사를 바꿔버려 큰 혼란을 초래한다. `rebase`는 `push`하기 전,
      개인 로컬 브랜치의 히스토리를 정리할 때만 사용한다.
    * `rebase` 중 충돌 해결 시 `git commit`을 사용하면 안 된다. `rebase`는 내부적으로 커밋을 새로 만드는 과정이므로, 사용자는 충돌 해결 사실만 `add`로 알려주고,
      `rebase --continue`로 나머지 과정을 Git에게 맡겨야 한다.

---

### 2. 커밋 골라내기: `cherry-pick`

다른 브랜치에 있는 특정 커밋 하나(또는 여러 개)만 현재 브랜치로 가져오는 방법을 학습했다.

* **학습 목표 (Why?)**:
  전체 브랜치를 병합하기는 부담스럽지만, 다른 브랜치의 특정 기능이나 버그 수정 커밋 하나만 긴급하게 현재 브랜치에 적용하고 싶을 때 사용한다.

* **핵심 원리 (What?)**:
  `cherry-pick`은 지정된 커밋에서 이루어진 변경사항(diff)을 그대로 복사하여, 현재 브랜치 위에 **새로운 커밋**으로 만든다. 기존 커밋을 옮겨오는 것이 아니라, 내용을 복제하는 것이다.

* **문법 및 사용법 (How?)**:
  ```bash
  # main 브랜치에서 작업 중
  git switch main

  # release 브랜치에 있는 특정 커밋(a1b2c3d)만 main으로 가져오기
  git cherry-pick a1b2c3d
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`cherry-pick` vs. `merge`**: 특정 커밋 `C`에서 브랜치를 만들어 `merge`하는 것은 가능하지만, 이는 불필요한 브랜치와 병합 커밋을 남겨 히스토리를 복잡하게 만든다.
      `cherry-pick`은 **"나는 이 기능(커밋) 하나만 명시적으로 필요하다"**는 의도를 히스토리에 가장 깔끔하게 표현하는 방법이다.
    * 가져오려는 커밋이 이전 커밋에 의존하고 있다면(e.g., 특정 변수 선언이 이전 커밋에 있음), 해당 커밋만 `cherry-pick` 했을 때 코드가 정상 동작하지 않거나 충돌이 발생할 수 있다. 커밋
      간의 의존성을 반드시 확인해야 한다.

---

### 3. 대화형 리베이스: `rebase -i`

커밋 히스토리를 단순히 옮기는 것을 넘어, 커밋을 합치거나 메시지를 수정하는 등 세밀하게 편집하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  Pull Request를 보내기 전, 너무 잘게 쪼개진 커밋("wip", "fix typo" 등)들을 의미 있는 단위로 합치거나(squash), 커밋 메시지를 명확하게 수정하여(reword) 동료가 리뷰하기 좋은
  깔끔한 히스토리를 만들기 위함이다.

* **핵심 원리 (What?)**:
  `git rebase -i <기준>` 명령어를 실행하면, 지정한 기준 이후의 커밋 목록이 편집기에 나타난다. 각 커밋 앞에 있는 `pick` 키워드를 아래와 같은 다른 명령어로 수정하여 히스토리를 조작할 수
  있다.
    * `reword (r)`: 커밋 내용은 유지하고, 메시지만 수정한다.
    * `squash (s)`: 이전 커밋과 하나로 합친다. 두 커밋의 메시지도 함께 편집한다.
    * `fixup (f)`: `squash`와 같지만, 이 커밋의 메시지는 버리고 이전 커밋의 메시지만 사용한다.
    * `drop (d)`: 해당 커밋을 히스토리에서 완전히 삭제한다.

* **문법 및 사용법 (How?)**:
  ```bash
  # 최근 3개의 커밋을 대화형으로 편집
  git rebase -i HEAD~3
  ```

---

### 4. 버전 명시와 복구 (`tag`, `reflog`)

* **`git tag`와 Semantic Versioning**:
    * **학습 목표 (Why?)**: 프로젝트의 중요한 이정표, 특히 배포 버전을 명시적으로 표시하여 쉽게 찾아갈 수 있도록 하기 위함이다.
    * **핵심 원리 (What?)**: `tag`는 특정 커밋에 붙이는 이름표다. `v1.0.2`와 같이 **Major.Minor.Patch** 형식으로 버전을 관리하는 것을 Semantic
      Versioning이라 한다.
        * **Major**: 하위 호환성이 깨지는 큰 변경
        * **Minor**: 하위 호환성을 유지하며 기능 추가
        * **Patch**: 하위 호환성을 유지하며 버그 수정
    * **사용법 (How?)**: `git tag v1.0.0`, `git tag -a v1.0.1 -m "Release notes"` (Annotated Tag)

* **`git reflog`**:
    * **학습 목표 (Why?)**: `reset --hard`나 `rebase` 중 실수로 커밋을 날렸을 때, 이를 복구할 수 있는 최후의 안전장치를 이해하기 위함이다.
    * **핵심 원리 (What?)**: `reflog`는 `HEAD` 포인터가 이동했던 모든 기록을 로컬에 저장한다. 브랜치에서 삭제된 커밋이라도, `reflog`에는 `HEAD@{n}` 형태로 기록이 남아있어
      해당 시점으로 돌아갈 수 있다.
    * **사용법 (How?)**: `git reflog`로 복구할 시점(`HEAD@{n}`)을 확인한 후, `git reset --hard HEAD@{n}`으로 복구한다.

---

## 오늘의 깨달음 💡

* Git 명령어들은 단순 기능이 아니라 **개발자의 의도를 역사에 기록하는 도구**다. `merge`는 "협업의 흐름을 남기겠다"는 의도이며, `rebase`는 "히스토리를 간결하게 정리하겠다"는 의도다.
  `cherry-pick`은 "나는 이 기능 하나만 선택적으로 필요하다"는 명확한 의사 표현이다.

* `rebase`와 같은 복잡한 명령어의 동작 원리를 이해하는 것이 중요하다. Git이 내부적으로 커밋을 재작성하는 메커니즘을 이해하자, 왜 `rebase` 중 충돌 해결 후 `commit`이 아닌
  `--continue`를 써야 하는지 명확히 납득할 수 있었다.

* 편의성을 위해 만든 alias가 오히려 작업의 유연성을 해칠 수 있음을 깨달았다. `git add .`을 포함한 alias는 의도치 않게 모든 파일을 스테이징하는 부작용이 있었다. 도구는 그 동작 방식과 한계를
  정확히 알고 사용해야 한다.

* "왜 이 명령어가 필요할까?"라는 질문을 던지고 직접 실험해보는 과정이 개념을 가장 깊이 이해하게 만들었다. `cherry-pick`과 `merge`의 차이를 고민하며 직접 여러 시나리오를 테스트해본 경험이,
  단순히 설명을 읽는 것보다 훨씬 큰 깨달음을 주었다.