# TIL - 2025.05.13 - Git 과거 수정 및 원격 저장소 연동 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Reset #Revert #Remote #Push #Pull #Clone

---

## 오늘 배운 내용 🔍

- 과거 커밋을 수정하는 세 가지 명령어의 차이점: `git reset`, `git revert`, `git restore`
- `git reset`의 세 가지 옵션(`--soft`, `--mixed`, `--hard`)별 동작 방식
- 원격 저장소(Remote Repository)의 개념과 `git remote`를 이용한 연결
- 로컬 변경사항을 원격 저장소에 반영하는 `git push`
- 원격 저장소의 변경사항을 로컬로 가져오는 `git fetch`와 `git pull`의 차이
- 원격 저장소의 브랜치 상태를 추적하는 '원격 추적 브랜치'(`origin/main`)의 역할
- `git clone`을 통한 원격 저장소 복제 및 초기 설정

---

## 어려웠던 점 💣

* `reset`, `revert`, `restore` 세 명령어 모두 '되돌린다'는 공통점 때문에 각자의 역할과 사용 시점을 구분하는 것이 가장 혼란스러웠다. 어떤 명령어가 어떤 영역(Working
  Directory, Staging Area, Repository)에 영향을 미치는지 명확히 인지하는 것이 핵심이었다.

* `git reset HEAD` 명령어를 실행했을 때, 커밋이 뒤로 돌아가지 않아 당황했다. 이 명령어는 `HEAD~1`과 달리 커밋 포인터를 이동시키는 것이 아니라, 단순히 `add` 했던 파일들을 스테이징
  영역에서 내리는(`--mixed` 동작) 역할만 한다는 것을 나중에야 이해했다.

* `git clone`을 실행했을 때, 원격 저장소의 모든 브랜치가 로컬에 바로 생성되지 않고 `origin/feature` 와 같은 형태로만 보이는 것이 생소했다. `git switch`를 통해 필요한 시점에
  로컬 브랜치가 생성된다는 동작 방식을 파악하는 데 시간이 걸렸다.

---

## 정리 🖇️

### 1. 과거 시점으로 되돌리기 (`reset`, `revert`)

실수로 만들었거나 문제가 있는 커밋을 이전 상태로 되돌리는 방법을 학습했다.

* **학습 목표 (Why?)**:
  프로젝트의 특정 시점으로 코드를 되돌리거나, 잘못된 커밋의 영향을 제거하기 위함이다. 특히 협업 시에는 프로젝트의 공식 기록(History)을 안전하게 관리하는 것이 매우 중요하다.

* **핵심 원리 (What?)**:
  되돌리는 방식에 따라 크게 두 가지 명령어로 나뉜다.
    * **`git reset`**: **과거로 돌아가는 타임머신.** `HEAD` 포인터 자체를 지정한 과거 커밋으로 직접 이동시킨다. 이후의 커밋 기록이 사라지므로, 이미 원격 저장소에 공유된 커밋에는 절대
      사용해서는 안 된다.
        * `--soft`: 커밋 기록만 되돌린다. 변경 내용은 Staging Area에 그대로 남아있다. (`commit`만 취소)
        * `--mixed` (기본값): 커밋 기록과 Staging Area를 되돌린다. 변경 내용은 Working Directory에 남아있다. (`commit`과 `add`를 취소)
        * `--hard`: 커밋, 스테이징, 작업 디렉터리 내용을 모두 지정한 커밋 상태로 되돌린다. **작업 내용이 완전히 삭제되므로 매우 위험하다.**
    * **`git revert`**: **실수를 만회하는 새로운 행동.** 특정 커밋에서 이루어진 변경사항을 거꾸로 적용하는 **새로운 커밋**을 생성한다. 기존 커밋 기록을 삭제하지 않고 그대로 유지하므로,
      공유된 브랜치에서 특정 변경을 안전하게 되돌릴 때 사용한다.

* **문법 및 사용법 (How?)**:
  ```bash
  # 가장 최근 커밋을 취소하고, 변경사항은 Working Directory에 남김 (mixed)
  git reset HEAD~1

  # 가장 최근 커밋을 완전히 삭제 (위험!)
  git reset --hard HEAD~1

  # 특정 커밋(예: a1b2c3d)의 변경사항을 되돌리는 새 커밋을 생성
  git revert a1b2c3d
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`reset`은 개인 로컬 브랜치에서만, `revert`는 공유된 브랜치에서 사용**하는 것이 원칙이다. `push`된 커밋을 `reset`하면 다른 팀원의 저장소와 역사가 꼬이게 된다.
    * `git restore`는 아직 커밋되지 않은, **Working Directory의 변경사항**을 되돌릴 때 사용하는 명령어다. `reset`, `revert`와는 달리 커밋 기록(Repository)에
      전혀 영향을 주지 않는다.

---

### 2. 원격 저장소(Remote) 연동 및 동기화

로컬 Git 저장소를 GitHub과 같은 원격 서버와 연결하고, 코드를 주고받는 방법을 학습했다.

* **학습 목표 (Why?)**:
  작업물을 안전하게 백업하고, 다른 개발자들과 코드를 공유하며 협업하기 위해 필수적이다.

* **핵심 원리 (What?)**:
    * **Remote**: 내 컴퓨터가 아닌 다른 곳(e.g., GitHub 서버)에 위치한 저장소.
    * **`git remote add <이름> <주소>`**: 로컬 저장소에 원격 저장소의 주소를 특정 이름(보통 `origin`)으로 등록한다.
    * **`git push <원격저장소이름> <브랜치이름>`**: 로컬 브랜치의 커밋들을 원격 저장소로 업로드한다.
    * **`git fetch`**: 원격 저장소의 최신 내역을 가져오기만 한다. 로컬 코드에는 아무런 변경을 일으키지 않고, 원격 추적 브랜치(`origin/main`)만 업데이트한다.
    * **`git pull`**: 원격 저장소의 최신 내역을 가져와서(**fetch**), 현재 로컬 브랜치와 병합(**merge**)까지 실행한다. (`git pull` = `git fetch` +
      `git merge`)

* **문법 및 사용법 (How?)**:
  ```bash
  # 1. 원격 저장소 연결 (최초 1회)
  git remote add origin https://github.com/user/repo.git

  # 2. 로컬 main 브랜치의 내용을 origin으로 push
  # -u 옵션은 로컬 main과 원격 origin/main을 연결(track)하라는 의미
  git push -u origin main

  # 3. 원격 저장소의 변경사항을 로컬로 가져와 병합
  git pull origin main
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `pull`은 자동으로 `merge`를 실행하므로, 원격 저장소에 어떤 변경이 있었는지 모르는 상태에서 실행하면 예기치 않은 충돌이 발생할 수 있다. `fetch`로 먼저 변경 내역을 확인한 후, 수동으로
      `merge`하는 것이 더 안전한 작업 방식이 될 수 있다.

---

### 3. 원격 추적 브랜치와 `git clone`

원격 저장소의 상태를 로컬에서 어떻게 추적하고 관리하는지 학습했다.

* **학습 목표 (Why?)**:
  로컬 브랜치(`main`)와 원격 저장소의 브랜치(`origin/main`)가 어떻게 상호작용하는지 이해하여, 협업 시 발생할 수 있는 혼란을 줄이기 위함이다.

* **핵심 원리 (What?)**:
    * **`git clone <주소>`**: 원격 저장소의 모든 데이터를 복제하여 로컬 저장소를 생성한다. `git init`, `git remote add`, 기본 브랜치 설정 등을 한 번에 처리해주는 편리한
      명령어다.
    * **원격 추적 브랜치 (Remote-Tracking Branch)**: `origin/main`과 같이, 원격 저장소에 있는 브랜치들의 상태를 가리키는 **읽기 전용 포인터**다. 이 브랜치는
      `fetch`나 `pull`을 할 때만 업데이트된다. 로컬에서 직접 작업하는 공간이 아니다.
    * `clone`을 하면 기본 브랜치(`main`)만 로컬에 생성되고, 이 브랜치는 `origin/main`을 추적하도록 자동으로 설정된다. 다른 브랜치들(`origin/feature` 등)은 원격 추적
      브랜치로만 존재한다.
    * 이 상태에서 `git switch feature` 명령어를 실행하면, Git은 `origin/feature`의 존재를 확인하고, 그를 추적하는 로컬 `feature` 브랜치를 자동으로 생성해준다.

---

## 오늘의 깨달음 💡

* `reset`, `revert`, `restore`는 단순히 '되돌린다'는 기능이 아니라, **무엇을(대상) 어떻게(방식) 되돌릴지**에 따라 명확히 구분되는 각자의 철학을 가진 명령어임을 이해했다.
  `reset`은 역사를 바꾸고, `revert`는 역사를 덧붙이며, `restore`는 현재의 실수만 닦아낸다.

* `git reset --mixed HEAD`가 `add`의 취소, `git reset --mixed HEAD~1`이 `commit`과 `add`의 취소라는 미세한 차이를 구분하게 되면서, `HEAD`와
  `HEAD~1`이 가리키는 대상의 차이를 명확히 인지하게 되었다.

* `reset --mixed` 후 `restore`를 실행하면 `reset --hard`와 결과적으로 비슷해 보이지만, 과정의 차이가 안전성의 차이를 만든다. `hard`는 한번에 모든 것을 되돌리는 위험한 작업인
  반면, `mixed`와 `restore`를 조합하는 것은 변경사항을 검토할 기회를 가지는 더 안전한 단계적 접근법이다.

* 원격 저장소는 단순히 코드를 저장하는 클라우드 드라이브가 아니라, `origin/main`과 같은 '원격지의 거울'을 통해 로컬 저장소와 끊임없이 상태를 동기화하는 유기적인 시스템이라는 것을 깨달았다.