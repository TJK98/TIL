# TIL - 2025.05.12 - Git 병합, 충돌 해결 및 작업 관리 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Merge #Conflict #Stash #Diff

---

## 오늘 배운 내용 🔍

- 브랜치를 병합하는 두 가지 방식: Fast-forward와 3-way Merge
- 병합 시 발생하는 충돌(Conflict)의 원인과 해결 과정
- 파일의 변경사항을 비교하는 `git diff` 명령어의 다양한 사용법
- 작업 내용을 임시로 저장하는 `git stash` 명령어 활용
- 변경사항을 되돌리는 `git restore` 명령어의 역할
- 브랜치가 아닌 특정 커밋을 가리키는 `Detached HEAD` 상태의 이해

---

## 어려웠던 점 💣

* 의도적으로 3-way Merge 상황을 만드는 것이 어려웠다. `main` 브랜치에 추가적인 커밋을 만들지 않은 상태에서 병합을 시도하여, 계속해서 Fast-forward Merge가 발생하는 실수를 했다. 두
  브랜치의 역사가 갈라져야만 3-way Merge가 일어난다는 조건을 명확히 이해해야 했다.

---

## 정리 🖇️

### 1. 브랜치 병합 (Merge)

분리된 작업 흐름(브랜치)을 하나의 브랜치로 통합하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  기능 개발이 완료된 브랜치의 작업 내용을 `main`과 같은 주축 브랜치에 반영하여, 프로젝트에 새로운 기능을 통합하기 위함이다.

* **핵심 원리 (What?)**:
  | 방식 | 설명 |
  | :--- | :--- |
  | **Fast-forward** | 브랜치 간 이력이 갈라지지 않은 직선 관계일 때, 단순히 포인터만 이동 |
  | **3-way Merge** | 브랜치 간 이력이 갈라졌을 때, 공통 조상을 기준으로 새 병합 커밋을 생성 |

* **문법 및 사용법 (How?)**:
  ```bash
  # 1. main 브랜치로 이동
  git switch main

  # 2. feature 브랜치의 내용을 main 브랜치로 병합
  git merge feature
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * Fast-forward를 막고 의도적으로 병합 커밋을 남기고 싶다면 `git merge --no-ff <브랜치명>` 옵션을 사용한다.

---

### 2. 병합 충돌 (Merge Conflict)

두 개의 브랜치에서 같은 파일의 같은 부분을 수정했을 때 발생하는 충돌을 해결하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  여러 사람이 동시에 같은 파일을 작업할 때 발생할 수 있는 코드 충돌 상황을 이해하고, 개발자가 직접 수정하여 병합을 안전하게 완료하기 위함이다.

* **핵심 원리 (What?)**:
  충돌이 발생하면 Git은 병합을 멈추고, 파일 내부에 `<<<<<<< HEAD`, `=======`, `>>>>>>> 브랜치명` 과 같은 충돌 표시기(Conflict Marker)를 생성한다.

* **문법 및 사용법 (How?)**:
    1. 충돌이 발생한 파일을 열어 충돌 표시기를 제거하고 코드를 직접 수정한다.
    2. `git add <수정한 파일>` 명령어로 충돌 해결을 완료했음을 알린다.
    3. `git commit`을 실행하여 병합을 마무리한다.

---

### 3. 주요 작업 관리 명령어

`diff`, `stash`, `restore` 등 작업을 효율적으로 관리하는 명령어들을 학습했다.

* **학습 목표 (Why?)**:
  변경사항을 비교 검토하고, 작업을 임시 저장하며, 실수를 되돌리는 등 다양한 개발 상황에 유연하게 대처하기 위함이다.

* **핵심 원리 (What?)**:
  | 명령어 | 설명 |
  | :--- | :--- |
  | `git diff` | Working Directory ↔ Staging Area 변경사항 비교 |
  | `git diff --staged` | Staging Area ↔ 최신 커밋(HEAD) 변경사항 비교 |
  | `git stash` | 현재 작업 내용을 임시로 저장 |
  | `git stash pop` | 가장 최근의 stash를 꺼내와 적용하고 목록에서 제거 |
  | `git restore <파일명>` | Working Directory의 변경사항을 최신 커밋 상태로 되돌림 |
  | `git restore --staged <파일명>`| Staging Area에 올린 파일을 다시 내림 (`add` 취소) |

---

### 4. Detached HEAD 상태

브랜치가 아닌 특정 커밋을 직접 가리키는 특수한 상태를 학습했다.

* **학습 목표 (Why?)**:
  과거의 특정 커밋 시점으로 프로젝트 상태를 되돌려 코드를 확인하거나 테스트해보기 위해 필요하다.

* **핵심 원리 (What?)**:
  `git checkout <커밋 해시>` 명령어로 특정 커밋으로 이동하면 `Detached HEAD` 상태가 된다. 이 상태에서 새로운 커밋을 만들면 어떤 브랜치에도 속하지 않아 유실될 수 있다.

* **주의사항 및 실무 팁 (Watch out for)**:
    * `Detached HEAD` 상태에서 작업한 내용을 저장하고 싶다면, 반드시 `git switch -c <새 브랜치명>` 명령어로 새로운 브랜치를 생성하여 해당 커밋을 가리키도록 해야 한다.

---

## 오늘의 깨달음 💡

* 병합 충돌은 피해야 할 '문제'가 아니라, 여러 개발자의 작업이 합쳐지는 과정에서 발생하는 자연스러운 '조율' 과정의 일부로 인식하게 되었다.

* `HEAD`가 항상 브랜치를 가리키는 것이 아니라는 `Detached HEAD` 개념을 통해, Git의 내부 포인터 시스템을 더 깊게 이해하는 계기가 되었다.