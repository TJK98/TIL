# TIL - 2025.05.13 - Git 과거 수정 및 원격 저장소 연동 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #Reset #Revert #Remote #Push #Pull #Clone

---

## 오늘 배운 내용 🔍

- 과거 커밋을 수정하는 세 가지 명령어의 차이점: `git reset`, `git revert`, `git restore`
- `git reset`의 세 가지 옵션(`--soft`, `--mixed`, `--hard`)별 동작 방식
- 원격 저장소(Remote Repository) 개념과 `git remote`를 이용한 연결
- 로컬 변경사항을 원격 저장소에 반영하는 `git push`
- 원격 저장소의 변경사항을 로컬로 가져오는 `git fetch`와 `git pull`의 차이
- 원격 추적 브랜치(`origin/main`)의 역할과 `git clone`

---

## 어려웠던 점 💣

* `reset`, `revert`, `restore` 세 명령어 모두 '되돌린다'는 공통점 때문에 각자의 역할과 사용 시점을 구분하는 것이 가장 혼란스러웠다. 어떤 명령어가 어떤 영역(Working
  Directory, Staging Area, Repository)에 영향을 미치는지 명확히 인지하는 것이 핵심이었다.

---

## 정리 🖇️

### 1. 과거 시점으로 되돌리기 (`reset`, `revert`, `restore`)

잘못된 커밋이나 작업을 이전 상태로 되돌리는 다양한 방법을 학습했다.

* **학습 목표 (Why?)**:
  실수를 되돌리고 프로젝트의 기록을 안전하게 관리하기 위함이다. 특히 협업 시에는 되돌리는 방식이 프로젝트 전체에 영향을 미치므로 명확한 이해가 필수적이다.

* **핵심 원리 (What?)**:
  `git reset`은 커밋 기록 자체를 삭제하며 과거로 돌아가는 **파괴적인** 방식인 반면, `git revert`는 과거의 변경사항을 취소하는 **새로운 커밋을 생성**하는 **비파괴적인** 방식이다.

* **문법 및 사용법 (How?)**:

  **1. `git reset` 옵션 비교**

  | 옵션 | 커밋(HEAD) | Staging Area | Working Directory | 설명 |
    | :--- | :--- | :--- | :--- | :--- |
  | `--soft` | 이동(취소) | 유지 | 유지 | 커밋만 취소 |
  | `--mixed` (기본값) | 이동(취소) | 초기화 | 유지 | 커밋과 `add`를 함께 취소 |
  | `--hard` | 이동(취소) | 초기화 | 초기화 | 모든 변경사항을 삭제하고 과거로 돌아감 (위험) |

  **2. `git revert`**
  ```bash
  # 특정 커밋(a1b2c3d)의 변경사항을 되돌리는 새 커밋을 생성
  git revert a1b2c3d
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`reset`은 개인 로컬 브랜치에서만, `revert`는 공유된 브랜치에서 사용**하는 것이 원칙이다. `push`된 커밋을 `reset`하면 다른 팀원의 저장소와 역사가 꼬이게 된다.
    * `git restore`는 아직 커밋되지 않은, **Working Directory의 변경사항**을 되돌릴 때 사용하는 명령어다. 커밋 기록에는 영향을 주지 않는다.

---

### 2. 원격 저장소 연동 및 동기화

로컬 Git 저장소를 GitHub과 같은 원격 서버와 연결하고, 코드를 주고받는 방법을 학습했다.

* **학습 목표 (Why?)**:
  작업물을 안전하게 백업하고, 다른 개발자들과 코드를 공유하며 협업하기 위해 필수적이다.

* **핵심 원리 (What?)**:
  `origin`은 보통 원격 저장소의 별칭으로 사용된다. 로컬 브랜치(`main`)와 원격 추적 브랜치(`origin/main`)는 서로 다른 포인터이며, `push`/`pull`을 통해 동기화된다.

  | 명령어 | 설명 |
    | :--- | :--- |
  | `git remote add origin <주소>` | 원격 저장소를 `origin`이라는 이름으로 등록 |
  | `git push origin main` | 로컬 `main` 브랜치의 내용을 `origin`의 `main`으로 업로드 |
  | `git fetch` | 원격 저장소의 최신 내역을 가져오기만 함 (`origin/main` 업데이트) |
  | `git pull` | `fetch` + `merge`. 원격 저장소의 최신 내역을 가져와 현재 브랜치에 병합 |
  | `git clone <주소>` | 원격 저장소를 로컬에 복제. `remote add` 등을 자동으로 처리 |

---

## 오늘의 깨달음 💡

* `reset`, `revert`, `restore`는 단순히 '되돌린다'는 기능이 아니라, **무엇을(대상) 어떻게(방식) 되돌릴지**에 따라 명확히 구분되는 각자의 철학을 가진 명령어임을 이해했다.
  `reset`은 역사를 바꾸고, `revert`는 역사를 덧붙이며, `restore`는 현재의 실수만 닦아낸다.

* 원격 저장소는 단순히 코드를 저장하는 클라우드 드라이브가 아니라, `origin/main`과 같은 '원격지의 거울'을 통해 로컬 저장소와 끊임없이 상태를 동기화하는 유기적인 시스템이라는 것을 깨달았다.