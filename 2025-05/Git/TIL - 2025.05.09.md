# TIL - 2025.05.09 - Git의 3가지 영역과 기본 명령어 개념 이해

## 카테고리 🏷️

#TIL #Git #VersionControl #CLI #Branch

---

## 오늘 배운 내용 🔍

- Git 버전 관리 시스템의 기본 개념과 3가지 핵심 영역
- 터미널(Git Bash) 환경에서의 기본 파일 시스템 명령어 (`ls`, `cd`, `mkdir`)
- Git 저장소 생성 및 변경사항 추적 (`git init`, `add`, `commit`)
- `.gitignore` 파일을 이용한 특정 파일 및 폴더 추적 제외 설정
- 브랜치(Branch)를 이용한 독립적인 작업 흐름 관리 (`git branch`, `git switch`)

---

## 어려웠던 점 💣

* `git add` 명령어를 실행하면 변경 내용이 저장소에 기록되는 것으로 오해했다. 이 때문에 `git commit`을 생략하여 작업 내용이 반영되지 않는 실수를 반복했다. `add`는 기록을 위한 '준비'
  단계일 뿐이라는 것을 구분하는 것이 중요했다.

* 브랜치 간의 관계를 부모-자식 같은 계층 구조로 잘못 생각했다. 예를 들어 `main`에서 `feature-A`를, `feature-A`에서 `feature-B`를 만들었다면, `feature-A`를 삭제하면
  `feature-B`도 영향을 받을 것이라 예상했다. 하지만 실제로는 그렇지 않아 혼란스러웠다.

---

## 정리 🖇️

### 1. 터미널 기본 명령어 (CLI)

Git을 효율적으로 사용하기 위해 필요한 기본적인 터미널 명령어 사용법을 학습했다.

* **학습 목표 (Why?)**:
  GUI 도구 없이도, 명령어 라인 인터페이스(CLI) 환경에서 파일과 폴더를 생성하고 이동하는 등 컴퓨터를 직접 제어하기 위함이다. Git의 많은 기능이 터미널 환경에서 가장 빠르고 강력하게 동작한다.

* **핵심 원리 (What?)**:
  터미널은 키보드 입력으로 운영체제와 상호작용하는 프로그램이다. Git Bash는 Windows 환경에서 Linux 스타일의 터미널 명령어를 사용할 수 있게 해주는 도구이다.

* **문법 및 사용법 (How?)**:
    * `ls`: 현재 위치의 파일 및 폴더 목록을 보여준다. (`list`)
    * `cd <폴더명>`: 지정한 폴더로 이동한다. (`change directory`) `cd ..`는 상위 폴더로 이동한다.
    * `mkdir <폴더명>`: 새로운 폴더를 생성한다. (`make directory`)
    * `touch <파일명>`: 비어있는 새 파일을 생성한다.
    * `pwd`: 현재 작업 중인 폴더의 전체 경로를 보여준다. (`print working directory`)

* **주의사항 및 실무 팁 (Watch out for)**:
    * 터미널에서 `Tab` 키를 누르면 파일이나 폴더 이름을 자동 완성할 수 있어 매우 편리하다.

---

### 2. Git의 3가지 영역과 기본 흐름

Git이 파일의 변경사항을 어떻게 추적하고 저장하는지에 대한 핵심 원리를 학습했다.

* **학습 목표 (Why?)**:
  단순히 명령어를 암기하는 것을 넘어, 내 작업물이 어떤 단계를 거쳐 버전으로 기록되는지 이해하기 위함이다. 이는 `git add`와 `git commit`의 역할을 명확히 구분하고 실수를 줄이는 데 필수적이다.

* **핵심 원리 (What?)**:
  Git은 작업을 세 가지 영역으로 나누어 관리한다.
    1. **Working Directory (작업 디렉터리)**: 실제 사용자가 파일 수정, 생성, 삭제 등의 작업을 하는 프로젝트 폴더.
    2. **Staging Area (스테이징 영역)**: 버전으로 기록할 변경사항들을 임시로 모아두는 '준비 공간'. `git add` 명령어를 사용하면 파일의 변경 내용이 이곳으로 이동한다.
    3. **Repository (저장소)**: Staging Area에 있던 변경사항들이 `git commit` 명령어를 통해 버전(스냅샷)으로 영구히 기록되는 곳.

* **문법 및 사용법 (How?)**:
  ```bash
  # 1. 현재 폴더를 Git 저장소로 초기화
  git init

  # 2. 파일을 수정하거나 생성 (Working Directory에서의 변경)
  # ex) product.txt 파일 생성 및 내용 추가

  # 3. 변경된 파일을 Staging Area에 추가
  git add product.txt

  # 4. Staging Area의 변경사항을 메시지와 함께 Repository에 기록
  git commit -m "Add new product information"

  # 5. 현재 Git의 상태를 확인 (어떤 파일이 변경되었고, Staging Area에 있는지 등)
  git status

  # 6. Repository에 기록된 커밋 내역을 확인
  git log
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`git add`는 저장이 아니다.** 커밋에 포함시킬 변경사항을 선택하는 행위일 뿐이다. 여러 파일을 수정한 뒤, 원하는 파일만 `add`하여 의미 있는 단위로 커밋을 구성할 수 있다.
    * `.gitignore` 파일을 프로젝트 최상위 폴더에 만들고, 로그 파일(`*.log`), 빌드 결과물(`/build`) 등 버전 관리가 필요 없는 파일이나 폴더를 지정하면 Git이 해당 파일들을 무시(
      untracked)한다.

---

### 3. 브랜치(Branch)를 이용한 작업 분리

기존 코드에 영향을 주지 않으면서 새로운 기능을 개발하거나 버그를 수정할 수 있는 독립적인 작업 공간을 만드는 방법을 학습했다.

* **학습 목표 (Why?)**:
  안정적인 메인 버전(`main` 브랜치)을 유지하면서, 동시에 여러 기능을 개발하고 실험할 수 있는 환경을 구축하기 위함이다. 협업 시 각자의 작업을 분리하는 데 필수적인 기능이다.

* **핵심 원리 (What?)**:
  **브랜치는 특정 커밋을 가리키는 가벼운 '포인터(pointer)' 또는 '책갈피'**와 같다. 코드 전체를 복사하는 무거운 작업이 아니다. 새로운 브랜치를 생성하면, 기존 커밋 위에 새로운 작업 내역을 쌓아나갈
  수 있는 독립적인 흐름이 생긴다.

* **문법 및 사용법 (How?)**:
  ```bash
  # 현재 모든 브랜치 목록 확인
  git branch

  # 'new-feature' 라는 이름의 새 브랜치 생성
  git branch new-feature

  # 'new-feature' 브랜치로 작업 공간 전환
  git switch new-feature

  # 브랜치 생성과 동시에 전환
  git switch -c another-feature

  # 작업 완료 후 병합된 브랜치 삭제
  git branch -d new-feature
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 브랜치는 독립적인 포인터이기 때문에, 한 브랜치를 삭제해도 그 브랜치가 생성될 때 기반이 되었던 커밋이나 다른 브랜치에는 아무런 영향을 주지 않는다.
    * 예를 들어, `A` 브랜치의 마지막 커밋을 기반으로 `B` 브랜치를 만들었다면, `B`는 `A`의 '자식'이 아니라 'A가 가리키던 커밋을 동일하게 가리키는 새로운 포인터'일 뿐이다. 따라서 `A`
      브랜치를 삭제해도 `B` 브랜치는 온전히 남아있다.

---

## 오늘의 깨달음 💡

* `git add`와 `git commit`의 분리는 단순히 절차가 두 개인 것이 아니라, '기록할 내용을 신중하게 고르는 행위'와 '실제 역사를 기록하는 행위'를 분리한 Git의 중요한 설계 철학임을 이해했다.

* 브랜치를 '폴더 복사'나 '계층 구조'로 이해했던 것은 완전히 잘못된 접근이었다. 브랜치는 특정 커밋을 가리키는 '포인터'라는 본질을 이해하자, 브랜치 생성, 삭제, 이동의 모든 동작이 명확하게 해석되기
  시작했다.

* 결국 Git은 '파일의 변화(diff)'가 아닌 '프로젝트 전체의 스냅샷(snapshot)'을 커밋 단위로 저장하고, 브랜치는 그 스냅샷 중 하나를 가리키는 이름표에 불과하다는 것을 깨달았다.