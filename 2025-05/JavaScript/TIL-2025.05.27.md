# TIL - 2025.05.27 - JavaScript 변수, 데이터 타입, 연산자 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #DataType #Variable #Operator #TypeCoercion

---

## 오늘 배운 내용 🔍

- `let`과 `const`를 이용한 변수 선언 방식과 스코프의 차이점
- JavaScript의 기본 데이터 타입 (Number, String, Boolean, null, undefined)
- 느슨한 타입 언어의 특징인 암묵적/명시적 형변환
- 다양한 연산자(산술, 대입, 비교, 논리)의 종류와 동작 방식
- 조건문에서 `false`로 취급되는 `falsy` 값과 `true`로 취급되는 `truthy` 값
- 브라우저 환경에서 사용되는 기본 입출력 함수 (`alert`, `prompt`, `confirm`)

---

## 어려웠던 점 💣

* `null`과 `undefined`의 차이가 모호하게 느껴졌다. `null`은 개발자가 의도적으로 '값이 없음'을 명시한 상태이고, `undefined`는 변수는 선언되었으나 아직 아무 값도 할당되지 않은 '초기
  상태'라는 의미적 차이를 구분하는 것이 중요했다.

* JavaScript가 타입이 다른 값들끼리 연산을 시도할 때 에러를 발생시키지 않고, 내부 규칙에 따라 **암묵적 형변환**을 수행한다는 점이 혼란스러웠다. 예를 들어, `10 + '5'`가 수학적 덧셈이 아닌
  문자열 접합으로 동작하여 `'105'`가 되는 현상을 이해하는 데 시간이 필요했다.

* 전위 증가 연산자(`++x`)와 후위 증가 연산자(`x++`)의 미세한 동작 차이를 파악하기 어려웠다. `++x`는 값을 먼저 증가시킨 후 연산에 사용하고, `x++`는 현재 값을 먼저 연산에 사용한 후 값을
  증가시킨다는 실행 순서의 차이를 실습을 통해 구분해야 했다.

* `0`, `''`(빈 문자열), `null`, `undefined`, `NaN`이 모두 조건문에서 `false`로 취급된다는 점이 처음에는 직관적이지 않았다. 하지만 이 값들이 모두 '비어있음', '없음', '
  유효하지 않음' 등 부정적인 의미를 내포한다는 공통점을 발견하고 나서야 `falsy`라는 개념으로 묶어서 이해할 수 있었다.

---

## 정리 🖇️

### 1. 변수(Variable) 선언: `let`과 `const`

데이터를 저장하고 참조하기 위한 메모리 공간에 이름을 붙이는 방법을 학습했다.

* **학습 목표 (Why?)**:
  프로그램에서 사용될 데이터를 효율적으로 관리하고, 코드의 가독성과 유지보수성을 높이기 위함이다. 특히 `let`과 `const`를 구분하여 사용함으로써 값의 변경 가능성을 명시하여 실수를 줄일 수 있다.

* **핵심 원리 (What?)**:
  | 키워드 | 재할당 | 특징 |
  | :--- | :--- | :--- |
  | `let` | 가능 (O) | 값을 변경할 수 있는 변수를 선언할 때 사용. |
  | `const`| 불가능 (X) | 한 번 할당하면 절대 변하지 않는 상수(constant)를 선언할 때 사용. 선언과 동시에 초기화가 필수. |

* **문법 및 사용법 (How?)**:
  ```javascript
  let userAge = 30;
  userAge = 31; // 가능

  const userName = "Alice";
  // userName = "Bob"; // TypeError: Assignment to constant variable. (에러 발생)
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `const`로 선언된 객체나 배열의 경우, 변수 자체가 다른 객체나 배열로 재할당되는 것은 불가능하지만, 그 **내부의 속성이나 요소는 변경이 가능**하다.
      ```javascript
      const user = { name: "Alice" };
      user.name = "Bob"; // 가능
      ```
    * 변하지 않을 값은 `const`로 선언하는 것을 기본 원칙으로 삼는 것이 좋다. 이를 통해 코드의 안정성을 높일 수 있다.

---

### 2. 데이터 타입(Data Types)

JavaScript에서 다룰 수 있는 데이터의 종류를 학습했다.

* **학습 목표 (Why?)**:
  각 데이터 타입의 특징과 한계를 이해하여, 데이터에 맞는 적절한 연산과 처리를 수행하기 위함이다.

* **핵심 원리 (What?)**:
  JavaScript의 기본(Primitive) 데이터 타입은 다음과 같다.
  | 타입 | 예시 | 설명 |
  | :--- | :--- | :--- |
  | `Number` | `10`, `3.14`, `NaN`, `Infinity` | 정수, 실수, 그리고 숫자가 아님(`NaN`), 무한대(`Infinity`)를 포함하는 숫자형. |
  | `String` | `"hello"`, `'world'`, `` `template` `` | 텍스트 데이터를 나타내는 문자열. |
  | `Boolean`| `true`, `false` | 논리적인 참/거짓을 나타냄. |
  | `null` | `let a = null;` | 개발자가 의도적으로 '값이 비어있음'을 나타낼 때 사용. |
  | `undefined` | `let a;` | 변수가 선언되었지만, 아직 아무 값도 할당되지 않은 상태. |

* **문법 및 사용법 (How?)**:
  ```javascript
  const name = "Alice"; // String
  const age = 30; // Number
  const isStudent = true; // Boolean
  let score = null; // null (의도적으로 비워둠)
  let address; // undefined (아직 할당되지 않음)

  // typeof 연산자로 타입 확인 가능
  console.log(typeof name); // "string"
  console.log(typeof age); // "number"
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 문자열은 배열처럼 `text[0]`과 같이 각 문자에 인덱스로 접근할 수 있지만, 이는 **읽기 전용**이다. `text[0] = 'H'`와 같이 값을 수정하는 것은 불가능하다.

---

### 3. 형변환 (Type Conversion)

한 데이터 타입을 다른 데이터 타입으로 변환하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  JavaScript 엔진의 암묵적 형변환 규칙을 이해하고, `Number()`, `String()` 등 명시적 형변환을 통해 코드의 동작을 예측 가능하게 만들기 위함이다.

* **핵심 원리 (What?)**:
    * **암묵적 형변환 (Implicit Coercion)**: JavaScript 엔진이 연산을 위해 자동으로 타입을 변환하는 것. (e.g., `+` 연산자는 문자열 접합을 우선함)
    * **명시적 형변환 (Explicit Coercion)**: 개발자가 의도를 가지고 직접 타입을 변환하는 것.
      | 변환 목표 | 방법 | 예시 |
      | :--- | :--- | :--- |
      | **숫자로 변환** | `Number()`, `parseInt()`, 단항 `+` 연산자 | `Number("123")` → `123` |
      | **문자열로 변환**| `String()`, `.toString()` | `String(123)` → `"123"` |

* **문법 및 사용법 (How?)**:
  ```javascript
  // 암묵적 형변환
  console.log(10 + "5"); // '105' (문자열 접합)
  console.log(10 - "5"); // 5 (산술 연산)

  // 명시적 형변환
  const userInput = "30";
  const age = Number(userInput); // 문자열 "30"을 숫자 30으로 변환
  console.log(age + 5); // 35
  ```

---

### 4. 연산자 (Operators)

값을 확인, 변경, 결합하는 데 사용되는 기호들을 학습했다.
| 연산자 종류 | 설명 | 예시 |
| :--- | :--- | :--- |
| **산술 연산자** | 사칙연산, 나머지(`%`), 거듭제곱(`**`), 증감(`++`, `--`) | `5 % 2` → `1` |
| **대입 연산자** | 변수에 값을 할당. 복합 대입 연산자(`+=`, `-=`) 사용 가능 | `let x = 5; x += 3;` → `x`는 `8` |
| **비교 연산자** | 두 값의 관계를 비교하여 `true`/`false` 반환 | `5 == "5"`(true), `5 === "5"`(false) |
| **논리 연산자** | 여러 조건을 결합 (`&&`: AND), 또는 (`||`: OR), 반전 (`!`: NOT) | `isLogin && isAdmin` |

* **주의사항 및 실무 팁 (Watch out for)**:
    * **`==` vs `===`**: `==` (동등 연산자)는 타입을 자동으로 변환하여 값만 비교하므로 예상치 못한 결과를 낳을 수 있다. 항상 값과 타입을 모두 비교하는 **`===` (일치 연산자)를
      사용하는 것이 안전**하다.

---

### 5. `Truthy` & `Falsy`

조건문에서 `true` 또는 `false`로 평가되는 값들을 학습했다.

* **학습 목표 (Why?)**:
  JavaScript에서 조건식이 어떻게 평가되는지 이해하여, 간결하고 효과적인 조건문을 작성하기 위함이다.

* **핵심 원리 (What?)**:
  JavaScript에는 `false` 그 자체가 아니더라도 `false`처럼 취급되는 6가지 **`falsy`** 값이 있다. 이 외의 모든 값은 **`truthy`**로 취급된다.
  | Falsy 값 |
  | :--- |
  | `false` |
  | `0` |
  | `""` (빈 문자열) |
  | `null` |
  | `undefined` |
  | `NaN` |

* **문법 및 사용법 (How?)**:
  ```javascript
  let username = "";

  if (username) { // username은 빈 문자열('')이므로 falsy
    console.log(`Hello, ${username}`);
  } else {
    console.log("Please enter your name."); // 이 코드가 실행됨
  }
  ```

---

## 오늘의 깨달음 💡

* `null`과 `undefined`, `NaN`과 `Infinity` 등 특수한 값들의 의미를 명확히 구분하게 되었다. 이 값들은 에러가 아니라, JavaScript가 특정 상태('값이 없음', '숫자가 아님'
  등)를 표현하는 방식임을 이해했다.

* JavaScript의 암묵적 형변환은 편리해 보이지만, 코드의 예측 가능성을 떨어뜨리는 주된 원인이 될 수 있다는 것을 깨달았다. 안정적인 코드를 작성하기 위해서는 `Number()`, `String()` 등
  명시적 형변환을 통해 개발자의 의도를 명확히 드러내는 것이 중요하다.

* JavaScript가 특정 값들을 `falsy`로 간주하는 규칙을 통해, 변수에 값이 실제로 '있는지' 여부를 `if (variable)`과 같이 간결하게 확인할 수 있었다. 이는 JavaScript의 유연한
  특성을 잘 활용하는 효율적인 코딩 방식임을 알게 되었다.