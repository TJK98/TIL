# TIL - 2025.05.30 - JavaScript 배열 생성, 접근 및 기본 메서드 활용 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Array #DataStructure #ArrayMethods

---

## 오늘 배운 내용 🔍

- 배열(Array)의 기본 개념 및 생성 방법 (리터럴, 생성자)
- 인덱스를 이용한 배열 요소의 접근, 수정 및 순회(`for`, `for...of`)
- 배열 끝에 요소를 추가/제거하는 메서드 (`push`, `pop`)
- 배열 앞에 요소를 추가/제거하는 메서드 (`unshift`, `shift`)
- 배열의 중간을 조작(`splice`)하거나 일부를 복사(`slice`)하는 메서드
- 배열 내 특정 요소를 탐색하는 메서드 (`indexOf`, `includes`)
- 각 메서드별 원본 배열 변경(Mutation) 여부 구분

---

## 어려웠던 점 💣

* 배열에서 특정 값을 찾을 때, 찾고 싶은 값을 변수에 담아 `indexOf(searchVariable)` 형태로 사용하는 방식이 처음에는 직관적으로 떠오르지 않았다.

* `if (products.includes(targetProduct))` 와 같이, `includes()` 메서드를 조건문 안에서 활용하여 배열에 특정 값이 '존재하는지' 여부를 먼저 확인하는 논리적 흐름을
  구성하는 것이 익숙하지 않았다.

* `indexOf()`로 위치를 찾고, 그 결과를 변수에 저장한 뒤, 다시 그 변수를 `splice()`의 인자로 넘겨 요소를 수정하거나 삭제하는 것처럼, 여러 메서드의 결과를 연계하여 사용하는 다단계 로직을
  설계하는 것이 복잡하게 느껴졌다.

---

## 정리 🖇️

### 1. 배열(Array)의 기본 개념과 생성

여러 개의 데이터를 하나의 변수에 순서대로 저장하고 관리하는 자료 구조를 학습했다.

* **학습 목표 (Why?)**:
  사용자 목록, 상품 목록, 점수 등 연관 있는 여러 데이터를 개별 변수로 선언하는 대신, 하나의 변수로 묶어 효율적으로 관리하고 반복문 등을 통해 일괄 처리하기 위함이다.

* **핵심 원리 (What?)**:
  배열은 대괄호(`[]`) 안에 쉼표(`,`)로 구분된 값들의 목록을 저장한다. 각 데이터는 **인덱스(index)**라는 고유한 순서 번호(0부터 시작)를 가지며, 이 인덱스를 통해 특정 데이터에 접근할 수
  있다.
    * **배열 리터럴**: `let arr = [1, 2, 3];` 과 같이 대괄호를 이용해 생성하는 가장 일반적이고 권장되는 방식이다.
    * **배열 생성자**: `let arr = new Array(1, 2, 3);` 과 같이 `new Array()` 키워드를 이용해 생성하는 방식이다.

* **문법 및 사용법 (How?)**:
  ```javascript
  // 배열 생성 (리터럴 방식)
  let users = ['Alice', 'Bob', 'Charlie'];

  // 요소 접근 (0부터 시작하는 인덱스 사용)
  console.log(users[0]); // 'Alice'
  console.log(users.length); // 3 (배열의 길이)

  // 요소 수정
  users[1] = 'Daniel';
  console.log(users); // ['Alice', 'Daniel', 'Charlie']
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * 배열의 인덱스는 항상 `0`부터 시작한다는 점을 잊지 말아야 한다. 마지막 요소의 인덱스는 `배열.length - 1` 이다.
    * `const`로 선언된 배열이라도, 배열 자체를 다른 배열로 재할당하는 것은 불가능하지만, `push()`나 인덱스를 통한 요소 수정 등 내부 내용을 변경하는 것은 가능하다.

---

### 2. 배열 순회(Looping)와 주요 메서드

배열의 모든 요소를 탐색하거나, 특정 규칙에 따라 요소를 추가, 삭제, 수정하는 다양한 내장 함수들을 학습했다.

* **학습 목표 (Why?)**:
  배열에 담긴 데이터를 동적으로 조작하고, 필요한 정보를 효율적으로 탐색하여 다양한 데이터 처리 로직을 구현하기 위함이다.

* **핵심 원리 (What?)**:
  배열 메서드는 크게 **원본 배열을 직접 변경(Mutating)**하는 메서드와, **원본은 그대로 두고 새로운 배열이나 값을 반환(Non-mutating)**하는 메서드로 나뉜다. 이 차이를 이해하는 것이 매우
  중요하다.
  | 메서드 | 설명 | 원본 변경 |
  | :--- | :--- | :--- |
  | `push(item)` | 배열의 **끝**에 요소를 추가한다. | ✅ **변경됨** |
  | `pop()` | 배열의 **끝** 요소를 제거하고, 그 요소를 반환한다. | ✅ **변경됨** |
  | `unshift(item)`| 배열의 **앞**에 요소를 추가한다. | ✅ **변경됨** |
  | `shift()` | 배열의 **앞** 요소를 제거하고, 그 요소를 반환한다. | ✅ **변경됨** |
  | `splice(start, count, ...items)` | `start` 인덱스부터 `count`개만큼 요소를 **삭제/교체/추가**한다. | ✅ **변경됨** |
  | `slice(start, end)`| `start` 인덱스부터 `end` 인덱스 **전까지**의 요소를 복사하여 **새 배열로 반환**한다. | ❌ **변경 안 됨** |
  | `indexOf(item)`| `item`이 처음으로 나타나는 인덱스를 반환한다. 없으면 `-1`을 반환한다. | ❌ **변경 안 됨** |
  | `includes(item)`| `item`이 배열에 포함되어 있는지 여부를 `true`/`false`로 반환한다. | ❌ **변경 안 됨** |

* **문법 및 사용법 (How?)**:
  **1. 배열 순회**
  ```javascript
  const products = ['MacBook', 'iPad', 'iPhone'];

  // for문 (인덱스가 필요할 때 유용)
  for (let i = 0; i < products.length; i++) {
    console.log(`${i}: ${products[i]}`);
  }

  // for...of문 (값만 필요할 때 간결함)
  for (const product of products) {
    console.log(product);
  }
  ```

  **2. 메서드 활용 실무 패턴: 검색 → 확인 → 수정**
  ```javascript
  let products = ['MacBook', 'iPad', 'iPhone'];
  const targetProduct = 'iPhone';
  const newProduct = 'iPhone Pro';

  // 1. includes()로 '존재 여부' 확인
  if (products.includes(targetProduct)) {
    // 2. indexOf()로 '위치(인덱스)' 찾기
    const targetIndex = products.indexOf(targetProduct);

    // 3. splice()로 해당 위치의 요소를 '수정'
    // targetIndex에서 1개의 요소를 삭제하고, 그 자리에 newProduct를 추가
    products.splice(targetIndex, 1, newProduct);
  }

  console.log(products); // ['MacBook', 'iPad', 'iPhone Pro']
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `splice(2, 0, 'new')`와 같이 `deleteCount`를 `0`으로 설정하면, 요소를 삭제하지 않고 해당 위치에 새 요소를 **삽입**할 수 있다.
    * `slice()`는 `end` 인덱스를 생략하면 `start`부터 배열 끝까지 복사한다. `slice()`를 인자 없이 호출하면 배열 전체를 얕게 복사(shallow copy)하는 효과가 있다.
    * `indexOf()`는 찾는 요소가 없을 때 `-1`을 반환하므로, `if (arr.indexOf(item) > -1)`와 같은 형태로 존재 여부를 확인할 수 있다. 하지만 `includes()`가
      `true`/`false`를 직접 반환하므로 더 직관적이고 가독성이 좋다.

---

## 오늘의 깨달음 💡

* 배열 메서드를 개별적으로 아는 것을 넘어, **'변수를 이용한 탐색 → `includes`로 존재 여부 확인 → `indexOf`로 위치 파악 → `splice`로 수정'** 과 같은 일련의 논리적 흐름, 즉 '
  패턴'을 익히는 것이 실무적인 문제 해결 능력의 핵심임을 깨달았다.

* 단순히 메서드 목록을 암기하는 것보다, 각 메서드가 **원본 배열을 변경하는지 여부**를 명확히 구분하는 것이 훨씬 중요하다는 것을 알게 되었다. 원본을 변경하는 메서드는 의도치 않은 부작용(side
  effect)을 일으킬 수 있으므로 신중하게 사용해야 한다.

* 배열 조작은 단순히 데이터를 정리하는 기술이 아니라, 애플리케이션의 상태(state)를 관리하는 가장 기본적인 활동이다. 오늘 배운 탐색 및 수정 패턴은 나중에 더 복잡한 상태 관리 로직을 구현할 때의 기초가 될
  것임을 예감했다.