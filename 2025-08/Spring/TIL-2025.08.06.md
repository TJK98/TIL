# TIL - 2025.08.06 - Spring Security 기본 설정과 인증 API 구현 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringSecurity #Authentication #ApiDesign #ExceptionHandling

---

## 오늘 배운 내용 🔍

* Spring Security 의존성 추가 및 기본 보안 필터 체인(`SecurityFilterChain`) 설정
* 상태 비저장(Stateless) REST API를 위한 보안 옵션 비활성화 (`csrf`, `formLogin`, `httpBasic`)
* `BCryptPasswordEncoder`를 이용한 안전한 비밀번호 단방향 암호화
* 회원가입(`signup`) 및 로그인(`authenticate`) API의 처리 흐름
* `@Valid`를 이용한 요청 DTO 유효성 검증 및 전역 예외 처리 연동
* 일관된 API 응답을 위한 공통 응답(`ApiResponse`) DTO 설계 패턴

---

## 어려웠던 점 💣

* `disable()`을 반복 호출하는 것이 보안을 약화시키는 것처럼 보여 혼란스러웠다. 실제로는 세션 기반 기능을 제거하고 토큰 기반 보안을 준비하기 위한 과정이었다.

* `BCrypt`가 매번 다른 결과를 생성하기 때문에 단순 `encode().equals()` 비교가 불가능했다. `matches()` 메서드를 사용해야 한다는 점을 이해하는 데 시간이 걸렸다.

* `ErrorCode` Enum을 통한 예외 관리가 과한 설계처럼 느껴졌다. 하지만 클라이언트 입장에서 일관된 응답을 받을 수 있다는 점에서 필요성을 깨달았다.

* `@Valid` 검증 실패 시 발생하는 예외를 전역적으로 처리하는 방법이 처음에는 이해되지 않았다. `GlobalExceptionHandler`에서 `MethodArgumentNotValidException`을 처리하여 일관된 오류 응답을 제공한다는 점을 확인했다.

---

## 정리 🖇️

### 1. Spring Security 기본 설정

REST API 환경에 맞는 보안 구성을 위해 전통적인 세션 기반 기능을 비활성화한다.

* **학습 목표 (Why?)**
  세션을 사용하지 않고 토큰 기반 인증에 적합한 보안 구성을 적용하기 위함이다.

* **핵심 원리 (What?)**

  * `@EnableWebSecurity`: 보안 설정 활성화.
  * `SecurityFilterChain`: 요청에 대한 보안 처리를 정의.
  * 주요 비활성화 항목:

    * `.csrf(AbstractHttpConfigurer::disable)`
    * `.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`
    * `.formLogin(AbstractHttpConfigurer::disable)`
    * `.httpBasic(AbstractHttpConfigurer::disable)`

* **문법 및 사용법 (How?)**
  `SecurityConfig` 클래스에 `SecurityFilterChain` 빈을 등록한다.

* **주의사항 및 실무 팁 (Watch out for)**

  * 이 단계는 기본 뼈대를 만드는 과정이며, 인가 규칙이나 JWT 필터는 이후 추가해야 한다.
  * 운영 환경에서는 반드시 CORS 정책을 세밀하게 설정해야 한다.

---

### 2. 비밀번호 암호화 (`BCryptPasswordEncoder`)

비밀번호를 안전하게 단방향 암호화하여 저장한다.

* **학습 목표 (Why?)**
  DB 유출 시에도 비밀번호가 노출되지 않도록 보호하기 위함이다.

* **핵심 원리 (What?)**

  * 단방향 해시 함수: 복호화 불가.
  * `BCrypt`: Salt와 Key Stretching을 포함하는 표준 해시 알고리즘.
  * `PasswordEncoder` 인터페이스: `encode()`, `matches()` 제공.

* **문법 및 사용법 (How?)**
  `PasswordEncoder` 빈을 등록하고 서비스 계층에서 주입받아 사용한다.

* **주의사항 및 실무 팁 (Watch out for)**

  * 절대 `encode().equals()` 방식으로 비교하지 말고, `matches()` 메서드를 사용해야 한다.

---

### 3. 인증 API 흐름과 DTO 설계

회원가입 및 로그인 요청을 처리하는 전체 구조를 학습했다.

* **학습 목표 (Why?)**
  요청 → 검증 → 처리 → 응답의 일관된 API 파이프라인을 구성하기 위함이다.

* **핵심 원리 (What?)**

  * 요청 DTO: 클라이언트 입력을 검증 (`@Valid`).
  * 응답 DTO: 민감 정보 제외 후 반환.
  * `ApiResponse`: 모든 응답을 공통 포맷으로 감싸 전달.

* **문법 및 사용법 (How?)**
  Controller → Service → Repository 흐름으로 요청을 처리한다. 응답은 `ApiResponse`를 통해 래핑한다.

* **주의사항 및 실무 팁 (Watch out for)**

  * 로그인은 반드시 POST 방식으로 처리해야 한다.
  * JWT 발급 로직은 로그인 성공 후 별도로 추가해야 한다.

---

## 오늘의 깨달음 💡

* Security 설정에서 `disable()`은 기능 제거가 아니라 토큰 기반 인증을 위한 준비 단계라는 점을 알게 되었다.

* 비밀번호 암호화에서는 `matches()` 사용이 필수적이다. 같은 입력값이라도 결과가 달라지므로 단순 비교는 불가능하다.

* `ErrorCode` Enum은 클라이언트와의 약속된 규격을 제공하여 유지보수성과 확장성을 높인다.

* `ApiResponse`는 일관된 응답 구조를 제공하여 클라이언트 개발을 단순화한다.