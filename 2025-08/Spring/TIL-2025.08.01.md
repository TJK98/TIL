# TIL - 2025.08.01 - QueryDSL 고급 기능: 조인(Join), 그룹화(Grouping), 프로젝션(Projection) 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #QueryDSL #Join #GroupBy #Projection

---

## 오늘 배운 내용 🔍

- `groupBy`와 `having`을 이용한 데이터 그룹화 및 그룹 조건 필터링
- `CaseBuilder`를 활용한 동적인 조건부 그룹화 (e.g., 연령대별 통계)
- `innerJoin`, `leftJoin`을 이용한 엔티티 간의 조인 처리
- N+1 문제 해결을 위한 Fetch Join과 일반 Join의 동작 차이
- 조회 결과를 특정 DTO로 직접 매핑하는 프로젝션(`Projections`) 기능
- `@ManyToMany`를 대체하는 연결 엔티티를 QueryDSL로 조인하는 방법

---

## 어려웠던 점 💣

* **조인 대상 지정 문법**: `join(member.team, team)` 처럼, 시작 엔티티의 연관 필드를 첫 번째 인자로 명시해야 하는 이유가 혼란스러웠다. 이는 두 엔티티 간의 어떤 관계(FK)를 기반으로
  조인할지 명시적으로 알려주기 위함임을 알게 되었다.

* **`join`과 `fetchJoin`의 차이**: 두 메서드 모두 SQL의 `JOIN`을 생성해주는데, 왜 `fetchJoin`이라는 별도의 기능이 필요한지 의문이었다. 일반 `join`은 테이블 연결 및
  필터링 용도일 뿐 N+1 문제를 해결하지 못했고, `fetchJoin`은 연관된 엔티티 컬렉션을 실제 데이터로 함께 조회하여 성능을 최적화하는 특화된 기능임을 구분해야 했다.

* **`Tuple` 타입의 불편함**: 여러 컬럼을 조회할 때마다 결과가 `Tuple`로 반환되어, `Tuple`에서 값을 꺼내 DTO에 다시 매핑하는 과정이 번거롭게 느껴졌다.
  `Projections.constructor()`를 사용하면 쿼리 실행과 동시에 DTO 객체로 바로 변환해주는 것을 알게 되었다.

* **`groupBy`와 `where`의 실행 순서**: 그룹화된 결과에 조건을 거는 `having` 절의 역할이 `where` 절과 비슷해 보였다. `where`는 그룹화 이전의 개별 로우를 필터링하고,
  `having`은 그룹화가 완료된 후의 그룹 자체를 필터링한다는 실행 순서의 차이를 이해해야 했다.

---

## 정리 🖇️

### 1. 그룹화(groupBy)와 집계(Aggregation)

개별 데이터가 아닌, 특정 기준에 따라 그룹화된 데이터의 통계적 정보를 조회하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단순 조회를 넘어, "팀별 평균 연령", "성별 인원수" 등과 같이 데이터를 요약하고 분석하여 의미 있는 정보를 얻기 위함이다.

* **핵심 원리 (What?)**:
    * `groupBy(그룹화_기준)`: 특정 필드를 기준으로 데이터를 그룹으로 묶는다.
    * **집계 함수**: `groupBy`와 함께 사용되어 각 그룹에 대한 계산을 수행한다. (`count()`, `sum()`, `avg()`, `max()`, `min()`)
    * `having(그룹_조건)`: `groupBy`로 생성된 그룹들 중에서 특정 조건을 만족하는 그룹만 필터링한다.
    * `CaseBuilder`: SQL의 `CASE WHEN` 구문을 코드로 표현. 복잡한 조건에 따라 값을 동적으로 할당하거나 그룹화 기준을 만들 때 사용한다.

* **문법 및 사용법 (How?)**: 연령대(10대, 20대 등)별로 그룹화하고, 해당 연령대에 속한 멤버가 2명 이상인 그룹의 연령대와 인원수를 조회한다.
  ```java
  import static com.example.project.entity.QMember.member;

  // CaseBuilder로 동적 그룹화 기준 생성 (연령대)
  NumberExpression<Integer> ageGroup = new CaseBuilder()
          .when(member.age.between(10, 19)).then(10)
          .when(member.age.between(20, 29)).then(20)
          .otherwise(0);

  // groupBy와 having을 사용한 쿼리
  List<Tuple> result = factory
          .select(ageGroup, member.count())
          .from(member)
          .groupBy(ageGroup) // 연령대 기준으로 그룹화
          .having(member.count().goe(2)) // 그룹 인원이 2명 이상인 그룹만 필터링
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `having` 절에는 집계 함수를 포함한 조건만 사용할 수 있다. 일반 필드 조건은 `where` 절에 작성해야 한다.

---

### 2. 조인(JOIN)과 성능 최적화(Fetch Join)

서로 다른 엔티티에 흩어져 있는 데이터를 연관 관계를 기반으로 함께 조회하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  정규화된 테이블 구조에서 필요한 데이터를 가져오기 위해 여러 테이블을 연결하고, N+1 같은 성능 문제를 방지하여 효율적인 쿼리를 작성하기 위함이다.

* **핵심 원리 (What?)**:
  | 구분 | 일반 조인 (`innerJoin`, `leftJoin`) | 페치 조인 (`fetchJoin`) |
  | :--- | :--- | :--- |
  | **목적** | 테이블 연결을 통한 **필터링(WHERE) 또는 프로젝션(SELECT)** | 연관 엔티티의 **즉시 로딩**을 통한 성능 최적화 |
  | **N+1 해결**| ❌ 해결하지 못함 (연관 컬렉션은 여전히 LAZY 로딩) | ✅ 해결함 (연관 컬렉션을 실제 데이터로 함께 조회) |

* **문법 및 사용법 (How?)**:
  ```java
  import static com.example.project.entity.QMember.member;
  import static com.example.project.entity.QTeam.team;

  // 2022년에 앨범을 발매한 팀에 소속된 모든 멤버 정보 조회
  List<Member> members = factory
          .select(member)
          .from(member)
          .innerJoin(member.team, team).fetchJoin() // Member와 Team을 페치 조인
          .where(team.name.eq("IVE"))
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * **일반 조인 vs. 페치 조인**: 필터링 조건으로만 사용하려면 일반 조인, 연관된 엔티티 데이터를 실제로 함께 로딩하여 N+1 문제를 해결하려면 페치 조인을 사용한다.
    * `fetchJoin`과 `groupBy`는 하나의 쿼리에서 함께 사용할 수 없다. 전자는 엔티티 그래프 전체 조회가 목적이고, 후자는 데이터 요약이 목적이므로 서로 충돌한다.

---

### 3. 프로젝션(Projection)과 DTO 활용

조회 결과를 엔티티가 아닌, 원하는 형태의 DTO(Data Transfer Object)로 직접 받아오는 방법을 학습했다.

* **학습 목표 (Why?)**:
  API 응답에 필요한 데이터만 선별적으로 조회하여 네트워크 트래픽을 줄이고, `Tuple` 같은 범용 타입 대신 명확한 타입의 DTO를 사용함으로써 코드의 가독성과 유지보수성을 높이기 위함이다.

* **핵심 원리 (What?)**:
    * **프로젝션(Projection)**: DB에서 조회한 결과를 특정 객체(엔티티 또는 DTO)에 매핑하는 과정.
    * **`Projections`**: QueryDSL이 제공하는 프로젝션용 팩토리 클래스.
        * `Projections.constructor(DTO.class, ...)`: DTO의 생성자를 호출하여 객체를 생성. `select` 절의 필드 순서와 타입이 DTO 생성자 파라미터와 일치해야
          한다.
        * `Projections.bean(DTO.class, ...)`: DTO의 세터(setter)를 이용해 값을 주입.
        * `Projections.fields(DTO.class, ...)`: DTO의 필드에 직접 값을 주입 (리플렉션 사용).

* **문법 및 사용법 (How?)**:
  ```java
  // Tuple로 조회 후 Stream으로 변환하는 방식보다 Projections 사용이 더 간결하고 효율적
  List<TeamAverageAgeDto> result = factory
      .select(Projections.constructor(
          TeamAverageAge-Dto.class,
          team.name,
          member.age.avg()
      ))
      .from(member)
      .join(member.team, team)
      .groupBy(team.name)
      .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
    * `Projections.constructor`를 사용하려면 DTO에 조회할 컬럼의 타입과 순서가 일치하는 생성자가 반드시 존재해야 한다.
    * `record` 타입을 DTO로 활용하면 보일러플레이트 코드 없이 간결하게 프로젝션을 구현할 수 있다.

---

## 오늘의 깨달음 💡

* QueryDSL의 `join` 메서드는 `join(member.team, team)`과 같이 시작 엔티티의 연관 필드를 명시함으로써 어떤 관계를 기반으로 조인할지 명확하게 지정해야 한다.

* `join`과 `fetchJoin`은 목적이 다르다. `join`은 쿼리의 조건절이나 선택절에서 다른 테이블을 활용하기 위한 것이고, `fetchJoin`은 N+1 문제를 해결하기 위해 연관된 엔티티 데이터를
  함께 로딩하는 성능 최적화 기능이다.

* `where` 절은 그룹화 이전의 개별 데이터를 필터링하고, `having` 절은 그룹화 이후의 집계 결과를 필터링하는 역할을 한다.

* `Projections`를 사용하면 조회 결과를 `Tuple`이 아닌 DTO 객체로 직접 매핑할 수 있어, `stream().map()`을 이용한 수동 변환 과정 없이 더 간결하고 효율적인 코드를 작성할 수
  있다.

* `fetchJoin`은 엔티티 그래프 전체 조회가 목적이고, `groupBy`는 데이터 요약이 목적이므로 두 기능은 하나의 쿼리에서 함께 사용할 수 없다.