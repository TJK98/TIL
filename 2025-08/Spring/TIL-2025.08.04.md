# TIL - 2025.08.04 - QueryDSL 심화: 서브쿼리와 동적 쿼리 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #JPA #QueryDSL #Subquery #DynamicQuery #CustomRepository

---

## 오늘 배운 내용 🔍

- `JPAExpressions`를 이용한 서브쿼리 작성법 (WHERE, SELECT, EXISTS)
- 서브쿼리 내에서 별칭(alias) 충돌을 피하기 위한 `Q-Type`의 새로운 인스턴스 생성
- 사용자 입력에 따라 쿼리 조건을 유연하게 조합하는 동적 쿼리(Dynamic Query)
- `BooleanBuilder`를 활용한 동적 `WHERE` 절 구성 방법
- `OrderSpecifier`와 `switch`문을 이용한 동적 `ORDER BY` 절 구현
- 복잡한 QueryDSL 로직을 분리하기 위한 커스텀 Repository 패턴 (`...Custom`, `...Impl`)

---

## 어려웠던 점 💣

* **서브쿼리 내 Q-Type 인스턴스화**: `QAlbum subAlbum = new QAlbum("subAlbum");` 처럼, 서브쿼리를 작성할 때 Q-Type의 새 인스턴스를 만드는 이유가 궁금했다. 메인 쿼리와 서브쿼리에서 동일한 엔티티를 참조할 때 별칭(alias) 충돌을 피하기 위한 필수적인 과정임을 이해했다.

* **`BooleanBuilder`의 사용 시점**: 단순한 검색 조건에서는 `BooleanBuilder` 객체를 만들고 `if`문으로 조건을 추가하는 방식이 더 번거롭게 느껴졌다. 하지만 검색 필터가 많아지고 조건이 `null`일 수 있는 복잡한 상황에서는, `if-else`와 문자열 조합보다 체계적이고 안전한 방법임을 알게 되었다.

* **동적 정렬 구현**: 동적 `WHERE` 절과 달리, 정렬 기준(`sortBy`)과 순서(`ascending`)가 파라미터로 넘어올 때 `orderBy`를 어떻게 동적으로 처리해야 할지 막막했다. `OrderSpecifier` 타입을 사용하고 헬퍼 메서드를 통해 정렬 조건을 동적으로 생성하여 전달하는 패턴을 학습해야 했다.

* **커스텀 Repository 패턴**: `GroupRepository`가 `JpaRepository`와 `GroupRepositoryCustom`을 동시에 상속받는 구조가 낯설었다. 이는 Spring Data JPA의 기본 CRUD 기능과 QueryDSL을 사용한 복잡한 쿼리 로직을 분리하기 위한 설계 패턴이며, 역할 분리를 통해 유지보수성을 높일 수 있음을 알게 되었다.

---

## 정리 🖇️

### 1. 서브쿼리(Subquery) 작성법

쿼리 내부에 또 다른 쿼리를 포함시켜, 복잡한 조건이나 계산된 값을 기반으로 데이터를 조회하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  단일 쿼리만으로는 해결하기 어려운 복합적인 데이터 조회 요구사항을 충족시키기 위함이다. 예를 들어, "팀 평균 연령보다 나이가 많은 멤버"처럼, 한 번의 계산 결과가 다른 쿼리의 조건이 되어야 할 때 사용된다.

* **핵심 원리 (What?)**:
  *   **`JPAExpressions`**: QueryDSL에서 서브쿼리를 생성하는 진입점. `JPAExpressions.select(...)` 형태로 사용된다.
  *   **서브쿼리의 위치**: `WHERE` 절과 `SELECT` 절에서 사용 가능하나, JPA 표준과 QueryDSL에서는 `FROM` 절 서브쿼리를 지원하지 않는다.
  *   **Q-Type Alias**: 서브쿼리 내에서 메인 쿼리와 동일한 엔티티를 참조할 경우, 별칭(alias) 충돌을 피하기 위해 `QMember subMember = new QMember("subMember");` 처럼 새로운 Q-Type 인스턴스를 생성하여 사용해야 한다.

* **문법 및 사용법 (How?)**:
  ```java
  import static com.example.project.entity.QMember.member;
    
  // 예제: WHERE 절 서브쿼리 - 평균 나이보다 많은 멤버 조회
  JPQLQuery<Double> avgAge = JPAExpressions
          .select(member.age.avg())
          .from(member);

  List<Member> olderMembers = factory
          .selectFrom(member)
          .where(member.age.gt(avgAge))
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
  *   `FROM` 절 서브쿼리가 필요한 경우, `Native Query`를 사용하거나 쿼리를 여러 번 실행하여 애플리케이션단에서 조합해야 한다.
  *   상관 서브쿼리는 메인 쿼리의 각 행마다 실행되므로, 데이터 양이 많을 경우 성능 저하를 유발할 수 있다. 가능한 JOIN으로 해결하는 것이 좋다.

---

### 2. 동적 쿼리(Dynamic Query) 작성법

사용자의 입력이나 특정 조건에 따라 `WHERE` 또는 `ORDER BY` 절이 동적으로 변경되는 쿼리를 생성하는 방법을 학습했다.

* **학습 목표 (Why?)**:
  다양한 검색 조건(일부는 `null`일 수 있음)을 처리하기 위해 수많은 `if-else` 분기문과 문자열 조합으로 쿼리를 생성하는 비효율적이고 오류 발생 가능성이 높은 방식을 피하기 위함이다.

* **핵심 원리 (What?)**:
  *   **`BooleanBuilder`**: `Predicate`(쿼리 조건)들을 담는 컨테이너. `if`문과 함께 사용하여 `null`이 아닌 조건만 동적으로 `and()` 또는 `or()` 메서드를 통해 추가할 수 있다.
  *   **`OrderSpecifier`**: 정렬 조건을 표현하는 타입. 동적 정렬을 구현할 때, 이 타입의 변수에 조건부로 정렬 객체를 할당하여 `orderBy()`에 전달한다.

* **문법 및 사용법 (How?)**:
  ```java
  // 검색 조건 파라미터
  String category = "전자제품";
  Double minPrice = 500.0;

  // 1. BooleanBuilder 생성
  BooleanBuilder builder = new BooleanBuilder();

  // 2. 조건이 null이 아닐 경우 builder에 추가
  if (category != null) {
      builder.and(product.category.eq(category));
  }
  if (minPrice != null) {
      builder.and(product.price.goe(minPrice));
  }

  // 3. 생성된 builder를 where 절에 전달
  List<Product> products = factory
          .selectFrom(product)
          .where(builder)
          .fetch();
  ```

* **주의사항 및 실무 팁 (Watch out for)**:
  *   `BooleanBuilder` 외에도 `where` 절에 `BooleanExpression`을 반환하는 메서드를 여러 개 나열하는 방식도 많이 사용된다. 이 방법은 메서드 단위로 조건을 재사용할 수 있어 더 유연하다.

---

### 3. 커스텀 Repository와 QueryDSL 통합

Spring Data JPA의 기본 기능과 QueryDSL의 복잡한 쿼리 작성 기능을 분리하여 관리하는 실무적인 설계 패턴을 학습했다.

* **학습 목표 (Why?)**:
  `JpaRepository` 인터페이스는 단순 CRUD와 Query Method를 위해 깔끔하게 유지하고, 복잡하고 긴 QueryDSL 코드는 별도의 클래스로 분리하여 코드의 가독성, 재사용성, 테스트 용이성을 높이기 위함이다.

* **핵심 원리 (What?)**:
  1.  **커스텀 인터페이스 생성 (`...Custom`)**: QueryDSL로 구현할 메서드를 선언한다.
  2.  **메인 Repository 상속**: 기존 Repository가 `JpaRepository`와 함께 `...Custom`을 상속받도록 한다.
  3.  **구현 클래스 생성 (`...Impl`)**: `...Custom`을 구현하는 클래스를 만든다. 클래스 이름은 반드시 **`...Impl`**로 끝나야 Spring Data JPA가 자동으로 인식한다.
  4.  **구현체에 `JPAQueryFactory` 주입**: `@RequiredArgsConstructor`와 `final` 필드를 통해 `JPAQueryFactory`를 주입받아 실제 QueryDSL 로직을 작성한다.

* **문법 및 사용법 (How?)**:
  ```java
  // 1. 커스텀 인터페이스
  public interface TeamRepositoryCustom {
      List<TeamDto> findTeamDtos();
  }
    
  // 2. 메인 Repository
  public interface TeamRepository extends JpaRepository<Team, Long>, TeamRepositoryCustom {
  }

  // 3. 구현 클래스
  @RequiredArgsConstructor
  public class TeamRepositoryImpl implements TeamRepositoryCustom {
      private final JPAQueryFactory factory;

      @Override
      public List<TeamDto> findTeamDtos() {
          // ... QueryDSL 로직 구현 ...
      }
  }
  ```

---

## 오늘의 깨달음 💡

* QueryDSL은 자바 코드를 통해 SQL을 작성함으로써, 문자열 기반 쿼리에서 발생할 수 있는 런타임 오류를 컴파일 시점에 방지하는 타입 안정성을 제공한다.

* 서브쿼리 작성 시, 메인 쿼리와의 별칭 충돌을 피하기 위해 새로운 Q-Type 인스턴스를 생성해야 한다.

* `BooleanBuilder`는 여러 개의 동적 검색 조건들을 `if`문과 조합하여 체계적이고 안전하게 쿼리를 구성할 수 있게 해준다.

* 동적 정렬은 `OrderSpecifier` 타입과 `switch` 문 또는 헬퍼 메서드를 활용하여 구현할 수 있다.

* `JpaRepository`의 기본 기능과 QueryDSL의 복잡한 조회 로직은 커스텀 Repository 패턴을 통해 분리하여 관리하는 것이 유지보수성과 코드 가독성 측면에서 효과적이다.