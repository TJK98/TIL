# TIL - 2025.08.13 - Spring Security JWT 필터와 인가(Authorization) 처리 개념 이해

## 카테고리 🏷️

#TIL #Spring #SpringSecurity #JWT #Authorization #Filter

---

## 오늘 배운 내용 🔍

* JWT 토큰의 유효성을 검증하는 `JwtAuthenticationFilter`의 역할과 동작 원리
* Spring Security의 `SecurityFilterChain`에 커스텀 필터를 등록하는 방법 (`addFilterBefore`)
* `SecurityContextHolder`를 이용한 인증 정보 관리 및 스레드 로컬(ThreadLocal) 개념
* `authorizeHttpRequests`를 통한 URL 패턴별 접근 제어(인가) 규칙 설정
* `@AuthenticationPrincipal`을 사용하여 컨트롤러에서 인증된 사용자 정보 주입받기
* 인증된 사용자와 연관된 리소스(e.g., `Trip`)를 생성하는 비즈니스 로직 구현
* 프론트엔드에서 API 요청 시 필요한 인증 상태를 관리하고, 페이지별 접근 제어 구현

---

## 어려웠던 점 💣

* `@AuthenticationPrincipal`이 어떻게 현재 로그인한 사용자의 이름을 가져오는지 원리가 처음에는 명확하지 않았다. `JwtAuthenticationFilter`에서 토큰 검증 성공 후 `SecurityContextHolder`에 인증 객체를 저장하기 때문에 컨트롤러에서 이를 직접 꺼내 쓸 수 있다는 점을 확인했다.

* Spring의 `Filter`와 `Interceptor`의 차이점이 헷갈렸다. 보안 관련 검증은 Dispatcher Servlet에 도달하기 전 모든 요청에 대해 수행되어야 하므로 `Filter`가 적합하다는 것을 알게 되었다. 반면, `Interceptor`는 컨트롤러 호출 전후의 로직에 활용된다.

* JPA에서 `trip.setUser(user)`처럼 엔티티 전체를 전달해야 하는 부분이 어색했다. 이는 JPA가 객체 그래프를 관리하기 때문이며, 내부적으로 FK를 처리해준다는 것을 이해했다.

* 클라이언트 측 검증과 서버 측 검증이 중복된 것처럼 보여 혼란스러웠다. 클라이언트 검증은 UX 목적이고, 서버 검증은 데이터 무결성 보장을 위한 최종 방어선이라는 점에서 모두 필요했다.

---

## 정리 🖇️

### 1. JWT 인증 필터와 Security Context

* **학습 목표 (Why?)**
  로그인 이후 요청이 인증된 사용자에 의해 수행되었는지 확인하여 보안을 강화하기 위함이다.

* **핵심 원리 (What?)**

  * `JwtAuthenticationFilter`: `OncePerRequestFilter`를 상속하여 모든 요청마다 한 번 실행된다.
  * 주요 흐름:

    1. 헤더에서 JWT 추출
    2. 토큰 검증
    3. 사용자명 추출
    4. `SecurityContextHolder`에 인증 정보 등록

* **문법 및 사용법 (How?)**

  ```java
  UsernamePasswordAuthenticationToken auth =
      new UsernamePasswordAuthenticationToken(username, null, new ArrayList<>());
  SecurityContextHolder.getContext().setAuthentication(auth);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 인증 객체 생성 시 `principal`에는 사용자 식별자, `credentials`에는 보통 null, `authorities`에는 권한 목록을 담는다.
  * `ThreadLocal`을 사용하므로 요청별로 인증 정보가 분리된다.

---

### 2. 인가(Authorization) 설정과 @AuthenticationPrincipal

* **학습 목표 (Why?)**
  URL 접근을 사용자 인증 여부와 권한에 따라 제어하기 위함이다.

* **핵심 원리 (What?)**

  * `authorizeHttpRequests`: URL 패턴별 접근 권한 설정
  * `addFilterBefore`: JWT 필터를 기본 인증 필터 앞에 등록
  * `@AuthenticationPrincipal`: `SecurityContext`에 저장된 사용자 정보를 컨트롤러 파라미터에 주입

* **문법 및 사용법 (How?)**

  ```java
  .authorizeHttpRequests(auth -> auth
      .requestMatchers("/api/auth/**").permitAll()
      .requestMatchers("/api/**").authenticated()
      .anyRequest().authenticated()
  )
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 경로 규칙은 위에서부터 적용되므로 구체적인 경로를 먼저 배치해야 한다.
  * 컨트롤러에서 `SecurityContextHolder` 직접 접근 대신 `@AuthenticationPrincipal`을 활용하는 것이 더 단순하고 테스트 가능하다.

---

### 3. 인증 기반 비즈니스 로직과 DTO 설계

* **학습 목표 (Why?)**
  요청 사용자를 식별하여 개인화된 데이터를 생성 및 조회하기 위함이다.

* **핵심 원리 (What?)**

  * 컨트롤러에서 전달받은 `username`으로 `User` 엔티티를 조회한다.
  * JPA는 엔티티 전체 참조를 기반으로 연관 관계를 관리한다.
  * DTO는 요청/응답/검색 용도로 역할을 분리한다.

* **문법 및 사용법 (How?)**

  ```java
  Trip trip = Trip.builder()
      .title(request.getTitle())
      .user(foundUser)
      .build();
  tripRepository.save(trip);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 서비스 계층에 `@Transactional`을 붙여 데이터 일관성을 보장한다.

---

## 오늘의 깨달음 💡

* JWT 인증 필터는 인증 흐름의 핵심이며, 모든 요청에서 보안을 일관되게 보장한다는 점을 확인했다.

* `@AuthenticationPrincipal`을 사용하면 인증 정보를 더 단순하게 활용할 수 있고, 코드의 의존성이 줄어든다.

* URL 접근 제어 규칙을 명확히 정의함으로써 서비스 보안 수준을 체계적으로 높일 수 있다.

* 엔티티 내부에 비즈니스 메서드를 두면 응집도가 높아지고 객체지향적인 설계가 가능해진다.