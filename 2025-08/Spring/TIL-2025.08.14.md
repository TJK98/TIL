# TIL - 2025.08.14 - JPA 다대다 관계 매핑과 파일 업로드 구현 개념 이해

## 카테고리 🏷️

#TIL #Spring #JPA #ManyToMany #FileUpload #Multipart #JavaScript

---

## 오늘 배운 내용 🔍

* JPA에서 다대다(M\:N) 관계를 연결 엔티티(`TravelLogTag`)를 통해 구현하는 방법
* Spring Boot에서의 파일 업로드 처리 흐름 (로컬 저장 및 메타데이터 DB 관리)
* `multipart/form-data` 요청을 `@RequestPart` 애노테이션으로 처리하는 방법
* 외부 경로의 정적 리소스(업로드된 파일)를 웹에서 접근 가능하게 설정 (`WebMvcConfigurer`)
* JavaScript를 이용한 복잡한 폼 UI 처리 (이미지 썸네일 미리보기, 태그 시스템, 드래그 앤 드롭 정렬)
* JPA 엔티티 내 비즈니스 로직(편의 메서드)의 역할과 중요성

---

## 어려웠던 점 💣

* 다대다 관계를 위한 연결 엔티티의 PK를 복합 키로 할지, 독립적인 대리 키로 할지 혼란스러웠다. 실무에서는 관리 용이성 때문에 비식별 관계 방식이 더 많이 쓰인다는 점을 알게 되었다.

* JSON과 파일을 동시에 처리하는 방법이 낯설었다. `@RequestBody`가 아닌 `@RequestPart`를 사용해야 한다는 점을 학습했다.

* 로컬 경로와 웹 접근 경로가 다르다는 점을 명확히 이해하는 데 시간이 걸렸다. `WebMvcConfigurer`에서 매핑 설정을 반드시 해야 웹에서 접근 가능했다.

* 프론트엔드에서 여러 파일 썸네일 미리보기와 순서 변경 UI를 구현하는 과정이 까다로웠다. `File` 객체와 이벤트 흐름에 대한 깊은 이해가 필요했다.

---

## 정리 🖇️

### 1. 연결 엔티티를 통한 다대다(M\:N) 관계 매핑

* **학습 목표 (Why?)**
  `@ManyToMany`의 한계를 극복하고 유연한 관계를 설계하기 위함이다.

* **핵심 원리 (What?)**

  * 연결 엔티티(`TravelLogTag`)를 둬서 다대다를 1\:N-N:1 관계로 풀어낸다.
  * 비식별 관계 방식을 사용하면 관리가 유연하고 실무에서 선호된다.

* **문법 및 사용법 (How?)**

  ```java
  @Entity
  public class TravelLogTag {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "travel_log_id")
      private TravelLog travelLog;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "tag_id")
      private Tag tag;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  `addTag(Tag tag)` 같은 편의 메서드를 두면 서비스 로직이 단순해지고 응집도가 높아진다.

---

### 2. Spring Boot 파일 업로드 처리

* **학습 목표 (Why?)**
  파일 시스템과 DB의 책임을 분리하여 효율적으로 관리하기 위함이다.

* **핵심 원리 (What?)**

  * 실제 파일은 로컬 경로나 클라우드 스토리지에 저장한다.
  * DB에는 파일 경로와 메타데이터만 저장한다.

* **문법 및 사용법 (How?)**

  ```java
  String storedFileName = UUID.randomUUID() + ".jpg";
  Path target = userBasePath.resolve(storedFileName);
  Files.copy(file.getInputStream(), target);

  TravelPhoto photo = TravelPhoto.builder()
      .filePath("/uploads/" + username + "/" + storedFileName)
      .build();
  travelPhotoRepository.save(photo);
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  운영 환경에서는 AWS S3 같은 클라우드 스토리지를 사용하는 것이 바람직하다.

---

### 3. @RequestPart를 이용한 Multipart 요청 처리

* **학습 목표 (Why?)**
  JSON과 파일을 하나의 요청으로 처리하여 효율성을 높이기 위함이다.

* **핵심 원리 (What?)**

  * `@RequestBody`는 multipart를 처리할 수 없다.
  * `@RequestPart`는 각 파트를 개별적으로 바인딩한다.

* **문법 및 사용법 (How?)**

  ```javascript
  const formData = new FormData();
  formData.append('data', new Blob([JSON.stringify(payload)], { type: 'application/json' }));
  images.forEach(img => formData.append('files', img.file));
  ```

  ```java
  @PostMapping
  public ResponseEntity<?> createTravelLogs(
      @RequestParam Long tripId,
      @RequestPart(name = "data") @Valid TravelLogRequestDto requestDto,
      @RequestPart(name = "files") List<MultipartFile> files
  ) { ... }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  `@RequestPart`의 `name`은 프론트엔드의 `FormData.append()` 키와 반드시 일치해야 한다.

---

### 4. 프론트엔드 파일 업로드 UI 처리

* **학습 목표 (Why?)**
  파일 업로드 UI에서 사용자 경험을 높이고, 여러 파일을 직관적으로 관리할 수 있도록 하기 위함이다.

* **핵심 원리 (What?)**

  * `File` 객체와 `URL.createObjectURL`을 활용해 미리보기를 구현한다.
  * `draggable` 속성과 `drag` 이벤트를 활용해 순서 변경을 처리한다.
  * 선택된 파일과 태그 등은 상태(state) 객체에 일관되게 저장하고, 상태 변경 시 UI를 재렌더링한다.

* **문법 및 사용법 (How?)**

  ```javascript
  fileInput.addEventListener('change', e => {
    const files = e.target.files;
    files.forEach(file => {
      const preview = document.createElement('img');
      preview.src = URL.createObjectURL(file);
      preview.draggable = true;
      container.appendChild(preview);
    });
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  상태 관리 로직을 명확히 분리하지 않으면 DOM 조작이 복잡해지고 오류가 발생하기 쉽다. React나 Vue 같은 프레임워크에서는 상태 관리와 렌더링을 자동화해주므로 더 안정적으로 구현할 수 있다.

---

## 오늘의 깨달음 💡

* 다대다 관계는 단순히 `@ManyToMany`로 해결하지 않고 연결 엔티티를 통해 풀어내는 것이 더 나은 설계 방식이다.

* 파일 업로드는 DB와 파일 시스템의 책임을 분리해야 한다는 원칙을 체득했다.

* `@RequestPart`는 JSON과 파일을 동시에 다루는 상황에서 필수적인 기능임을 확인했다.

* 프론트엔드 UI는 상태 관리가 핵심이라는 점을 다시 한 번 깨달았다.