# TIL - 2025.08.12 - QueryDSL을 이용한 동적 쿼리 및 페이징 구현 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringDataJPA #QueryDSL #DynamicQuery #Pagination #RepositoryPattern #DTO #Enum

---

## 오늘 배운 내용 🔍

* QueryDSL을 이용한 동적 `WHERE` 절 구현 (`BooleanBuilder`, 검색 조건 DTO)
* QueryDSL을 이용한 동적 `ORDER BY` 절 구현 (`OrderSpecifier`, 헬퍼 메서드)
* Spring Data JPA `Pageable`과 QueryDSL을 통합한 페이징 처리 (`PageImpl`)
* JPA 기본 기능과 복잡한 조회 로직을 분리하는 커스텀 Repository 설계 패턴
* 엔티티 내 비즈니스 로직 포함 방식 (`getDuration`, `isOngoing`)
* `Enum` 기반 상태 관리 (`TripStatus`)

---

## 어려웠던 점 💣

* `TripRepository`, `TripRepositoryCustom`, `TripRepositoryImpl`로 나뉘는 구조가 처음에는 과하다고 느껴졌다. 역할 분리를 통한 응집도·가독성 향상이라는 목적을 확인하고 수용했다.

* 문자열 파라미터(`sortBy`)를 QueryDSL 정렬 객체로 변환하는 방법이 막막했다. `OrderSpecifier`를 반환하는 헬퍼 메서드로 해결했다.

* `Page`가 내부적으로 어떻게 구성되는지 궁금했다. 콘텐츠 조회 쿼리와 별도의 전체 카운트 쿼리를 합쳐 `PageImpl`로 만든다는 점을 코드로 확인했다.

* `TripSearchCondition`을 커스텀 인터페이스 내부 static 클래스로 둔 이유가 낯설었다. 해당 Repository 맥락에 강하게 결합된 조건 모델을 응집시키려는 선택임을 이해했다.

---

## 정리 🖇️

### 1. 커스텀 Repository 설계 패턴

Spring Data JPA 기본 기능과 복잡한 QueryDSL 로직을 분리해 유지보수성과 테스트 용이성을 확보한다.

* **학습 목표 (Why?)**
  CRUD/Query Method는 간결하게 유지하고, 동적 쿼리·페이징처럼 복잡한 로직은 별도 구현 클래스로 분리해 책임을 명확히 한다.

* **핵심 원리 (What?)**

  1. `TripRepositoryCustom`에 복잡 쿼리 시그니처 선언
  2. `TripRepository`가 `JpaRepository`와 `TripRepositoryCustom`을 동시 상속
  3. `TripRepositoryImpl`에서 실제 QueryDSL 로직 구현 (`...Impl` 접미사 규칙)

* **문법 및 사용법 (How?)**

  ```java
  public interface TripRepositoryCustom {
    Page<Trip> findTripsByUser(User user, TripSearchCondition condition, Pageable pageable);
  }

  public interface TripRepository extends JpaRepository<Trip, Long>, TripRepositoryCustom {
  }

  @Repository
  @RequiredArgsConstructor
  public class TripRepositoryImpl implements TripRepositoryCustom {
    private final JPAQueryFactory factory;
    @Override
    public Page<Trip> findTripsByUser(...) { /* ... */ }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `...Impl` 접미사 규칙을 지켜야 Spring Data가 자동 연결한다.
  * 복잡 조회가 많은 서비스에서 표준적으로 쓰이는 패턴이다.

---

### 2. QueryDSL 동적 쿼리 (WHERE, ORDER BY)

조건 존재 여부에 따라 `WHERE`를 조합하고, 문자열 기준 정렬을 안전하게 변환한다.

* **학습 목표 (Why?)**
  다양한 필터·정렬 옵션을 유연하게 수용하면서, 서비스 계층의 분기를 최소화한다.

* **핵심 원리 (What?)**

  * **동적 WHERE**: `BooleanBuilder`에 조건 존재 시 `.and()`로 누적
  * **동적 ORDER BY**: `sortBy`, `direction` 값을 `OrderSpecifier`로 매핑

* **문법 및 사용법 (How?)**

  ```java
  // TripRepositoryImpl.java
  public Page<Trip> findTripsByUser(User user, TripSearchCondition condition, Pageable pageable) {
    BooleanBuilder where = new BooleanBuilder()
        .and(trip.user.eq(user));

    if (condition.getStatus() != null) {
      where.and(trip.status.eq(condition.getStatus()));
    }
    if (condition.getDestination() != null) {
      where.and(trip.destination.containsIgnoreCase(condition.getDestination()));
    }

    List<Trip> content = factory
        .selectFrom(trip)
        .where(where)
        .orderBy(getOrderSpecifier(condition))
        .offset(pageable.getOffset())
        .limit(pageable.getPageSize())
        .fetch();

    Long total = factory
        .select(trip.count())
        .from(trip)
        .where(where)
        .fetchOne();

    return new PageImpl<>(content, pageable, total == null ? 0L : total);
  }

  private OrderSpecifier<?> getOrderSpecifier(TripSearchCondition c) {
    boolean desc = "DESC".equalsIgnoreCase(c.getSortDirection());
    switch (c.getSortBy() == null ? "" : c.getSortBy().toLowerCase()) {
      case "startdate": return desc ? trip.startDate.desc() : trip.startDate.asc();
      case "enddate":   return desc ? trip.endDate.desc()   : trip.endDate.asc();
      case "status":    return desc ? trip.status.desc()    : trip.status.asc();
      default:          return trip.createdAt.desc(); // 기본 정렬
    }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 문자열 정렬 필드는 \*\*허용 목록(allowlist)\*\*으로만 매핑해 SQL 인젝션 위험을 차단한다.
  * `containsIgnoreCase`는 내부적으로 `lower()` 비교가 수행되므로 인덱스 사용성에 유의한다(필요 시 정규화 컬럼 또는 별도 검색 컬럼 고려).

---

### 3. QueryDSL 페이징 처리

콘텐츠 쿼리와 카운트 쿼리를 분리해 `Page`를 구성한다.

* **학습 목표 (Why?)**
  대량 데이터에서 페이지 단위 제공과 총 개수 제공을 동시에 만족한다.

* **핵심 원리 (What?)**

  * **콘텐츠 쿼리**: `where + orderBy + offset + limit`
  * **카운트 쿼리**: 동일 `where`로 총합만 계산(정렬·페이징 제외)
  * **결합**: `new PageImpl<>(content, pageable, totalCount)`

* **문법 및 사용법 (How?)**

  ```java
  List<Trip> content = factory
      .selectFrom(trip)
      .where(where)
      .orderBy(getOrderSpecifier(condition))
      .offset(pageable.getOffset())
      .limit(pageable.getPageSize())
      .fetch();

  Long total = factory
      .select(trip.count())
      .from(trip)
      .where(where)
      .fetchOne();

  return new PageImpl<>(content, pageable, total == null ? 0L : total);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 카운트 쿼리에는 `orderBy`를 넣지 않는다.
  * `fetchOne()`은 `null` 가능성이 있으므로 안전 처리가 필요하다.
  * 복잡 조인/필터에서는 카운트 쿼리를 단순화해 성능을 확보한다.

---

### 4. 엔티티의 비즈니스 로직 포함

단순 데이터 보관을 넘어, 도메인 규칙을 엔티티에 캡슐화한다.

* **학습 목표 (Why?)**
  도메인 로직을 엔티티로 이동해 응집도를 높이고 서비스 레이어 분기를 줄인다.

* **핵심 원리 (What?)**

  * `getDuration()`: `startDate`\~`endDate` 기간 계산
  * `isOngoing()`: 현재 시점이 기간 내인지 판단
  * `TripStatus` `Enum`: 상태 전이와 표현을 일관되게 관리

* **문법 및 사용법 (How?)**

  ```java
  @Entity
  public class Trip {
    // ...
    public long getDuration() {
      return ChronoUnit.DAYS.between(this.startDate, this.endDate);
    }
    public boolean isOngoing(LocalDate now) {
      return (now.isEqual(startDate) || now.isAfter(startDate))
          && (now.isBefore(endDate) || now.isEqual(endDate));
    }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 엔티티 메서드는 **부작용 없는 계산/판단**에 집중한다(트랜잭션 외부 변경 지양).
  * 상태 전이는 `Enum`과 메서드 조합으로 유효성 검사를 함께 제공한다.

---

## 오늘의 깨달음 💡

* 커스텀 Repository 패턴으로 CRUD와 복잡 조회 로직을 분리하면 응집도와 가독성이 높아진다.

* `BooleanBuilder`와 `OrderSpecifier`를 사용하면 조건 추가·정렬 변경 요구사항을 안전하게 수용할 수 있다.

* 페이징은 콘텐츠와 카운트 쿼리를 분리해 정확한 총개수를 제공하는 것이 핵심이다.

* 엔티티에 계산/판단 로직을 포함하면 도메인 규칙이 명확해지고 서비스 레이어가 단순해진다.