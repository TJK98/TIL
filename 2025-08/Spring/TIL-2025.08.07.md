# TIL - 2025.08.07 - Spring Security JWT 인증 흐름 구현 개념 이해

## 카테고리 🏷️

#TIL #Java #Spring #SpringSecurity #JWT #Authentication #Frontend #AsyncAwait

---

## 오늘 배운 내용 🔍

* JWT(JSON Web Token)의 기본 구조 (Header, Payload, Signature)와 Stateless 인증 원리
* `jjwt` 라이브러리를 이용한 JWT 생성 및 서명(`signWith`) 과정
* `@ConfigurationProperties`를 이용한 설정값 매핑
* 로그인 로직에 JWT 발급 기능을 통합하고 `AuthResponse` DTO로 반환
* JavaScript 모듈화 (`import`/`export`) 및 `async/await` 기반 API 통신
* Thymeleaf를 이용한 페이지 라우팅 컨트롤러 (`PageController`) 구현

---

## 어려웠던 점 💣

* JWT가 단순 암호화 문자열이 아니라 구조화된 데이터라는 점이 처음에는 이해되지 않았다. Base64 인코딩일 뿐 암호화가 아니라는 점이 혼란스러웠다.

* Secret Key를 어떤 방식으로 생성하고 관리해야 하는지 명확하지 않았다. 안전한 키 생성과 환경 변수 관리의 필요성을 학습했다.

* 서버가 토큰 발급 후 인증 흐름을 어떻게 이어가는지 전체 그림이 부족했다. 클라이언트가 토큰을 저장하고 요청마다 `Authorization` 헤더에 담아야 한다는 점을 이해하고 나서 흐름이 명확해졌다.

* JavaScript 모듈화를 적용하면서 파일이 나뉘고 `import`/`export` 구조가 낯설었다. 하지만 유지보수성과 재사용성 향상이라는 장점을 확인했다.

---

## 정리 🖇️

### 1. JWT 이해와 생성

* **학습 목표 (Why?)**
  세션 없이도 클라이언트의 요청만으로 인증을 처리할 수 있는 확장성 높은 인증 방식을 구현한다.

* **핵심 원리 (What?)**

  * JWT는 `Header`, `Payload`, `Signature` 세 부분으로 구성된다.
  * Header에는 토큰 타입과 알고리즘 정보, Payload에는 사용자 식별 정보와 만료 시간이 담긴다.
  * Signature는 서버의 비밀 키로 생성되어 위변조 여부를 검증한다.
  * `JwtProvider`는 JWT 생성과 검증을 담당한다.

* **문법 및 사용법 (How?)**
  `jjwt` 라이브러리를 통해 토큰을 생성하고, `@ConfigurationProperties`를 이용해 secret 값과 만료 시간을 주입받는다.

* **주의사항 및 실무 팁 (Watch out for)**

  * 비밀 키는 소스코드에 직접 작성하지 말고 환경 변수로 관리해야 한다.
  * Payload에는 누구나 디코딩 가능한 정보가 담기므로 민감 데이터를 넣지 않는다.

---

### 2. 로그인 흐름과 JWT 발급

* **학습 목표 (Why?)**
  로그인 성공 시 JWT를 발급하여 이후 요청에 인증 수단으로 사용한다.

* **핵심 원리 (What?)**

  * 비밀번호 검증에 성공하면 `JwtProvider`를 통해 토큰을 생성한다.
  * 생성된 토큰은 사용자 정보와 함께 `AuthResponse` DTO로 반환된다.
  * 응답에는 `Bearer` 타입을 명시해 클라이언트가 표준 형식으로 사용할 수 있도록 한다.

* **문법 및 사용법 (How?)**
  `UserService.authenticate`에서 토큰을 생성하고, `AuthResponse`를 반환한다.

* **주의사항 및 실무 팁 (Watch out for)**

  * `Authorization: Bearer <token>` 형식으로 헤더를 구성하는 것이 표준이다.

---

### 3. 프론트엔드와 API 연동

* **학습 목표 (Why?)**
  클라이언트 UI와 백엔드 API를 연결해 사용자 상호작용을 처리한다.

* **핵심 원리 (What?)**

  * JavaScript 모듈화를 통해 기능을 분리(`import`/`export`).
  * `fetch` API와 `async/await`를 활용해 비동기 요청을 처리한다.
  * 이벤트 리스너를 통해 사용자 입력을 감지하고 서버와 통신한다.

* **문법 및 사용법 (How?)**
  `apiService` 모듈을 만들어 재사용 가능한 HTTP 요청 로직을 구성하고, 페이지별 스크립트에서 이를 호출한다.

* **주의사항 및 실무 팁 (Watch out for)**

  * `fetch`는 4xx, 5xx 응답에도 예외를 던지지 않으므로 `response.ok` 검증이 필요하다.

---

## 오늘의 깨달음 💡

* JWT는 세션 없이 인증을 유지할 수 있는 구조화된 토큰이며, 발급 후 클라이언트가 이를 요청마다 제출해야 한다.

* Secret Key는 보안의 핵심이므로 안전한 방식으로 생성하고 환경 변수로 관리해야 한다.

* 인증 흐름은 "로그인 → JWT 발급 → 클라이언트 저장 → 요청 시 헤더 전송"이라는 일관된 패턴으로 정리된다.

* JavaScript 모듈화와 `async/await`는 초기에는 복잡하게 보이지만, 코드의 가독성과 유지보수성을 크게 높여준다.