# TIL - 2025.08.19 - JPA 다대다 관계 매핑과 파일 업로드 구현 개념 이해

## 카테고리 🏷️

#TIL #Spring #JPA #ManyToMany #FileUpload #Multipart #JavaScript

---

## 오늘 배운 내용 🔍

* JPA에서 다대다(M\:N) 관계를 연결 엔티티(`TravelLogTag`)를 통해 구현하는 방법
* Spring Boot에서 파일 업로드 처리 흐름 (로컬 저장 및 메타데이터 DB 관리)
* `multipart/form-data` 요청을 `@RequestPart` 애노테이션으로 처리하는 방법
* 외부 경로의 정적 리소스를 웹에서 접근 가능하게 설정하는 방법 (`WebMvcConfigurer`)
* JPA 엔티티 내 편의 메서드의 역할과 필요성
* 프론트엔드에서 파일 업로드 시 상태 관리와 UI 반영 전략

---

## 어려웠던 점 💣

* 다대다 관계를 해소하는 연결 엔티티의 PK를 **복합 키**로 할지, **대리 키**로 할지 선택이 어려웠다. 실무에서는 대리 키 기반 비식별 관계가 더 선호된다는 점을 확인했다.

* JSON과 파일을 동시에 처리할 때 `@RequestBody`로는 불가능하고 `@RequestPart`를 사용해야 한다는 점이 처음에는 혼란스러웠다.

* 로컬 경로(`C:/uploads/...`)와 웹 접근 경로(`/uploads/...`)의 차이를 구분하는 데 시간이 걸렸다. `WebMvcConfigurer`를 통한 매핑이 필수적이었다.

* 여러 파일을 선택, 썸네일 미리보기, 드래그 앤 드롭으로 순서 변경까지 구현하려니 상태 관리 로직이 복잡해졌다.

---

## 정리 🖇️

### 1. 연결 엔티티를 통한 다대다(M\:N) 관계 매핑

* **학습 목표 (Why?)**
  `@ManyToMany`의 한계를 극복하고, 관계에 추가 데이터를 저장할 수 있는 유연한 설계를 하기 위함이다.

* **핵심 원리 (What?)**

  * 중간 엔티티(`TravelLogTag`)를 두어 1\:N - N:1 관계로 풀어낸다.
  * 대리 키(`id`)를 사용한 비식별 관계가 관리와 확장성 면에서 유리하다.
  * 연결 엔티티에 `createdAt` 같은 추가 정보를 담을 수 있다.

* **문법 및 사용법 (How?)**

  ```java
  @Entity
  public class TravelLogTag {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "travel_log_id")
      private TravelLog travelLog;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "tag_id")
      private Tag tag;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  `addTag(Tag tag)` 같은 편의 메서드를 두면 서비스 계층 코드가 간결해지고 응집도가 올라간다.

---

### 2. Spring Boot 파일 업로드 처리

* **학습 목표 (Why?)**
  파일 저장과 메타데이터 관리를 분리해 효율적이고 확장성 있는 설계를 하기 위함이다.

* **핵심 원리 (What?)**

  * 실제 파일은 파일 시스템(또는 클라우드 스토리지)에 저장한다.
  * DB에는 파일 경로나 URL, 원본 이름 등의 메타데이터만 저장한다.

* **문법 및 사용법 (How?)**

  ```java
  String storedFileName = UUID.randomUUID() + ".jpg";
  Path target = userBasePath.resolve(storedFileName);
  Files.copy(file.getInputStream(), target);

  TravelPhoto photo = TravelPhoto.builder()
      .filePath("/uploads/" + username + "/" + storedFileName)
      .build();
  travelPhotoRepository.save(photo);
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  운영 환경에서는 AWS S3와 같은 클라우드 스토리지를 활용하는 것이 일반적이다.
  업로드 시 파일 크기와 MIME Type을 반드시 검증해야 한다.

---

### 3. @RequestPart를 이용한 Multipart 요청 처리

* **학습 목표 (Why?)**
  JSON 데이터와 파일을 하나의 API 요청으로 처리해 효율성을 높이기 위함이다.

* **핵심 원리 (What?)**

  * `@RequestBody`는 `multipart/form-data`를 처리할 수 없다.
  * `@RequestPart`는 요청의 각 파트를 개별 파라미터로 바인딩한다.

* **문법 및 사용법 (How?)**

  ```javascript
  const formData = new FormData();
  formData.append('data', new Blob([JSON.stringify(payload)], { type: 'application/json' }));
  images.forEach(img => formData.append('files', img.file));
  ```

  ```java
  @PostMapping
  public ResponseEntity<?> createTravelLogs(
      @RequestParam Long tripId,
      @RequestPart(name = "data") @Valid TravelLogRequestDto requestDto,
      @RequestPart(name = "files") List<MultipartFile> files
  ) { ... }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  `@RequestPart`의 name 속성은 프론트엔드의 `FormData.append()` 키와 반드시 일치해야 한다.

---

### 4. 프론트엔드 파일 업로드 상태 관리

* **학습 목표 (Why?)**
  사용자가 업로드한 파일을 직관적으로 확인하고, 순서를 바꾸는 등 상호작용성을 높이기 위함이다.

* **핵심 원리 (What?)**

  * `File` 객체와 `URL.createObjectURL`로 미리보기를 만든다.
  * `drag` 이벤트로 파일 순서를 제어한다.
  * 파일, 태그 등은 상태(state) 객체에 저장하고 상태 변경 시 UI를 재렌더링한다.

* **문법 및 사용법 (How?)**

  ```javascript
  fileInput.addEventListener('change', e => {
    [...e.target.files].forEach(file => {
      const preview = document.createElement('img');
      preview.src = URL.createObjectURL(file);
      preview.draggable = true;
      container.appendChild(preview);
    });
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  상태 관리가 명확히 분리되지 않으면 DOM 조작이 복잡해지고 오류가 발생한다.
  React/Vue 같은 프레임워크는 상태와 UI 렌더링을 자동으로 동기화해주므로 더 안정적이다.

---

## 오늘의 깨달음 💡

* 다대다 관계는 `@ManyToMany`보다 연결 엔티티로 풀어내는 것이 더 좋은 설계다.

* 파일 업로드는 DB와 파일 시스템의 책임을 나누는 것이 핵심이다.

* `@RequestPart`는 JSON과 파일을 동시에 처리하는 데 필수적이다.

* 프론트엔드 UI는 결국 상태 관리가 안정성과 유지보수성을 좌우한다.