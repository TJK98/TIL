# TIL - 2025.08.11 - JWT 클라이언트 인증 상태 관리와 실시간 유효성 검증 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Spring #JWT #LocalStorage #Validation #Debouncing #SpringDataJPA #Frontend

---

## 오늘 배운 내용 🔍

* `localStorage`를 이용한 클라이언트 측 JWT 인증 상태 관리(로그인, 로그아웃, 상태 확인)
* 인증 상태에 따른 동적 UI 업데이트 로직
* 회원가입 폼 UX 향상을 위한 실시간 중복 체크 API 연동
* 불필요한 호출을 줄이는 **디바운싱(Debouncing)** 적용
* Spring Data JPA `existsBy...`로 효율적인 중복 확인
* JavaScript 모듈 패턴(`import`/`export`) 기반 기능 분리

---

## 어려웠던 점 💣

* 로그인 성공 후 서버가 HTML을 재전송하지 않아도, 클라이언트가 `localStorage`와 DOM 조작으로 헤더 상태를 변경한다는 점을 처음에 이해하지 못했다.

* JWT 저장 위치 선택(`localStorage` vs `sessionStorage`)에서 자동 로그인 편의성과 XSS 노출 가능성 간의 트레이드오프 판단이 필요했다.

* `input` 이벤트마다 중복 체크 API를 호출하면 비효율적이라 디바운싱 도입이 필요했다.

* 디바운싱의 동작 원리(마지막 입력 후 일정 시간 경과 시 1회 실행)와 `setTimeout`/`clearTimeout` 기반 구현에 익숙해지는 과정이 필요했다.

---

## 정리 🖇️

### 1. 클라이언트 측 인증 상태 관리

서버에서 발급된 JWT를 브라우저에 저장하고, 로그인 상태와 UI를 제어한다.

* **학습 목표 (Why?)**
  상태 비저장 서버 환경에서 페이지 이동 후에도 로그인 상태를 유지하고 화면을 일관되게 갱신하기 위함이다.

* **핵심 원리 (What?)**

  * **웹 스토리지**

    * `localStorage`: 브라우저 재시작 후에도 유지. 자동 로그인에 적합.
    * `sessionStorage`: 탭/창 단위 유지.
  * **`authService` 모듈**

    * `login(token, user)`: 토큰·사용자 정보 저장.
    * `logout()`: 저장 정보 삭제 및 리다이렉트.
    * `checkAuthStatus()`: 저장 정보로 인증 상태 반환.
    * `updateHeaderUI()`: 상태에 따른 헤더 DOM 갱신.

* **문법 및 사용법 (How?)**

  ```javascript
  // auth.js
  const TOKEN = 'token';
  const USER  = 'user';

  export const authService = {
    login(token, userJson) {
      localStorage.setItem(TOKEN, token);
      localStorage.setItem(USER, userJson);
    },
    logout() {
      localStorage.removeItem(TOKEN);
      localStorage.removeItem(USER);
      window.location.href = '/';
    },
    checkAuthStatus() {
      const token = localStorage.getItem(TOKEN);
      const user  = JSON.parse(localStorage.getItem(USER) || '{}');
      return { isAuthenticated: !!token, user };
    },
    updateHeaderUI() {
      // 상태에 따른 헤더 버튼/메뉴 토글
    }
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `localStorage`는 스크립트 접근이 가능하므로 민감 정보 저장을 지양한다.
  * 권한 판단은 서버 검증을 기준으로 하고, 클라이언트에는 표시용 최소 정보만 둔다.
  * Refresh Token은 `HttpOnly` 쿠키 등 별도 보안 전략을 고려한다.

---

### 2. 실시간 비동기 유효성 검증

입력 단계에서 서버와 통신해 중복 여부를 즉시 피드백한다.

* **학습 목표 (Why?)**
  제출 단계의 일괄 오류를 줄이고 입력 중 피드백으로 UX를 개선한다.

* **핵심 원리 (What?)**

  * **백엔드**: `existsBy...` Query Method로 존재 여부만 빠르게 확인.
  * **프론트엔드**: `input` 이벤트에 비동기 호출을 연결하고 결과에 따라 메시지/스타일 갱신.

* **문법 및 사용법 (How?)**

  ```java
  // AuthController.java
  @GetMapping("/check-username")
  public ResponseEntity<?> checkUsername(@RequestParam String username) {
      boolean exists = userService.checkDuplicateUsername(username);
      return ResponseEntity.ok(ApiResponse.success("ok", exists));
  }

  // UserService.java
  public boolean checkDuplicateUsername(String username) {
      return userRepository.existsByUsername(username);
  }
  ```

  ```javascript
  // signup.js
  async function checkDuplicateUsername(username) {
    const res = await apiService.get(`/api/auth/check-username?username=${username}`);
    const isAvailable = !res.data;
    updateInputState($usernameInput, isAvailable, res.message);
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 서버 부하를 줄이기 위해 디바운싱을 적용한다.
  * 서버 검증 규칙(트림, 길이, 패턴)과 클라이언트 검증 규칙을 일치시킨다.

---

### 3. 디바운싱(Debouncing) 기반 성능 최적화

연속 이벤트를 묶어 마지막 입력 후 한 번만 실행한다.

* **학습 목표 (Why?)**
  잦은 네트워크 호출과 불필요한 계산을 줄여 성능과 응답성을 개선한다.

* **핵심 원리 (What?)**

  * 디바운싱: 마지막 이벤트로부터 `delay` 경과 시 1회 실행.
  * `setTimeout`/`clearTimeout`으로 구현.

* **문법 및 사용법 (How?)**

  ```javascript
  // util.js
  export const utils = {
    debounce(fn, delay) {
      let t;
      return function (...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }
  };

  // signup.js
  import { utils } from '../utils/util.js';

  const handleUsernameInput = utils.debounce(e => {
    const v = e.target.value;
    // 기본 클라이언트 검증 후
    checkDuplicateUsername(v);
  }, 500);

  $usernameInput?.addEventListener('input', handleUsernameInput);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 디바운싱은 “마지막 1회”, 쓰로틀링은 “주기적 제한”이다.
  * 딜레이 값(예: 300\~500ms)은 입력 속도·API 응답 시간을 고려해 조정한다.

---

## 오늘의 깨달음 💡

* 클라이언트가 토큰과 사용자 정보를 활용해 인증 상태를 관리할 수 있음을 확인했다.

* `localStorage` 사용은 편의성과 보안 간 트레이드오프가 존재하므로, 민감 정보 배제와 서버 검증 중심 설계를 유지해야 한다.

* 실시간 유효성 검증은 디바운싱 적용 시 서버 부하와 네트워크 트래픽을 효과적으로 줄일 수 있다.

* 자바스크립트 모듈화와 이벤트·네트워크 처리 분리는 유지보수성과 재사용성을 높인다.
