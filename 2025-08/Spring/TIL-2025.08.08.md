# TIL - 2025.08.08 - JWT 클라이언트 인증 상태 관리와 실시간 유효성 검증 개념 이해

## 카테고리 🏷️

#TIL #JavaScript #Spring #SpringSecurity #JWT #LocalStorage #Debouncing #Validation #Frontend #SpringDataJPA

---

## 오늘 배운 내용 🔍

* `localStorage`를 이용한 클라이언트 측 JWT 인증 상태 관리(로그인, 로그아웃, 상태 확인)
* 인증 상태에 따른 동적 UI 업데이트 로직
* 회원가입 폼 UX 향상을 위한 실시간 중복 체크 API 연동
* 불필요한 호출을 줄이는 **디바운싱(Debouncing)** 적용
* Spring Data JPA `existsBy...`를 이용한 중복 확인
* JavaScript 모듈 패턴(`import`/`export`) 기반 기능 분리

---

## 어려웠던 점 💣

* 로그인 성공 후 서버가 HTML을 다시 보내지 않아도, 클라이언트가 `localStorage`와 DOM 조작으로 헤더 상태를 바꾼다는 점을 처음에 이해하지 못했다.

* 토큰 저장 위치로 `localStorage`와 `sessionStorage` 중 무엇이 적합한지 판단이 어려웠다. 자동 로그인을 고려해 `localStorage`를 선택했으나, XSS 노출 가능성이라는 보안 트레이드오프가 있다는 점을 알았다.

* 입력마다 API를 호출하는 실시간 중복 체크가 비효율적이었다. 이를 줄이기 위한 디바운싱 기법의 필요성을 인지하고 적용했다.

* 디바운싱 개념과 구현(마지막 입력 후 일정 시간 경과 시 1회 실행)을 익히는 과정이 낯설었다.

---

## 정리 🖇️

### 1. 클라이언트 측 인증 상태 관리

서버에서 발급된 JWT를 브라우저에 저장하고, 이를 바탕으로 로그인 상태와 UI를 제어하는 방법을 정리했다.

* **학습 목표 (Why?)**
  상태 비저장 서버 환경에서, 페이지 이동 이후에도 로그인 상태를 유지하고 화면 요소를 일관되게 갱신하기 위함이다.

* **핵심 원리 (What?)**

  * **웹 스토리지**

    * `localStorage`: 브라우저 재시작 후에도 유지. 자동 로그인에 적합.
    * `sessionStorage`: 탭/창 단위 유지.
  * **`authService` 모듈**

    * `login(token, user)`: 토큰·사용자 정보를 저장.
    * `logout()`: 저장 정보 삭제 및 리다이렉트.
    * `checkAuthStatus()`: 저장 정보로 인증 상태 반환.
    * `updateHeaderUI()`: 현재 상태에 따라 헤더 DOM 갱신.

* **문법 및 사용법 (How?)**

  ```javascript
  // auth.js
  const TOKEN = 'token';
  const USER  = 'user';

  export const authService = {
    login(token, userJson) {
      localStorage.setItem(TOKEN, token);
      localStorage.setItem(USER, userJson);
    },
    logout() {
      localStorage.removeItem(TOKEN);
      localStorage.removeItem(USER);
      window.location.href = '/';
    },
    checkAuthStatus() {
      const token = localStorage.getItem(TOKEN);
      const user  = JSON.parse(localStorage.getItem(USER) || '{}');
      return { isAuthenticated: !!token, user };
    },
    updateHeaderUI() {
      // 상태에 따른 헤더 버튼/메뉴 토글
    }
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `localStorage`는 스크립트로 접근 가능하므로 민감 정보 저장을 지양한다.
  * 권한은 서버 검증을 기준으로 처리하고, 클라이언트에는 표시용 최소 정보만 둔다.
  * 보안 강화를 위해 Refresh Token은 `HttpOnly` 쿠키 사용을 고려한다.

---

### 2. 실시간 비동기 유효성 검증

입력 단계에서 중복 여부를 서버와 통신해 즉시 피드백하는 로직을 정리했다.

* **학습 목표 (Why?)**
  제출 단계에서 오류를 발견하는 비효율을 줄이고, 입력 중 피드백으로 UX를 개선하기 위함이다.

* **핵심 원리 (What?)**

  * **백엔드**: `existsBy...` Query Method로 존재 여부만 빠르게 확인.
  * **프론트엔드**: `input` 이벤트에 비동기 호출을 연결해 결과에 따라 즉시 메시지/스타일 업데이트.

* **문법 및 사용법 (How?)**

  ```java
  // AuthController.java
  @GetMapping("/check-username")
  public ResponseEntity<?> checkUsername(@RequestParam String username) {
      boolean exists = userService.checkDuplicateUsername(username);
      return ResponseEntity.ok(ApiResponse.success("ok", exists));
  }

  // UserService.java
  public boolean checkDuplicateUsername(String username) {
      return userRepository.existsByUsername(username);
  }
  ```

  ```javascript
  // signup.js
  async function checkDuplicateUsername(username) {
    const res = await apiService.get(`/api/auth/check-username?username=${username}`);
    const isAvailable = !res.data;
    updateInputState($usernameInput, isAvailable, res.message);
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 서버 부하를 줄이기 위해 디바운싱을 반드시 적용한다.
  * 서버 기준의 유효성(트림, 길이, 패턴 등)과 일치하도록 클라이언트 측 검증 규칙을 맞춘다.

---

### 3. 디바운싱(Debouncing) 기반 성능 최적화

연속 이벤트를 묶어서 마지막 입력 후 한 번만 실행하는 패턴을 정리했다.

* **학습 목표 (Why?)**
  잦은 네트워크 호출과 불필요한 계산을 줄여 성능과 응답성을 개선하기 위함이다.

* **핵심 원리 (What?)**

  * 디바운싱: 마지막 이벤트로부터 `delay` 경과 시 1회 실행.
  * `setTimeout`/`clearTimeout`으로 구현.

* **문법 및 사용법 (How?)**

  ```javascript
  // util.js
  export const utils = {
    debounce(fn, delay) {
      let t;
      return function (...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }
  };

  // signup.js
  import { utils } from '../utils/util.js';
  const handleUsernameInput = utils.debounce(e => {
    const v = e.target.value;
    // 기본 클라이언트 검증 후
    checkDuplicateUsername(v);
  }, 500);

  $usernameInput?.addEventListener('input', handleUsernameInput);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 디바운싱은 “마지막 1회”, 쓰로틀링은 “주기적 제한”이라는 차이가 있다.
  * 딜레이 값(예: 300\~500ms)은 UX에 직접적 영향을 준다. 입력 속도와 API 응답 시간을 고려해 조정한다.

---

## 오늘의 깨달음 💡

* 상태 비저장 서버 환경에서 클라이언트가 토큰과 사용자 정보를 기반으로 인증 상태를 주도적으로 관리할 수 있음을 확인했다.

* `localStorage` 사용은 편의성과 보안 사이의 트레이드오프가 있으므로, 민감 정보 배제와 서버 검증 중심 설계를 유지해야 한다.

* 실시간 검증은 디바운싱 적용이 필수이며, 서버·클라이언트 검증 규칙의 일관성이 중요하다.

* 모듈화된 자바스크립트 구조는 유지보수성과 재사용성을 높이며, 이벤트·네트워크 처리 코드를 명확히 분리하는 데 효과적이다.