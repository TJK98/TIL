# TIL - 2025.08.26 - 2025.08.26 - 여러 상태 관리, 상향식 데이터 전달, 동적 리스트·조건부 렌더링·차트 구성 개념 이해

## 카테고리 🏷️

#TIL #React #StateManagement #useState #Immutability #FunctionalUpdate #Props #LiftingState #ConditionalRendering #DynamicList #KeyProp #Form #Chart

---

## 오늘 배운 내용 🔍

* 단일 값 상태 vs 객체 상태로 입력값 관리 흐름
* 상태 불변성과 스프레드 연산으로 안전하게 업데이트하는 방법
* `setState`의 비동기 특성과 **함수형 업데이트** 패턴
* 폼 입력을 **Controlled Component**로 관리하고 초기화하는 패턴
* 자식 → 부모 **상향식 데이터 전달**(함수 props)과 상태 끌어올리기
* 연도 필터로 동적 리스트를 **filter + map**으로 렌더링하고 `key` 부여
* 버튼/토글을 이용한 **조건부 렌더링**으로 폼 표시 제어
* 월별 합계 계산 후 **막대 차트 컴포넌트(Chart/ChartBar)** 구성

---

## 어려웠던 점 💣

* 입력 상태를 단일 값으로 나눌지, 객체 하나로 묶을지 기준을 잡는 데 시간이 걸렸음.

* 스프레드 없이 객체의 특정 필드만 바꾸면 리렌더링이 되지 않는 이유를 처음에 이해하지 못했음.

* `setState` 직후 콘솔에 이전 값이 보이는 현상을 비동기 특성과 배치 업데이트 관점에서 연결하는 데 시간이 걸렸음.

* 리스트 렌더링에서 `key`를 임시 랜덤값으로 주면 재조정이 불안정해질 수 있음을 실습으로 체감함.

* `onInput`과 `onChange`의 차이를 실무 기준으로 정리하는 데 시간이 걸렸음.

---

## 정리 🖇️

### 1. 단일 값 상태 vs 객체 상태 관리

클라이언트 폼 입력을 **단일 상태 다건** 또는 **단일 객체**로 관리하는 기준과 장단점을 학습했다.

* **학습 목표 (Why?)**
  입력 규모와 관련성에 따라 상태를 분해하거나 묶어 **가독성과 유지보수성, 업데이트 일관성**을 확보하기 위함이다.

* **핵심 원리 (What?)**

  * 독립 변경이 많으면 **단일 값 상태**로 관리할 수 있다.
  * 값들이 논리적으로 묶이고 **동시에 갱신**될 가능성이 높으면 **객체 상태**로 관리할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // 단일 값 상태
  const [productName, setProductName] = useState('');
  const [amount, setAmount] = useState('');
  const [orderDate, setOrderDate] = useState('');

  // 객체 상태
  const [orderInput, setOrderInput] = useState({
    productName: '',
    amount: '',
    orderDate: ''
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 객체 상태에서 특정 필드만 바꿀 때는 **스프레드로 얕은 복사** 후 교체할 수 있다.
  * 폼 규모가 커지면 **객체 상태 + 함수형 업데이트**로 동시성 문제를 줄일 수 있다.

> 단일 값 상태와 객체 상태의 선택 기준과 사용 패턴을 학습했다.

---

### 2. 상태 불변성과 안전한 업데이트

상태는 **불변성**을 지켜 새 객체로 교체해야 React가 변경을 감지함을 학습했다.

* **학습 목표 (Why?)**
  참조 동일성 비교를 활용하는 React의 렌더링 전략에 맞게 **신규 참조로 교체**하여 변경 탐지를 가능하게 하기 위함이다.

* **핵심 원리 (What?)**

  * 객체/배열 상태는 **직접 수정** 대신 **새 인스턴스**로 교체할 수 있다.
  * 스프레드(`...`)로 기존 필드를 복사하고 바뀐 필드만 덮어쓸 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  setOrderInput(prev => ({
    ...prev,
    productName: e.target.value
  }));
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 기존 객체에 **직접 대입**하면 렌더가 트리거되지 않을 수 있다.
  * 배열 추가/삭제도 **스프레드, filter, map**으로 새 배열을 만들 수 있다.

> 스프레드 기반의 불변 업데이트 방식과 그 이유를 학습했다.

---

### 3. 비동기 업데이트와 함수형 업데이트 패턴

`setState`가 **비동기·배치**됨을 전제로 **이전 상태 의존 로직**을 안전히 처리하는 방법을 학습했다.

* **학습 목표 (Why?)**
  연속 업데이트 시 **경쟁 상태**를 피하고 정확한 누적을 보장하기 위함이다.

* **핵심 원리 (What?)**

  * `setState(next)`는 즉시 반영되지 않을 수 있다.
  * **함수형 업데이트** `setState(prev => next(prev))`를 쓰면 정확히 누적할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // 누적 증가 보장
  setCount(prev => prev + 1);
  setCount(prev => prev + 1); // 총 +2 보장
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 동일 렌더 사이에서 `setState(state + 1)`를 두 번 호출하면 **한 번만 반영**될 수 있다.
  * 이전 상태에 의존하는 모든 갱신은 **함수형 업데이트**로 작성할 수 있다.

> 함수형 업데이트의 필요성과 패턴을 학습했다.

---

### 4. 폼 입력 제어와 초기화(Controlled Components)

입력 요소를 **상태 단일 출처**로 제어하고 제출 시 **초기화**하는 흐름을 학습했다.

* **학습 목표 (Why?)**
  입력값 검증·포맷팅·초기화 등 UI/비즈니스 로직을 **일관된 데이터 소스**에서 처리하기 위함이다.

* **핵심 원리 (What?)**

  * 입력의 `value`는 **상태**가 단일 출처가 된다.
  * 입력 이벤트에서 **setter**로 상태를 갱신할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const [orderInput, setOrderInput] = useState({ productName:'', amount:0, orderDate:'' });

  const submit = e => {
    e.preventDefault();
    // payload 사용 후 초기화
    setOrderInput({ productName:'', amount:0, orderDate:'' });
  };

  <input
    type="text"
    value={orderInput.productName}
    onInput={e => setOrderInput(prev => ({ ...prev, productName: e.target.value }))}
  />
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 실무에선 **`onChange`** 사용을 권장할 수 있다(브라우저·IME 호환성 면에서 안정적).
  * 숫자 입력은 **문자열 → 숫자 변환**을 명확히 할 수 있다(예: `+e.target.value`).

> Controlled Component로 폼을 제어하고 안전하게 초기화하는 패턴을 학습했다.

---

### 5. 상향식 데이터 전달(Lifting State Up)

자식이 부모 상태를 직접 바꿀 수 없으므로 **부모에서 함수를 내려주고 자식이 호출**하는 패턴을 학습했다.

* **학습 목표 (Why?)**
  **단방향 데이터 흐름**을 유지하며 자식 이벤트를 부모 상태 변화로 연결하기 위함이다.

* **핵심 원리 (What?)**

  * 부모는 `onAddOrder` 같은 **콜백**을 자식에게 props로 전달할 수 있다.
  * 자식은 **완성된 데이터**를 콜백 인자로 전달해 부모가 상태를 갱신할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // App.jsx
  const [orders, setOrders] = useState([]);
  const onAddOrder = order => setOrders(prev => [...prev, order]);

  <NewOrder onSave={onAddOrder} />

  // NewOrder.jsx
  <OrderForm onAdd={onSave} />

  // OrderForm.jsx
  onAdd({ productName, amount, orderDate: new Date(orderDate) });
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 트리 깊이가 깊어지면 **prop drilling**이 발생할 수 있다 → 컨텍스트/상태 관리 도구를 검토할 수 있다.
  * 부모는 **배열을 새로 만들어** 상태를 교체할 수 있다.

> 함수 props를 통한 상향식 데이터 전달과 상태 끌어올리기를 학습했다.

---

### 6. 동적 리스트 렌더링과 `key` 부여

`filter → map`으로 항목을 렌더링하고 안정적인 `key`로 재조정을 최적화하는 법을 학습했다.

* **학습 목표 (Why?)**
  데이터 변경 시 최소 DOM 변경으로 성능과 일관성을 확보하기 위함이다.

* **핵심 원리 (What?)**

  * `Array.prototype.map`으로 컴포넌트 배열을 생성할 수 있다.
  * 각 항목에는 **변하지 않는 고유 키**(예: DB PK)를 줄 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  orders
    .filter(o => o.date.getFullYear().toString() === year)
    .map(o => <OrderItem key={o.id} order={o} />);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `Math.random()`은 **재조정 불안정**을 초래할 수 있다.
  * 인덱스 키는 **정렬/삽입/삭제**가 있는 리스트에서 지양할 수 있다.

> 동적 리스트 렌더링과 안정적인 키 설계를 학습했다.

---

### 7. 조건부 렌더링과 토글 UI

상황에 따라 다른 UI를 보여주는 **조건부 렌더링**과 버튼으로 **폼 표시 토글**을 학습했다.

* **학습 목표 (Why?)**
  상태에 따라 **명확한 UI 분기**를 제공하여 사용자 경험을 개선하기 위함이다.

* **핵심 원리 (What?)**

  * 삼항 연산자, `&&` 연산 등으로 조건에 따른 컴포넌트를 분기할 수 있다.
  * **토글 상태**로 폼 열기/닫기를 제어할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const [open, setOpen] = useState(false);
  { open ? <OrderForm onAdd={onSave} onCancel={() => setOpen(false)} /> 
         : <button onClick={() => setOpen(true)}>새 주문 추가</button> }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 조건부 분기 결과가 길어지면 **변수에 컴포넌트 할당** 후 반환부를 단순화할 수 있다.
  * 비어있는 결과는 **명확한 안내 문구**를 함께 제공할 수 있다.

> 토글 상태로 폼을 열고 닫고, 조건에 따라 다른 UI를 제공하는 방법을 학습했다.

---

### 8. 연도 필터와 리스트/차트 연동

연도 선택값을 부모로 끌어올려 **리스트와 차트를 동시에 연동**하는 흐름을 학습했다.

* **학습 목표 (Why?)**
  하나의 필터 상태로 여러 하위 뷰(리스트/차트)를 일관되게 동기화하기 위함이다.

* **핵심 원리 (What?)**

  * 필터 상태는 **상위 컴포넌트**에서 관리할 수 있다.
  * 필터링 결과를 **리스트 렌더링**과 **월별 합산**에 동시에 사용할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const [year, setYear] = useState(new Date().getFullYear().toString());
  const filtered = orders.filter(o => o.date.getFullYear().toString() === year);

  <YearFilter onChangeFilter={setYear} />
  <OrderChart orders={filtered} />
  {filtered.length > 0 ? filtered.map(o => <OrderItem key={o.id} order={o} />)
                       : <p>해당 연도의 주문이 없다.</p>}
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 필터 옵션과 데이터의 **타입 일치**(문자/숫자 변환)를 신경 쓸 수 있다.
  * 필터가 비었을 때의 **빈 상태 UI**를 정의할 수 있다.

> 상위 필터 상태로 리스트와 차트를 일관되게 구동하는 흐름을 학습했다.

---

### 9. 월별 합계 차트 구성(Chart/ChartBar)

필터링된 주문을 **월별 합계**로 집계해 막대 그래프로 가시화하는 컴포지션을 학습했다.

* **학습 목표 (Why?)**
  데이터의 **시간적 패턴**을 한 눈에 파악하고 분석하기 위함이다.

* **핵심 원리 (What?)**

  * 12개월 데이터 포인트 배열을 준비하고 월 인덱스(`0~11`)로 누적할 수 있다.
  * `Chart`는 **총합**을 계산하고, 각 `ChartBar`는 **월 비율**을 그릴 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const points = Array.from({length:12}, (_,i) => ({ label: MONTH[i], value: 0 }));
  filtered.forEach(o => { points[o.date.getMonth()].value += o.amount; });

  const total = points.reduce((acc, p) => acc + p.value, 0);

  <div className="chart">
    {points.map(p => (
      <ChartBar key={p.label} label={p.label}
                currentMonthValue={p.value}
                totalValue={total} />
    ))}
  </div>
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 월 인덱스가 **0부터 시작**함을 고려할 수 있다.
  * 0 나눗셈 방지를 위해 총합 0일 때는 높이 0%로 처리할 수 있다.

> 월별 합산과 차트 컴포넌트 분할 설계를 학습했다.

---

### 10. 예시 전환: 실무 도메인으로 통일

데모 예시를 **`Order`/`Product`/`User`** 도메인으로 바꿔 실무 맥락을 유지하는 원칙을 학습했다.

* **학습 목표 (Why?)**
  학습 코드를 실무 맥락과 동일한 언어로 맞춰 **전이학습**과 **재사용성**을 높이기 위함이다.

* **핵심 원리 (What?)**

  * 표현 필드: `productName`, `amount`, `orderDate`, `id` 등으로 통일할 수 있다.
  * 상향식 전달 시 **완성된 DTO**를 콜백 인자로 넘길 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // OrderForm → parent
  onAdd({
    productName: orderInput.productName,
    amount: +orderInput.amount,
    orderDate: new Date(orderInput.orderDate)
  });
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `key`는 가능하면 **백엔드 PK**를 사용할 수 있다.
  * UI 텍스트/필드명/주석도 **실무 용어**로 통일할 수 있다.

> 학습 예시를 `Order`/`Product`/`User` 도메인으로 일관되게 전환하는 기준을 학습했다.

---

## 오늘의 깨달음 💡

* 상태를 객체로 묶을 때는 **함수형 업데이트**를 기본으로 두면 동시성 문제가 줄어든다.

* 리스트 렌더링의 `key`는 **안정적인 고유값**이어야 재조정 비용을 줄일 수 있다.

* 필터 상태를 상위에서 관리하면 **리스트·차트·요약**을 한 번에 동기화할 수 있다.

* Controlled Component 패턴으로 **검증·포맷팅·초기화**가 일관되게 된다.

* 조건부 렌더링은 토글 상태와 결합해 **간결한 UI 흐름**을 만들 수 있다.