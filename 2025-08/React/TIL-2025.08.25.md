# TIL - 2025.08.25 - React 기본 개념과 JSX, 컴포넌트, 이벤트·상태 관리, 스타일링 개념 이해

## 카테고리 🏷️

#TIL #React #JavaScript #Frontend #Vite #JSX #Component #Props #StateManagement #EventHandling

---

## 오늘 배운 내용 🔍

* Vite로 React 프로젝트 생성과 실행 과정
* React와 Vanilla JS의 차이: 선언적 UI, Virtual DOM, 컴포넌트 기반 아키텍처
* JSX 핵심 규칙 (className, 단일 루트, self-closing, Fragment, camelCase 속성)
* 함수형·클래스형 컴포넌트와 합성·재사용 원리
* `props`와 `props.children`을 통한 데이터·레이아웃 전달
* 이벤트 바인딩 방식과 합성 이벤트 모델
* `useState` 훅으로 상태 관리, 불변성 및 비동기 업데이트
* CSS 파일 분리, 클래스 네이밍, 반응형 스타일링

---

## 어려웠던 점 💣

* `class` 대신 `className`을 써야 하는 이유와 빌드시 DOM 변환 과정을 처음에 혼동했다.

* 단일 루트 규칙을 지키면서 불필요한 래퍼 `<div>`를 쓰지 않고 `Fragment`를 적용하는 방법이 낯설었다.

* JSX에서 `<Product />`처럼 태그 문법으로 컴포넌트를 호출하는 방식이 직관적으로 이해되지 않았다.

* DOM API로 이벤트를 바인딩하려다, 렌더 타이밍과 가상 DOM 때문에 실패한 적이 있었다. JSX 이벤트 속성으로 변경하면서 해결했다.

* `useState`에서 직접 값을 대입했는데 화면이 갱신되지 않아 혼란스러웠다. 불변성과 `setState` 비동기 특성을 이해한 후 해결했다.

* CSS 파일을 분리해 적용할 때 클래스 네이밍이 겹쳐 전역 충돌이 발생했고, BEM 규칙을 적용하면서 해결했다.

---

## 정리 🖇️

### 1. Vite로 React 앱 실행 가이드

React 프로젝트를 Vite로 초기화하고 실행하는 과정을 학습했다.

* **학습 목표 (Why?)**
  빠르고 가벼운 개발 환경을 세팅하고, HMR을 통한 즉각적인 미리보기를 활용하기 위함이다.

* **핵심 원리 (What?)**

  * `npm create vite@latest`로 React 템플릿 생성할 수 있다.
  * `npm run dev`로 실행하면 개발 서버가 HMR 기반으로 동작할 수 있다.

* **문법 및 사용법 (How?)**

  ```bash
  npm create vite@latest my-app
  cd my-app
  npm install
  npm run dev
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * Node.js는 LTS 버전을 사용하는 것이 안정적일 수 있다.
  * 포트 충돌 시 `npm run dev -- --port=5174` 같은 방식으로 해결할 수 있다.

---

### 2. React vs Vanilla JS: 선언적 UI와 Virtual DOM

React와 전통적인 DOM 조작 방식의 차이를 학습했다.

* **학습 목표 (Why?)**
  명령형 DOM 조작 대신 상태 중심의 선언적 렌더링으로 복잡한 UI를 예측 가능하게 관리하기 위함이다.

* **핵심 원리 (What?)**

  * UI를 컴포넌트 단위로 분리해 재사용할 수 있다.
  * 선언적 방식으로 `상태 → UI` 흐름을 기술하면 React가 차이를 계산(diffing)해 패치할 수 있다.
  * Virtual DOM은 메모리 상의 가상 트리로, 효율적인 업데이트를 가능하게 할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  function Greeting({ isLogin }) {
    return isLogin ? <h1>Welcome back</h1> : <h1>Please sign up</h1>;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * DOM 직접 조작은 최소화해야 예측 가능한 상태 관리가 가능할 수 있다.

---

### 3. JSX 핵심 규칙과 Fragment

JSX 문법과 Fragment 사용법을 학습했다.

* **학습 목표 (Why?)**
  JSX 문법 오류를 방지하고, 불필요한 DOM 중첩을 줄이기 위함이다.

* **핵심 원리 (What?)**

  * 하나의 루트 요소가 필요할 수 있다.
  * HTML의 `class`는 JSX에서 `className`으로 사용해야 한다.
  * 비어 있는 태그는 self-closing 형태로 작성해야 한다.
  * 이벤트 속성은 camelCase로 작성할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  function App() {
    return (
      <>
        <h1 className="title">Dashboard</h1>
        <input id="nameInput" type="text" />
      </>
    );
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * JSX는 빌드시 `React.createElement`로 변환될 수 있다.

---

### 4. 컴포넌트: 함수형·클래스형, 합성과 재사용

컴포넌트 구조와 합성 방법을 학습했다.

* **학습 목표 (Why?)**
  UI를 독립된 컴포넌트 단위로 설계해 유지보수성과 테스트 용이성을 높이기 위함이다.

* **핵심 원리 (What?)**

  * 함수형 컴포넌트는 간결하고 훅을 사용할 수 있다.
  * 클래스 컴포넌트는 레거시이지만 라이프사이클 메서드를 포함할 수 있다.
  * 작은 컴포넌트를 합성해 큰 UI를 구성할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // 함수형
  const ProductList = () => (
    <ul>
      <li>Product A</li><li>Product B</li>
    </ul>
  );

  // 클래스형
  class UserProfile extends React.Component {
    render() {
      return <h1>User Profile</h1>;
    }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 컴포넌트 이름은 반드시 대문자로 시작해야 React가 사용자 정의로 인식할 수 있다.

---

### 5. `props`와 `props.children`

부모-자식 데이터 전달과 children 합성 패턴을 학습했다.

* **학습 목표 (Why?)**
  데이터 흐름을 단방향으로 유지하고, 범용 레이아웃을 구현하기 위함이다.

* **핵심 원리 (What?)**

  * `props`는 읽기 전용일 수 있다.
  * `props.children`은 태그 사이의 내용을 전달할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  function ProductItem({ product }) {
    return <div>{product.name} - {product.price}</div>;
  }

  const Card = ({ children }) =>
    <div className="card">{children}</div>;
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * 리스트 렌더링 시 key를 반드시 지정해야 성능 최적화를 할 수 있다.
  * 데이터는 부모에서 가공 후 자식에 전달하는 것이 좋을 수 있다.

---

### 6. 이벤트 바인딩과 합성 이벤트

React의 이벤트 처리 방식을 학습했다.

* **학습 목표 (Why?)**
  가상 DOM 렌더링과 호환되는 안정적인 이벤트 처리 방식을 사용하기 위함이다.

* **핵심 원리 (What?)**

  * JSX 이벤트는 camelCase로 작성할 수 있다.
  * 이벤트 핸들러는 함수 참조를 전달해야 한다.

* **문법 및 사용법 (How?)**

  ```jsx
  const OrderButton = () => {
    const handleClick = () => console.log("Order submitted");
    return <button onClick={handleClick}>Submit Order</button>;
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * DOM API 직접 바인딩은 렌더 타이밍 문제를 일으킬 수 있다.
  * 빈번한 이벤트 핸들러는 `useCallback`으로 메모이제이션할 수 있다.

---

### 7. 상태값과 `useState`

상태 관리와 불변성 개념을 학습했다.

* **학습 목표 (Why?)**
  상태에 따른 UI 갱신을 선언적으로 관리하기 위함이다.

* **핵심 원리 (What?)**

  * `useState`는 `[state, setState]` 배열을 반환할 수 있다.
  * 상태는 불변성을 유지해야 한다.
  * `setState`는 비동기이므로 이전 값 의존 시 함수형 업데이트를 사용할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const [count, setCount] = useState(0);
  const inc = () => setCount(prev => prev + 1);
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * `setState` 직후 콘솔 로그는 이전 값을 출력할 수 있다.

---

### 8. CSS 파일 분리와 스타일링

React 컴포넌트의 스타일링 방법을 학습했다.

* **학습 목표 (Why?)**
  구조와 스타일을 분리해 유지보수성과 확장성을 높이기 위함이다.

* **핵심 원리 (What?)**

  * CSS를 별도 파일로 관리하고 import해서 적용할 수 있다.
  * 클래스 네이밍 규칙(BEM)을 적용해 충돌을 방지할 수 있다.
  * 미디어쿼리로 반응형 디자인을 구현할 수 있다.

* **문법 및 사용법 (How?)**

  ```css
  /* Product.css */
  .product-card { ... }
  .product-card__title { ... }
  @media (max-width: 600px) {
    .product-card { flex-direction: column; }
  }
  ```

  ```jsx
  import './Product.css';
  function ProductCard({ product }) {
    return <div className="product-card">{product.name}</div>;
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**

  * CSS 클래스는 전역 충돌이 발생할 수 있으므로 명확한 네이밍을 할 수 있다.
  * CSS Modules, styled-components 같은 도구를 사용할 수도 있다.

---

## 오늘의 깨달음 💡

* React는 선언적 렌더링과 컴포넌트 구조를 통해 UI 복잡도를 크게 줄일 수 있다.

* JSX 문법 규칙(className, Fragment 등)을 지켜야 빌드 오류를 예방할 수 있다.

* props와 children 패턴으로 데이터와 레이아웃을 유연하게 전달할 수 있다.

* 이벤트 바인딩은 DOM 직접 조작보다 React 합성 이벤트 모델을 사용하는 것이 안전하다.

* `useState`의 불변성과 함수형 업데이트 패턴을 지키면 예측 가능한 UI 갱신이 가능하다.

* CSS를 분리하고 네이밍 규칙을 적용하면 스타일 충돌을 예방할 수 있다.