# TIL - 2025.08.29 - React Router v6: 라우팅, 레이아웃, 파라미터/쿼리, 에러 처리 심화 개념 이해

## 카테고리 🏷️

#TIL #React #JavaScript #Frontend #SPA #ReactRouter #NestedRoutes #Layout #useParams #useSearchParams

---

## 오늘 배운 내용 🔍

* SPA에서의 라우팅 개념과 필요성
* React Router 설치, `createBrowserRouter`/`RouterProvider` 기본 설정
* 첫 라우트 구성과 `Link`/`NavLink` 차이
* 레이아웃(공통 UI)과 중첩 라우팅, `Outlet`
* `errorElement`와 `useRouteError`로 404/예외 처리
* 동적 세그먼트 `:id`와 `useParams`
* 검색 쿼리 관리 `useSearchParams` (필터/정렬/페이지네이션, 디바운싱)
* 실무형 예시: 블로그 목록/상세/사이드바/필터를 라우팅으로 연결

---

## 어려웠던 점 💣

* `a` 태그를 쓰면 SPA 특성(상태 유지, 부드러운 전환)이 깨지는 이유를 `Link` 관점으로 재정리하는 데 시간이 걸렸다.

* 중첩 라우팅에서 부모 레이아웃의 `Outlet`과 자식 경로(`index`, 상대경로)를 머릿속으로 트리 구조처럼 그려 이해해야 했다.

* `useSearchParams`로 필터를 유지하면서 URL 동기화할 때 초기값/형변환/디바운싱 타이밍을 조절하는 부분이 헷갈렸다.

* 에러 처리에서 에러 버블링(가까운 `errorElement`로 전파) 개념을 실제 트리와 매칭해보며 정리했다.

---

## 정리 🖇️

### 1. 라우팅이란?

**학습 목표 (Why?)**
URL에 따라 알맞은 화면으로 사용자를 안내하고, SPA에서 새로고침 없이 앱처럼 자연스럽게 이동시키기 위함이다.

**핵심 원리 (What?)**

* 경로(path)와 화면(element)을 매핑하여 페이지 전환을 제어할 수 있다.
* SPA에서 실제 문서 교체 없이 뷰만 바꿔 UX를 개선할 수 있다.
* 명확한 URL 설계로 북마크/공유/접근성을 강화할 수 있다.

**문법 및 사용법 (How?)**

* 주소 `/about` → 회사 소개 화면, `/products` → 상품 목록처럼 경로별 컴포넌트를 매핑한다.
* React Router로 이 매핑을 선언적으로 구성한다.

**주의사항 및 실무 팁 (Watch out for)**

* 모든 것을 한 페이지에 넣지 않고 경로를 구조화해야 유지보수를 쉽게 할 수 있다.
* URL은 정보 구조를 반영하도록 의미 있게 설계할 수 있다.

> 라우팅의 개념과 SPA에서의 필요성을 학습했다.

---

### 2. React Router 설치 및 기본 설정

**학습 목표 (Why?)**
프로젝트에 라우팅 기능을 도입하고 기본 동작을 구성하기 위함이다.

**핵심 원리 (What?)**

* `react-router-dom` 패키지를 설치하고 `createBrowserRouter`로 라우터를 만들 수 있다.
* `RouterProvider`로 애플리케이션에 라우터를 주입할 수 있다.

**문법 및 사용법 (How?)**

```bash
npm install react-router-dom
```

```jsx
// App.jsx
import { RouterProvider } from 'react-router-dom';
import { router } from './routes/router-config.jsx';

const App = () => <RouterProvider router={router} />;
export default App;
```

```jsx
// routes/router-config.jsx
import { createBrowserRouter } from 'react-router-dom';
import RootLayout from '../layouts/RootLayout.jsx';
import IndexPage from '../pages/IndexPage.jsx';
import AboutPage from '../pages/AboutPage.jsx';
import ErrorPage from '../pages/ErrorPage.jsx';

export const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <ErrorPage />,
    children: [
      { index: true, element: <IndexPage /> },
      { path: 'about', element: <AboutPage /> },
    ],
  },
]);
```

**주의사항 및 실무 팁 (Watch out for)**

* 라우터 설정은 파일로 분리해 가독성과 테스트 용이성을 높일 수 있다.
* Node LTS, 패키지 잠금 파일을 통해 환경을 안정화할 수 있다.

> React Router의 설치와 기본 주입 구조를 학습했다.

---

### 3. 첫 번째 라우터 만들기

**학습 목표 (Why?)**
최소 라우트로 홈/소개 같은 정적 페이지 이동을 구현하기 위함이다.

**핵심 원리 (What?)**

* 경로-컴포넌트 매핑을 배열로 선언할 수 있다.
* 페이지 이동에는 `Link`를 사용해 새로고침 없이 전환할 수 있다.

**문법 및 사용법 (How?)**

```jsx
// 간단한 페이지
function Home() { return <h1>환영합니다!</h1>; }
function About() { return <h1>회사 소개입니다</h1>; }

// 매핑
const router = createBrowserRouter([
  { path: '/', element: <Home /> },
  { path: '/about', element: <About /> }
]);

// 이동
import { Link } from 'react-router-dom';
<Link to="/">홈</Link>
<Link to="/about">회사소개</Link>
```

**주의사항 및 실무 팁 (Watch out for)**

* `a` 태그를 쓰면 문서가 새로고침되어 상태가 초기화될 수 있다.
* Link의 `to`는 절대/상대 경로 모두 사용할 수 있다.

> 최초 라우트 구성과 `Link` 기반 전환을 학습했다.

---

### 4. `createBrowserRouter` 이해하기

**학습 목표 (Why?)**
중첩 라우트, 에러 처리 등 복잡한 구조를 선언적으로 관리하기 위함이다.

**핵심 원리 (What?)**

* `children`으로 중첩 구조를 만들 수 있다.
* `errorElement`로 라우트 단위 에러 화면을 지정할 수 있다.
* (확장) 데이터 로딩/변경(`loader`/`action`)을 라우트에 결합할 수 있다.

**문법 및 사용법 (How?)**

```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <ErrorPage />,
    children: [
      { index: true, element: <IndexPage /> },
      {
        path: 'blog',
        element: <BlogLayout />,
        children: [
          { index: true, element: <BlogPage /> },
          { path: ':postId', element: <BlogPostDetailPage /> },
        ],
      },
    ],
  },
]);
```

**주의사항 및 실무 팁 (Watch out for)**

* 경로 충돌 가능성이 있는 정적 경로(예: `new`)는 동적 경로(`:id`)보다 먼저 선언할 수 있다.
* 중첩이 깊어지면 책임을 레이아웃/페이지로 적절히 분리할 수 있다.

> 중첩 라우팅과 에러 처리 구성을 학습했다.

---

### 5. `Link`와 `NavLink`로 페이지 이동하기

**학습 목표 (Why?)**
메뉴/탭에서는 현재 위치를 강조하고, 일반 이동은 가볍게 처리하기 위함이다.

**핵심 원리 (What?)**

* `Link`는 단순 이동을 할 수 있다.
* `NavLink`는 `isActive`/`isPending`을 활용해 활성 스타일을 줄 수 있다.

**문법 및 사용법 (How?)**

```jsx
import { NavLink } from 'react-router-dom';

const MainNav = () => {
  const activate = ({ isActive }) => isActive ? 'menu-item active' : 'menu-item';
  return (
    <nav>
      <NavLink to="/" className={activate}>Home</NavLink>
      <NavLink to="/blog" className={activate}>Blog</NavLink>
      <NavLink to="/about" className={activate}>About</NavLink>
    </nav>
  );
};
```

**주의사항 및 실무 팁 (Watch out for)**

* 내비게이션/사이드바/탭에는 `NavLink`를 사용해 UX를 높일 수 있다.
* 스타일은 클래스 함수 패턴으로 일관성 있게 관리할 수 있다.

> 상황별로 `Link`/`NavLink`를 선택하는 기준을 학습했다.

---

### 6. 레이아웃 만들기 (`Outlet`)

**학습 목표 (Why?)**
헤더/푸터/사이드바 등 공통 레이아웃을 재사용하기 위함이다.

**핵심 원리 (What?)**

* 부모 라우트의 `element`에서 공통 UI를 선언하고, `Outlet`에 자식 페이지가 렌더링되도록 할 수 있다.
* 섹션별로 레이아웃을 쪼개 중첩 레이아웃을 구성할 수 있다.

**문법 및 사용법 (How?)**

```jsx
// RootLayout.jsx
import { Outlet } from 'react-router-dom';
const RootLayout = () => (
  <div>
    <header>{/* MainNav */}</header>
    <main><Outlet /></main>
    <footer>© 2025</footer>
  </div>
);

// BlogLayout.jsx
const BlogLayout = () => (
  <div className="blog-layout">
    <BlogSideBar />
    <main><Outlet /></main>
  </div>
);
```

**주의사항 및 실무 팁 (Watch out for)**

* 레이아웃은 레이아웃 역할(구조/공통 UI)에 집중하게 하고 비즈니스 로직은 페이지 컴포넌트에 둘 수 있다.
* SCSS/CSS 모듈로 레이아웃 스타일을 캡슐화할 수 있다.

> `Outlet` 기반 공통 레이아웃과 중첩 레이아웃 패턴을 학습했다.

---

### 7. 에러 페이지 처리 (`errorElement`, `useRouteError`)

**학습 목표 (Why?)**
없는 경로(404)나 예외 상황에서 친절한 안내를 제공하기 위함이다.

**핵심 원리 (What?)**

* 각 라우트에 `errorElement`를 지정하여 에러 발생 시 해당 컴포넌트를 렌더할 수 있다.
* `useRouteError`로 구체적인 에러 정보를 표시할 수 있다.
* 에러는 가까운 `errorElement`로 버블링되어 적절한 범위로 처리할 수 있다.

**문법 및 사용법 (How?)**

```jsx
// ErrorPage.jsx
import { Link, useRouteError } from 'react-router-dom';

const ErrorPage = () => {
  const error = useRouteError();
  const message = error?.status === 404
    ? '페이지를 찾을 수 없습니다'
    : (error?.message ?? '알 수 없는 에러가 발생했습니다');

  return (
    <div className="error">
      <h1>앗! 문제가 발생했어요</h1>
      <p>{message}</p>
      <Link to="/">홈으로 돌아가기</Link>
    </div>
  );
};
```

**주의사항 및 실무 팁 (Watch out for)**

* 관리자 등 특정 섹션에는 별도의 `errorElement`를 둬 맞춤 안내를 할 수 있다.
* 페이지 초기 로딩/네트워크 에러 메시지를 사용자 친화적으로 표현할 수 있다.

> 라우트 범위의 에러 처리와 버블링 동작을 학습했다.

---

### 8. URL 파라미터 사용하기 (`:id`) & `useParams`

**학습 목표 (Why?)**
동적 상세 페이지(게시글/상품/프로필 등)를 하나의 컴포넌트로 처리하기 위함이다.

**핵심 원리 (What?)**

* 경로에서 `:param` 형태로 동적 세그먼트를 선언할 수 있다.
* 컴포넌트에서 `useParams`로 파라미터를 읽어 로직에 활용할 수 있다.

**문법 및 사용법 (How?)**

```jsx
// 라우트
{ path: 'blog/:postId', element: <BlogPostDetailPage /> }

// 컴포넌트
import { useParams } from 'react-router-dom';
const BlogPostDetailPage = () => {
  const { postId } = useParams();      // 항상 문자열
  const id = Number(postId);           // 필요 시 형변환
  // id 검증/데이터 조회...
  return <div>글 번호: {id}</div>;
};
```

**주의사항 및 실무 팁 (Watch out for)**

* 파라미터는 문자열이므로 숫자 사용 시 형변환/검증을 할 수 있다.
* `/blog/new` 같은 정적 경로는 동적 경로보다 먼저 선언할 수 있다.

> 동적 경로와 `useParams` 활용 패턴을 학습했다.

---

### 9. 검색 쿼리 다루기 (`useSearchParams`)

**학습 목표 (Why?)**
필터/정렬/페이지네이션 상태를 URL과 동기화해 공유 가능하고 재현 가능한 UI를 만들기 위함이다.

**핵심 원리 (What?)**

* `useSearchParams`로 쿼리를 읽고/설정할 수 있다.
* `get`, `getAll`, `has`, 그리고 `set/delete`를 통해 상태를 URL에 반영할 수 있다.

**문법 및 사용법 (How?)**

```jsx
import { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';

const BlogFilter = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const [searchValue, setSearchValue] = useState(searchParams.get('search') || '');

  const handleCategory = e => setSearchParams(prev => { prev.set('category', e.target.value); return prev; });
  const handleSort = e => setSearchParams(prev => { prev.set('sort', e.target.value); return prev; });

  // 디바운싱으로 입력 부담 감소
  useEffect(() => {
    const t = setTimeout(() => {
      setSearchParams(prev => {
        if (searchValue.trim()) prev.set('search', searchValue.trim());
        else prev.delete('search');
        return prev;
      });
    }, 500);
    return () => clearTimeout(t);
  }, [searchValue, setSearchParams]);

  return (
    <div>
      <select onChange={handleCategory} value={searchParams.get('category') || 'all'}>{/* ... */}</select>
      <select onChange={handleSort} value={searchParams.get('sort') || 'latest'}>{/* ... */}</select>
      <input value={searchValue} onChange={e => setSearchValue(e.target.value)} placeholder="검색어" />
    </div>
  );
};
```

**주의사항 및 실무 팁 (Watch out for)**

* 값은 문자열이므로 숫자/불리언은 형변환을 할 수 있다.
* 기본값을 명확히 두고, 비어있을 때는 쿼리를 제거하여 URL을 깔끔히 유지할 수 있다.
* 디바운싱으로 과도한 업데이트를 줄일 수 있다.

> URL 쿼리 상태 동기화와 디바운싱 전략을 학습했다.

---

### 10. 중첩 라우팅 심화

**학습 목표 (Why?)**
섹션별 레이아웃, 탭/서브메뉴 등 계층형 UI를 라우팅으로 구조화하기 위함이다.

**핵심 원리 (What?)**

* 부모 레이아웃 + 자식 페이지 패턴으로 공통 UI를 재사용할 수 있다.
* `index: true`로 기본 자식 경로를 지정할 수 있다.
* 상대 경로(`to="new"`, `to="../"`)로 선언적 이동을 구성할 수 있다.

**문법 및 사용법 (How?)**

```jsx
{
  path: 'blog',
  element: <BlogLayout />,
  children: [
    { index: true, element: <BlogPage /> },          // /blog
    { path: ':postId', element: <BlogPostDetailPage /> } // /blog/123
  ]
}
```

**주의사항 및 실무 팁 (Watch out for)**

* 3\~4단계를 넘는 깊은 중첩은 복잡도를 높일 수 있으니 책임을 분할할 수 있다.
* 정적 경로를 동적 경로보다 먼저 선언하여 충돌을 방지할 수 있다.

> 레이아웃/자식 조합으로 계층형 UI를 설계하는 방법을 학습했다.

---

### 11. 실무 예시 통합: 블로그 라우팅

**학습 목표 (Why?)**
목록/상세/필터/사이드바를 하나의 라우팅 체계로 동작시키기 위함이다.

**핵심 원리 (What?)**

* `RootLayout`(헤더/푸터/메인) + `BlogLayout`(사이드바/콘텐츠)로 중첩 레이아웃을 구성할 수 있다.
* `BlogPage`는 `useSearchParams`로 카테고리/검색/정렬을 반영한 목록을 렌더링할 수 있다.
* `PostCard`는 `Link`로 상세 경로(`/blog/:postId`)에 진입할 수 있다.
* `MainNav`는 `NavLink`로 현재 메뉴 상태를 표시할 수 있다.
* `ErrorPage`는 404/기타 예외를 사용자 친화적으로 안내할 수 있다.

**문법 및 사용법 (How?)**

* `router-config.jsx`: `RootLayout` → `IndexPage`/`AboutPage`/`BlogLayout(→ BlogPage, BlogPostDetailPage)`
* `BlogFilter`: `useSearchParams`로 쿼리 동기화(디바운싱 포함)
* `BlogSideBar`: `useNavigate` + `setSearchParams`로 사이드바 클릭 시 목록으로 이동하며 필터 적용
* `PostCard`: 상세 링크 이동
* `ErrorPage`: `useRouteError`로 상태별 메시지 분기

**주의사항 및 실무 팁 (Watch out for)**

* 필터 UI와 목록은 URL을 단일 진실 원천으로 삼아 새로고침/공유 시에도 같은 화면을 재현할 수 있다.
* SCSS 모듈로 페이지/레이아웃 스타일을 캡슐화하여 충돌을 방지할 수 있다.

> 블로그 예시를 통해 중첩 라우팅·필터·상세 이동·에러 처리의 통합 패턴을 학습했다.

---

## 오늘의 깨달음 💡

* SPA에서 라우팅은 “URL = 상태”라는 관점으로 봐야 재현성과 협업 효율이 올라간다.

* `Link`/`NavLink`/`Outlet`/`errorElement`/`useParams`/`useSearchParams` 조합만으로도 대부분의 웹앱 네비게이션 요구를 충족할 수 있다.

* 중첩 라우팅은 레이아웃 재사용과 정보 구조를 일치시키는 강력한 도구다.
 
* 쿼리 동기화 시 디바운싱과 기본값/형변환을 명확히 하면 버그가 줄어든다.