# TIL - 2025.08.27 - 입력 검증, 동적 스타일링, CSS Modules·Sass 적용 및 상태 끌어올리기 개념 이해

## 카테고리 🏷️

#TIL #React #JavaScript #Frontend #StateManagement #LiftingStateUp #Validation #DynamicStyling #CSSModules #Sass

---

## 오늘 배운 내용 🔍

* 상향식 데이터 전달로 입력폼(UserInput) → 리스트(App)까지 사용자 항목 추가/삭제 흐름 구성
* 입력값 검증 상태를 null/boolean으로 관리하며 에러 스타일을 동적으로 토글
* 인라인 스타일 동적 적용 vs 클래스 토글 방식의 장단점 비교
* CSS Modules로 클래스 충돌 방지 및 대시(-) 포함 클래스 키 다루기(구조분해 할당)
* 동적 클래스 결합(`${styles['form-control']} ${isValid === false && styles.invalid}`) 패턴
* react-icons, Sass 설치 및 사용 목적 이해
* SCSS 변수, 중첩, 부모 선택자(&), 믹스인(@mixin/@include)로 재사용 가능한 스타일 구성
* 리스트 렌더링 시 key, 이벤트 위임/핸들러 설계 및 불변성 업데이트 패턴 확인

---

## 어려웠던 점 💣

* isValid 초기값을 false로 두면, 입력 전부터 에러 스타일이 적용되는 문제를 겪었다. null을 사용해 “아직 판정하지 않음” 상태를 분리해야 했다.

* 인라인 스타일을 조건부로 넣는 방식은 간단하지만, 우선순위(Specificity)와 재사용성 한계 때문에 실제 컴포넌트 확장 시 스타일 충돌이 생길 수 있었다.

* CSS Modules에서 `form-control`처럼 대시가 포함된 클래스 키를 다룰 때, `styles['form-control']` 접근과 구조분해(`const {'form-control': formControl}`)의 차이를 한 번에 정리하기가 헷갈렸다.

* 리스트 삭제 로직에서 `setUsers(users.filter(...))`처럼 현재 클로저의 users를 참조하면 간헐적으로 최신 상태가 반영되지 않을 여지가 있어, 함수형 업데이트가 언제 필요한지 경계가 필요했다.

---

## 정리 🖇️

### 1. 상태 끌어올리기와 리스트 추가/삭제

상위(App)에서 users 배열을 상태로 관리하고, 하위(UserInput/UserList)가 콜백으로 상위 상태를 갱신하는 상향식 흐름을 학습했다.

* **학습 목표 (Why?)**
  입력 폼의 로컬 상태와 리스트의 전역 상태를 분리하고 단방향 데이터 흐름을 유지해 예측 가능한 업데이트를 보장하기 위함이다.

* **핵심 원리 (What?)**
  부모가 상태를 소유하고 자식에게 **함수형 props**를 내려 이벤트 발생 시 상위에서 상태를 갱신하게 할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // App.jsx
  const [users, setUsers] = useState([{ id:'u1', name:'홍길동' }, { id:'u2', name:'김철수' }]);

  const onAddUser = (name) => {
    const newUser = { id: Math.random().toString(), name };
    setUsers(prev => [...prev, newUser]); // 불변성 유지
  };

  const onDeleteUser = (targetId) => {
    setUsers(prev => prev.filter(u => u.id !== targetId)); // 함수형 업데이트 권장
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  비동기 상태 업데이트 특성상 **이전 상태에 의존**할 때는 `setState(prev => ...)` 형태를 사용해야 일관된 결과를 보장할 수 있다.

---

### 2. 입력 검증 상태 설계(null/boolean)와 폼 제출

유효성 판정을 “아직 안 함(null)”과 “유효/무효(boolean)”로 구분하여 UX 왜곡을 방지하는 패턴을 학습했다.

* **학습 목표 (Why?)**
  사용자가 입력을 시작하기도 전에 에러 상태가 노출되는 것을 피하고, 검증 타이밍을 명확히 분리하기 위함이다.

* **핵심 원리 (What?)**
  검증 상태는 `null | true | false`로 삼분화하여 시점 제어를 명확히 할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  const [enteredName, setEnteredName] = useState('');
  const [isValid, setIsValid] = useState(null); // null = 미판정

  const submitHandler = (e) => {
    e.preventDefault();
    if (!enteredName.trim()) { setIsValid(false); return; }
    onAddUser(enteredName);
    setEnteredName('');
    setIsValid(true);
  };

  const inputHandler = (e) => {
    const v = e.target.value;
    if (v.trim()) setIsValid(true);
    setEnteredName(v);
  };
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  에러 표시 기준을 명확히 하고, 제출 시만 판정하거나 입력 변경 시 부분 판정하는 등 **검증 트리거를 일관되게** 설계할 수 있다.

---

### 3. 동적 인라인 스타일 vs 클래스 토글

동적 인라인 스타일은 빠르게 적용 가능하지만 재사용성과 우선순위 관리가 어렵고, 클래스 토글은 스타일 재사용 및 설계가 수월하다는 점을 학습했다.

* **학습 목표 (Why?)**
  컴포넌트가 커질수록 유지보수를 고려한 **스타일 적용 전략**이 필요하기 위함이다.

* **핵심 원리 (What?)**
  인라인 스타일은 우선순위가 높아 오버라이드가 어렵고, 클래스 토글은 선언적·재사용적 스타일 관리를 할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // 인라인 (간단하지만 재사용성 낮음)
  <label style={{ color: isValid === false ? 'red' : 'black' }}>사용자 이름</label>

  // 클래스 토글 (권장)
  <div className={`form-control ${isValid === false ? 'invalid' : ''}`}>...</div>
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  테마/상태가 다층적으로 얽히는 경우 클래스 설계(BEM, 상태 클래스)가 확장성과 일관성을 높일 수 있다.

---

### 4. CSS Modules 기본과 동적 클래스 결합

CSS Modules로 클래스 충돌을 방지하고, 대시가 포함된 클래스 키를 안전하게 다루는 법을 학습했다.

* **학습 목표 (Why?)**
  전역 클래스 충돌을 제거하고, 컴포넌트 스코프에서 스타일을 안전하게 재사용하기 위함이다.

* **핵심 원리 (What?)**
  CSS Modules는 컴파일 타임에 **고유한 클래스명**을 생성해 충돌 없이 스타일을 적용할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  import styles from './UserInput.module.css';

  const { 'form-control': formControl, invalid } = styles;

  <div className={`${formControl} ${isValid === false ? invalid : ''}`}>
    ...
  </div>

  <ul className={styles['user-list']}>...</ul>
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  조건부 결합은 템플릿 리터럴 외에도 `clsx` 같은 유틸을 사용할 수 있고, **상태 클래스**(`.invalid`)는 최소화하고 의미를 명확히 할 수 있다.

---

### 5. Styled-components vs CSS Modules 비교

프로젝트 특성에 따라 어떤 스타일링 전략을 선택할지 판단 기준을 학습했다.

* **학습 목표 (Why?)**
  팀/프로젝트의 규모, 동적 스타일 요구사항에 맞춰 **적합한 스타일링 도구**를 선택하기 위함이다.

* **핵심 원리 (What?)**
  CSS Modules는 전통 CSS를 모듈화해 **빌드 타임**에 처리할 수 있고, Styled-components는 **런타임** 주입과 props 기반 **동적 스타일**을 쉽게 다룰 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // CSS Modules
  import styles from './Button.module.css';
  <button className={styles.button}>저장</button>

  // Styled-components
  import styled from 'styled-components';
  const Button = styled.button`
    background: ${p => (p.primary ? '#38d9a9' : '#eee')};
  `;
  <Button primary>저장</Button>
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  런타임 오버헤드/SSR 고려가 필요하고, **동적 스타일이 많으면 Styled-components**, **정적·성능 우선이면 CSS Modules**를 우선 고려할 수 있다.

---

### 6. react-icons, Sass 설치와 목적

아이콘과 확장 CSS 문법(SCSS)을 도입해 생산성과 표현력을 높이는 방법을 학습했다.

* **학습 목표 (Why?)**
  반복되는 SVG/아이콘 자원 관리와 CSS 반복 코드를 줄여 UI 개발 속도를 높이기 위함이다.

* **핵심 원리 (What?)**
  `react-icons`로 다양한 아이콘 팩을 통합 사용하고, Sass로 변수/중첩/믹스인 등 **프로그래밍적 CSS**를 사용할 수 있다.

* **문법 및 사용법 (How?)**

  ```bash
  npm install react-icons
  npm install sass
  ```

  ```jsx
  import { FaUserPlus } from 'react-icons/fa';
  <button><FaUserPlus /></button>
  ```

  ```scss
  $my-dark-gray: #343a40;

  header {
    h1 { color: $my-dark-gray; }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  아이콘은 **의미/일관성**을 우선해 선택하고, Sass는 변수·믹스인 등 **반복 제거**에 집중해 유지보수성을 높일 수 있다.

---

### 7. SCSS 중첩, 부모 선택자(&), 믹스인(@mixin)

SCSS의 구조화와 재사용 기법으로 스타일 품질을 높이는 법을 학습했다.

* **학습 목표 (Why?)**
  트리 구조 중첩과 조각화된 믹스인으로 **가독성과 재사용성**을 동시에 확보하기 위함이다.

* **핵심 원리 (What?)**
  중첩 선택자, `&`(부모 참조), `@mixin/@include`로 **상태/변형 클래스**와 **공통 정렬**을 단일 원천으로 관리할 수 있다.

* **문법 및 사용법 (How?)**

  ```scss
  // 변수
  $btn-size: 80px;

  // 믹스인
  @mixin content-center {
    display: flex; justify-content: center; align-items: center;
  }

  .add-btn {
    width: $btn-size; height: $btn-size;

    &:hover { /* 상태 */ }
    &.open { transform: rotate(45deg); } // 변형 클래스
  }

  .user-list-item {
    .check-circle { @include content-center; &.active { color: #38d9a9; } }
    .name { &.inactive { text-decoration: line-through; } }
  }
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  과도한 중첩은 **특정성 폭증**을 야기하므로 3단계 이내를 권장하고, **상태 클래스는 낮은 특정성**을 유지해 재정의 여지를 남길 수 있다.

---

### 8. 리스트 렌더링과 아이템 제거 UX

아이템 클릭으로 삭제하는 단순 UX에서, 의도치 않은 삭제를 최소화하는 패턴을 함께 고려했다.

* **학습 목표 (Why?)**
  실수 삭제를 줄이고 접근성을 확보하는 안정적인 리스트 인터랙션을 제공하기 위함이다.

* **핵심 원리 (What?)**
  삭제는 명시적 **삭제 버튼**과 **호버 표시**, **확인 단계**로 설계할 수 있다.

* **문법 및 사용법 (How?)**

  ```jsx
  // UserItem.jsx
  const UserItem = ({ user, onDelete }) => (
    <li className="user-item">
      <span>{user.name}</span>
      <button className="remove" onClick={() => onDelete(user.id)}>삭제</button>
    </li>
  );
  ```

* **주의사항 및 실무 팁 (Watch out for)**
  키보드 접근성(Enter/Space), 포커스 스타일, 스크린리더 레이블(aria-label)을 더해 **접근성 기준**을 충족할 수 있다.

---

## 오늘의 깨달음 💡

* 검증 상태는 이진이 아니라 **미판정(null)** 단계를 두면 UX가 자연스러워진다.

* 인라인 조건부 스타일은 빠르지만, 규모를 생각하면 **클래스 토글 + CSS Modules**가 유지보수에 유리하다.

* 리스트 갱신은 항상 **함수형 업데이트**를 우선 고려하면 동시성 문제를 피할 수 있다.

* SCSS의 변수·믹스인·중첩·&만으로도 전역 유틸리티를 만들지 않고 충분히 재사용성을 확보할 수 있다.

* 아이콘과 스타일 도구는 “보여주기”보다 **일관성과 접근성**을 먼저 고려해야 실제 제품 품질이 올라간다.